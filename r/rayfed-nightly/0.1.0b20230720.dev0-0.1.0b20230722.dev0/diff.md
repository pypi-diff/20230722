# Comparing `tmp/rayfed_nightly-0.1.0b20230720.dev0-py3-none-any.whl.zip` & `tmp/rayfed_nightly-0.1.0b20230722.dev0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,30 +1,30 @@
-Zip file size: 41715 bytes, number of entries: 28
--rw-r--r--  2.0 unx      859 b- defN 23-Jul-20 01:33 fed/__init__.py
--rw-r--r--  2.0 unx    14394 b- defN 23-Jul-20 01:33 fed/api.py
--rw-r--r--  2.0 unx     3676 b- defN 23-Jul-20 01:33 fed/cleanup.py
--rw-r--r--  2.0 unx     6115 b- defN 23-Jul-20 01:33 fed/config.py
--rw-r--r--  2.0 unx     2877 b- defN 23-Jul-20 01:33 fed/fed_object.py
--rw-r--r--  2.0 unx     7908 b- defN 23-Jul-20 01:33 fed/tree_util.py
--rw-r--r--  2.0 unx     7519 b- defN 23-Jul-20 01:33 fed/utils.py
--rw-r--r--  2.0 unx      581 b- defN 23-Jul-20 01:33 fed/_private/__init__.py
--rw-r--r--  2.0 unx      581 b- defN 23-Jul-20 01:33 fed/_private/api.py
--rw-r--r--  2.0 unx     5269 b- defN 23-Jul-20 01:33 fed/_private/compatible_utils.py
--rw-r--r--  2.0 unx     1074 b- defN 23-Jul-20 01:33 fed/_private/constants.py
--rw-r--r--  2.0 unx     3837 b- defN 23-Jul-20 01:33 fed/_private/fed_actor.py
--rw-r--r--  2.0 unx     3947 b- defN 23-Jul-20 01:33 fed/_private/fed_call_holder.py
--rw-r--r--  2.0 unx     1262 b- defN 23-Jul-20 01:33 fed/_private/global_context.py
--rw-r--r--  2.0 unx     2419 b- defN 23-Jul-20 01:33 fed/_private/serialization_utils.py
--rw-r--r--  2.0 unx      581 b- defN 23-Jul-20 01:33 fed/grpc/__init__.py
--rw-r--r--  2.0 unx     2968 b- defN 23-Jul-20 01:33 fed/grpc/fed_pb2_grpc_in_protobuf3.py
--rw-r--r--  2.0 unx     2989 b- defN 23-Jul-20 01:33 fed/grpc/fed_pb2_grpc_in_protobuf4.py
--rw-r--r--  2.0 unx     2095 b- defN 23-Jul-20 01:33 fed/grpc/fed_pb2_in_protobuf3.py
--rw-r--r--  2.0 unx     2113 b- defN 23-Jul-20 01:33 fed/grpc/fed_pb2_in_protobuf4.py
--rw-r--r--  2.0 unx      613 b- defN 23-Jul-20 01:33 fed/proxy/__init__.py
--rw-r--r--  2.0 unx     9726 b- defN 23-Jul-20 01:33 fed/proxy/barriers.py
--rw-r--r--  2.0 unx     2019 b- defN 23-Jul-20 01:33 fed/proxy/base_proxy.py
--rw-r--r--  2.0 unx    11356 b- defN 23-Jul-20 01:35 rayfed_nightly-0.1.0b20230720.dev0.dist-info/LICENSE
--rw-r--r--  2.0 unx     7367 b- defN 23-Jul-20 01:35 rayfed_nightly-0.1.0b20230720.dev0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jul-20 01:35 rayfed_nightly-0.1.0b20230720.dev0.dist-info/WHEEL
--rw-r--r--  2.0 unx        4 b- defN 23-Jul-20 01:35 rayfed_nightly-0.1.0b20230720.dev0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2339 b- defN 23-Jul-20 01:35 rayfed_nightly-0.1.0b20230720.dev0.dist-info/RECORD
-28 files, 106580 bytes uncompressed, 37955 bytes compressed:  64.4%
+Zip file size: 41548 bytes, number of entries: 28
+-rw-r--r--  2.0 unx      859 b- defN 23-Jul-22 01:33 fed/__init__.py
+-rw-r--r--  2.0 unx    13013 b- defN 23-Jul-22 01:33 fed/api.py
+-rw-r--r--  2.0 unx     3676 b- defN 23-Jul-22 01:33 fed/cleanup.py
+-rw-r--r--  2.0 unx     6368 b- defN 23-Jul-22 01:33 fed/config.py
+-rw-r--r--  2.0 unx     2877 b- defN 23-Jul-22 01:33 fed/fed_object.py
+-rw-r--r--  2.0 unx     7908 b- defN 23-Jul-22 01:33 fed/tree_util.py
+-rw-r--r--  2.0 unx     7505 b- defN 23-Jul-22 01:33 fed/utils.py
+-rw-r--r--  2.0 unx      581 b- defN 23-Jul-22 01:33 fed/_private/__init__.py
+-rw-r--r--  2.0 unx      581 b- defN 23-Jul-22 01:33 fed/_private/api.py
+-rw-r--r--  2.0 unx     5269 b- defN 23-Jul-22 01:33 fed/_private/compatible_utils.py
+-rw-r--r--  2.0 unx     1074 b- defN 23-Jul-22 01:33 fed/_private/constants.py
+-rw-r--r--  2.0 unx     3851 b- defN 23-Jul-22 01:33 fed/_private/fed_actor.py
+-rw-r--r--  2.0 unx     3947 b- defN 23-Jul-22 01:33 fed/_private/fed_call_holder.py
+-rw-r--r--  2.0 unx     1262 b- defN 23-Jul-22 01:33 fed/_private/global_context.py
+-rw-r--r--  2.0 unx     2419 b- defN 23-Jul-22 01:33 fed/_private/serialization_utils.py
+-rw-r--r--  2.0 unx      581 b- defN 23-Jul-22 01:33 fed/grpc/__init__.py
+-rw-r--r--  2.0 unx     2968 b- defN 23-Jul-22 01:33 fed/grpc/fed_pb2_grpc_in_protobuf3.py
+-rw-r--r--  2.0 unx     2989 b- defN 23-Jul-22 01:33 fed/grpc/fed_pb2_grpc_in_protobuf4.py
+-rw-r--r--  2.0 unx     2095 b- defN 23-Jul-22 01:33 fed/grpc/fed_pb2_in_protobuf3.py
+-rw-r--r--  2.0 unx     2113 b- defN 23-Jul-22 01:33 fed/grpc/fed_pb2_in_protobuf4.py
+-rw-r--r--  2.0 unx      613 b- defN 23-Jul-22 01:33 fed/proxy/__init__.py
+-rw-r--r--  2.0 unx     9796 b- defN 23-Jul-22 01:33 fed/proxy/barriers.py
+-rw-r--r--  2.0 unx     2025 b- defN 23-Jul-22 01:33 fed/proxy/base_proxy.py
+-rw-r--r--  2.0 unx    11356 b- defN 23-Jul-22 01:35 rayfed_nightly-0.1.0b20230722.dev0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     7327 b- defN 23-Jul-22 01:35 rayfed_nightly-0.1.0b20230722.dev0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-22 01:35 rayfed_nightly-0.1.0b20230722.dev0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        4 b- defN 23-Jul-22 01:35 rayfed_nightly-0.1.0b20230722.dev0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2339 b- defN 23-Jul-22 01:35 rayfed_nightly-0.1.0b20230722.dev0.dist-info/RECORD
+28 files, 105488 bytes uncompressed, 37788 bytes compressed:  64.2%
```

## zipnote {}

```diff
@@ -63,23 +63,23 @@
 
 Filename: fed/proxy/barriers.py
 Comment: 
 
 Filename: fed/proxy/base_proxy.py
 Comment: 
 
-Filename: rayfed_nightly-0.1.0b20230720.dev0.dist-info/LICENSE
+Filename: rayfed_nightly-0.1.0b20230722.dev0.dist-info/LICENSE
 Comment: 
 
-Filename: rayfed_nightly-0.1.0b20230720.dev0.dist-info/METADATA
+Filename: rayfed_nightly-0.1.0b20230722.dev0.dist-info/METADATA
 Comment: 
 
-Filename: rayfed_nightly-0.1.0b20230720.dev0.dist-info/WHEEL
+Filename: rayfed_nightly-0.1.0b20230722.dev0.dist-info/WHEEL
 Comment: 
 
-Filename: rayfed_nightly-0.1.0b20230720.dev0.dist-info/top_level.txt
+Filename: rayfed_nightly-0.1.0b20230722.dev0.dist-info/top_level.txt
 Comment: 
 
-Filename: rayfed_nightly-0.1.0b20230720.dev0.dist-info/RECORD
+Filename: rayfed_nightly-0.1.0b20230722.dev0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## fed/api.py

```diff
@@ -11,15 +11,15 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 import functools
 import inspect
 import logging
-from typing import Any, Dict, List, Union, Optional
+from typing import Any, Dict, List, Union
 
 import cloudpickle
 import ray
 
 import fed._private.compatible_utils as compatible_utils
 import fed.config as fed_config
 import fed.utils as fed_utils
@@ -31,66 +31,44 @@
     ping_others,
     recv,
     send,
     _start_receiver_proxy,
     _start_sender_proxy,
 )
 from fed.proxy.grpc.grpc_proxy import SenderProxy, ReceiverProxy
-from fed.config import CrossSiloMessageConfig
+from fed.config import GrpcCrossSiloMessageConfig
 from fed.fed_object import FedObject
 from fed.utils import is_ray_object_refs, setup_logger
 
 logger = logging.getLogger(__name__)
 
 
 def init(
-    cluster: Dict = None,
+    addresses: Dict = None,
     party: str = None,
+    config: Dict = {},
     tls_config: Dict = None,
     logging_level: str = 'info',
-    enable_waiting_for_other_parties_ready: bool = False,
     sender_proxy_cls: SenderProxy = None,
     receiver_proxy_cls: ReceiverProxy = None,
-    global_cross_silo_message_config: Optional[CrossSiloMessageConfig] = None,
-    **kwargs,
 ):
     """
     Initialize a RayFed client.
 
     Args:
-        cluster: optional; a dict describes the cluster config. E.g.
+        addresses: optional; a dict describes the addresses configurations. E.g.
 
             .. code:: python
                 {
-                    'alice': {
-                        # The address for other parties.
-                        'address': '127.0.0.1:10001',
-                        # (Optional) the listen address, the `address` will be
-                        # used if not provided.
-                        'listen_addr': '0.0.0.0:10001',
-                        'cross_silo_message_config': CrossSiloMessageConfig
-                    },
-                    'bob': {
-                        # The address for other parties.
-                        'address': '127.0.0.1:10002',
-                        # (Optional) the listen address, the `address` will be
-                        # used if not provided.
-                        'listen_addr': '0.0.0.0:10002',
-                        # (Optional) The party specific metadata sent with grpc requests
-                        'grpc_metadata': (('token', 'bob-token'),),
-                    },
-                    'carol': {
-                        # The address for other parties.
-                        'address': '127.0.0.1:10003',
-                        # (Optional) the listen address, the `address` will be
-                        # used if not provided.
-                        'listen_addr': '0.0.0.0:10003',
-                        # (Optional) The party specific metadata sent with grpc requests
-                        'grpc_metadata': (('token', 'carol-token'),),
-                    },
+                    # The address that can be connected to `alice` by other parties.
+                    'alice': '127.0.0.1:10001',
+                    # The address that can be connected to `bob` by other parties.
+                    'bob': '127.0.0.1:10002',
+                    # The address that can be connected to `carol` by other parties.
+                    'carol': '127.0.0.1:10003',
                 }
         party: optional; self party.
         tls_config: optional; a dict describes the tls config. E.g.
             For alice,
 
             .. code:: python
                 {
@@ -105,58 +83,54 @@
                 {
                     "ca_cert": "root ca cert of other parties.",
                     "cert": "bob's server cert",
                     "key": "bob's server cert key",
                 }
         logging_level: optional; the logging level, could be `debug`, `info`,
             `warning`, `error`, `critical`, not case sensititive.
-        enable_waiting_for_other_parties_ready: ping other parties until they
-            are all ready if True.
-        global_cross_silo_message_config: Global cross-silo message related
-            configs that are applied to all connections. Supported configs
-            can refer to CrossSiloMessageConfig in config.py.
 
     Examples:
         >>> import fed
         >>> import ray
         >>> ray.init(address='local')
-        >>> cluster = {
-        >>>    'alice': {'address': '127.0.0.1:10001'},
-        >>>    'bob': {'address': '127.0.0.1:10002'},
-        >>>    'carol': {'address': '127.0.0.1:10003'},
+        >>> addresses = {
+        >>>    'alice': '127.0.0.1:10001',
+        >>>    'bob': '127.0.0.1:10002',
+        >>>    'carol': '127.0.0.1:10003',
         >>> }
         >>> # Start as alice.
-        >>> fed.init(cluster=cluster, self_party='alice')
+        >>> fed.init(addresses=addresses, party='alice')
     """
-    assert cluster, "Cluster should be provided."
+    assert addresses, "Addresses should be provided."
     assert party, "Party should be provided."
-    assert party in cluster, f"Party {party} is not in cluster {cluster}."
+    assert party in addresses, f"Party {party} is not in the addresses {addresses}."
 
-    fed_utils.validate_cluster_info(cluster)
+    fed_utils.validate_addresses(addresses)
 
     tls_config = {} if tls_config is None else tls_config
     if tls_config:
         assert (
             'cert' in tls_config and 'key' in tls_config
         ), 'Cert or key are not in tls_config.'
 
-    global_cross_silo_message_config = \
-        global_cross_silo_message_config or CrossSiloMessageConfig()
+    cross_silo_message_dict = config.get("cross_silo_message", {})
+    cross_silo_message_config = GrpcCrossSiloMessageConfig.from_dict(
+        cross_silo_message_dict)
     # A Ray private accessing, should be replaced in public API.
     compatible_utils._init_internal_kv()
 
     cluster_config = {
-        constants.KEY_OF_CLUSTER_ADDRESSES: cluster,
+        constants.KEY_OF_CLUSTER_ADDRESSES: addresses,
         constants.KEY_OF_CURRENT_PARTY_NAME: party,
         constants.KEY_OF_TLS_CONFIG: tls_config,
     }
 
     job_config = {
         constants.KEY_OF_CROSS_SILO_MESSAGE_CONFIG:
-            global_cross_silo_message_config,
+            cross_silo_message_config,
     }
     compatible_utils.kv.put(constants.KEY_OF_CLUSTER_CONFIG,
                             cloudpickle.dumps(cluster_config))
     compatible_utils.kv.put(constants.KEY_OF_JOB_CONFIG, cloudpickle.dumps(job_config))
     # Set logger.
     # Note(NKcqx): This should be called after internal_kv has party value, i.e.
     # after `ray.init` and
@@ -166,63 +140,64 @@
         logging_format=constants.RAYFED_LOG_FMT,
         date_format=constants.RAYFED_DATE_FMT,
         party_val=_get_party(),
     )
 
     logger.info(f'Started rayfed with {cluster_config}')
     get_global_context().get_cleanup_manager().start(
-        exit_when_failure_sending=global_cross_silo_message_config.exit_on_sending_failure) # noqa
+        exit_when_failure_sending=cross_silo_message_config.exit_on_sending_failure) # noqa
 
     if receiver_proxy_cls is None:
         logger.debug(
             "There is no receiver proxy class specified, it uses `GrpcRecvProxy` by "
             "default.")
         from fed.proxy.grpc.grpc_proxy import GrpcReceiverProxy
         receiver_proxy_cls = GrpcReceiverProxy
     _start_receiver_proxy(
-        cluster=cluster,
+        addresses=addresses,
         party=party,
         logging_level=logging_level,
         tls_config=tls_config,
         proxy_cls=receiver_proxy_cls,
-        proxy_config=global_cross_silo_message_config
+        proxy_config=cross_silo_message_config
     )
 
     if sender_proxy_cls is None:
         logger.debug(
             "There is no sender proxy class specified, it uses `GrpcRecvProxy` by "
             "default.")
         from fed.proxy.grpc.grpc_proxy import GrpcSenderProxy
         sender_proxy_cls = GrpcSenderProxy
     _start_sender_proxy(
-        cluster=cluster,
+        addresses=addresses,
         party=party,
         logging_level=logging_level,
         tls_config=tls_config,
         proxy_cls=sender_proxy_cls,
-        proxy_config=global_cross_silo_message_config
+        # TODO(qwang): proxy_config -> cross_silo_message_config
+        proxy_config=cross_silo_message_config
     )
 
-    if enable_waiting_for_other_parties_ready:
+    if config.get("barrier_on_initializing", False):
         # TODO(zhouaihui): can be removed after we have a better retry strategy.
-        ping_others(cluster=cluster, self_party=party, max_retries=3600)
+        ping_others(addresses=addresses, self_party=party, max_retries=3600)
 
 
 def shutdown():
     """
     Shutdown a RayFed client.
     """
     compatible_utils._clear_internal_kv()
     clear_global_context()
     logger.info('Shutdowned rayfed.')
 
 
-def _get_cluster():
+def _get_addresses():
     """
-    Get the RayFed cluster configration.
+    Get the RayFed addresses configration.
     """
     return fed_config.get_cluster_config().cluster_addresses
 
 
 def _get_party():
     """
     A private util function to get the current party name.
@@ -286,15 +261,15 @@
         self._options = options
         return self
 
     def remote(self, *cls_args, **cls_kwargs):
         fed_class_task_id = get_global_context().next_seq_id()
         fed_actor_handle = FedActorHandle(
             fed_class_task_id,
-            _get_cluster(),
+            _get_addresses(),
             self._cls,
             _get_party(),
             self._party,
             self._options,
         )
         fed_call_holder = FedCallHolder(
             self._party, fed_actor_handle._execute_impl, self._options
@@ -337,15 +312,15 @@
     """
     if is_ray_object_refs(fed_objects):
         return ray.get(fed_objects)
 
     # A fake fed_task_id for a `fed.get()` operator. This is useful
     # to help contruct the whole DAG within `fed.get`.
     fake_fed_task_id = get_global_context().next_seq_id()
-    cluster = _get_cluster()
+    addresses = _get_addresses()
     current_party = _get_party()
     is_individual_id = isinstance(fed_objects, FedObject)
     if is_individual_id:
         fed_objects = [fed_objects]
 
     ray_refs = []
     for fed_object in fed_objects:
@@ -353,15 +328,15 @@
             # The code path of the fed_object is in current party, so
             # need to boardcast the data of the fed_object to other parties,
             # and then return the real data of that.
             ray_object_ref = fed_object.get_ray_object_ref()
             assert ray_object_ref is not None
             ray_refs.append(ray_object_ref)
 
-            for party_name in cluster:
+            for party_name in addresses:
                 if party_name == current_party:
                     continue
                 else:
                     if fed_object._was_sending_or_sent_to_party(party_name):
                         # This object was sending or sent to the target party,
                         # so no need to do it again.
                         continue
```

## fed/config.py

```diff
@@ -108,14 +108,17 @@
     timeout_in_ms: int = 60000
     messages_max_size_in_bytes: int = None
     exit_on_sending_failure: Optional[bool] = False
     serializing_allowed_list: Optional[Dict[str, str]] = None
     send_resource_label: Optional[Dict[str, str]] = None
     recv_resource_label: Optional[Dict[str, str]] = None
     http_header: Optional[Dict[str, str]] = None
+    # (Optional) The address this party is going to listen on.
+    # If not provided, the `address` will be used.
+    listening_address: str = None
 
     def __json__(self):
         return json.dumps(self.__dict__)
 
     @classmethod
     def from_json(cls, json_str):
         data = json.loads(json_str)
@@ -128,15 +131,18 @@
         Args:
             data (Dict): Dictionary with keys as member variable names.
 
         Returns:
             CrossSiloMessageConfig: An instance of CrossSiloMessageConfig.
         """
         # Get the attributes of the class
-        attrs = {attr for attr, _ in cls.__annotations__.items()}
+
+        data = data or {}
+        all_annotations = {**cls.__annotations__, **cls.__base__.__annotations__}
+        attrs = {attr for attr, _ in all_annotations.items()}
         # Filter the dictionary to only include keys that are attributes of the class
         filtered_data = {key: value for key, value in data.items() if key in attrs}
         return cls(**filtered_data)
 
 
 @dataclass
 class GrpcCrossSiloMessageConfig(CrossSiloMessageConfig):
```

## fed/utils.py

```diff
@@ -205,13 +205,13 @@
                 "- `local` for starting a new cluster, or `localhost` for connecting a local cluster.\n" # noqa
                 "- 'ip:port' format, where the IP needs to follow the IP address specifications and the port is a number.\n" # noqa
                 "- 'hostname:port' format, where the hostname is a string and the port is a number.\n" # noqa
                 "- An HTTPS or HTTP link starting with 'https://' or 'http://'.") # noqa
     raise ValueError(error_msg)
 
 
-def validate_cluster_info(cluster: dict):
+def validate_addresses(addresses: dict):
     """
-    Validate whether the cluster information is in correct forms.
+    Validate whether the addresses is in correct forms.
     """
-    for _, info in cluster.items():
-        validate_address(info['address'])
+    for _, address in addresses.items():
+        validate_address(address)
```

## fed/_private/fed_actor.py

```diff
@@ -21,36 +21,36 @@
 logger = logging.getLogger(__name__)
 
 
 class FedActorHandle:
     def __init__(
         self,
         fed_class_task_id,
-        cluster,
+        addresses,
         cls,
         party,
         node_party,
         options,
     ) -> None:
         self._fed_class_task_id = fed_class_task_id
-        self._cluster = cluster
+        self._addresses = addresses
         self._body = cls
         self._party = party
         self._node_party = node_party
         self._options = options
         self._actor_handle = None
 
     def __getattr__(self, method_name: str):
         # User trying to call .bind() without a bind class method
         if method_name == "remote" and "remote" not in dir(self._body):
             raise AttributeError(f".remote() cannot be used again on {type(self)} ")
         # Raise an error if the method is invalid.
         getattr(self._body, method_name)
         call_node = FedActorMethod(
-            self._cluster,
+            self._addresses,
             self._party,
             self._node_party,
             self,
             method_name,
         ).options(**self._options)
         return call_node
 
@@ -86,21 +86,21 @@
         )
         return ray_object_ref
 
 
 class FedActorMethod:
     def __init__(
         self,
-        cluster,
+        addresses,
         party,
         node_party,
         fed_actor_handle,
         method_name,
     ) -> None:
-        self._cluster = cluster
+        self._addresses = addresses
         self._party = party  # Current party
         self._node_party = node_party
         self._fed_actor_handle = fed_actor_handle
         self._method_name = method_name
         self._options = {}
         self._fed_call_holder = FedCallHolder(node_party, self._execute_impl)
```

## fed/proxy/barriers.py

```diff
@@ -54,51 +54,51 @@
     return the_dict[key_a].pop(key_b)
 
 
 @ray.remote
 class SenderProxyActor:
     def __init__(
         self,
-        cluster: Dict,
+        addresses: Dict,
         party: str,
         tls_config: Dict = None,
         logging_level: str = None,
         proxy_cls=None
     ):
         setup_logger(
             logging_level=logging_level,
             logging_format=constants.RAYFED_LOG_FMT,
             date_format=constants.RAYFED_DATE_FMT,
             party_val=party,
         )
 
         self._stats = {"send_op_count": 0}
-        self._cluster = cluster
+        self._addresses = addresses
         self._party = party
         self._tls_config = tls_config
         job_config = fed_config.get_job_config()
         cross_silo_message_config = job_config.cross_silo_message_config
         self._proxy_instance: SenderProxy = proxy_cls(
-            cluster, party, tls_config, cross_silo_message_config)
+            addresses, party, tls_config, cross_silo_message_config)
 
     async def is_ready(self):
         res = await self._proxy_instance.is_ready()
         return res
 
     async def send(
         self,
         dest_party,
         data,
         upstream_seq_id,
         downstream_seq_id,
     ):
         self._stats["send_op_count"] += 1
         assert (
-            dest_party in self._cluster
-        ), f'Failed to find {dest_party} in cluster {self._cluster}.'
+            dest_party in self._addresses
+        ), f'Failed to find {dest_party} in addresses {self._addresses}.'
         send_log_msg = (
             f'send data to seq_id {downstream_seq_id} of {dest_party} '
             f'from {upstream_seq_id}'
         )
         logger.debug(
             f'Sending {send_log_msg} with{"out" if not self._tls_config else ""}'
             ' credentials.'
@@ -111,45 +111,45 @@
             return False
         logger.debug(f"Succeeded to send {send_log_msg}. Response is {response}")
         return True  # True indicates it's sent successfully.
 
     async def _get_stats(self):
         return self._stats
 
-    async def _get_cluster_info(self):
-        return self._cluster
+    async def _get_addresses_info(self):
+        return self._addresses
 
     async def _get_proxy_config(self, dest_party=None):
         return await self._proxy_instance.get_proxy_config(dest_party)
 
 
 @ray.remote
 class ReceiverProxyActor:
     def __init__(
         self,
-        listen_addr: str,
+        listening_address: str,
         party: str,
         logging_level: str,
         tls_config=None,
         proxy_cls=None,
     ):
         setup_logger(
             logging_level=logging_level,
             logging_format=constants.RAYFED_LOG_FMT,
             date_format=constants.RAYFED_DATE_FMT,
             party_val=party,
         )
         self._stats = {"receive_op_count": 0}
-        self._listen_addr = listen_addr
+        self._listening_address = listening_address
         self._party = party
         self._tls_config = tls_config
         job_config = fed_config.get_job_config()
         cross_silo_message_config = job_config.cross_silo_message_config
         self._proxy_instance: ReceiverProxy = proxy_cls(
-            listen_addr, party, tls_config, cross_silo_message_config)
+            listening_address, party, tls_config, cross_silo_message_config)
 
     async def start(self):
         await self._proxy_instance.start()
 
     async def is_ready(self):
         res = await self._proxy_instance.is_ready()
         return res
@@ -169,40 +169,40 @@
 
 _DEFAULT_RECEIVER_PROXY_OPTIONS = {
     "max_concurrency": 1000,
 }
 
 
 def _start_receiver_proxy(
-    cluster: str,
+    addresses: str,
     party: str,
     logging_level: str,
     tls_config=None,
     proxy_cls=None,
     proxy_config: Optional[fed_config.CrossSiloMessageConfig] = None
 ):
 
     # Create RecevrProxyActor
     # Not that this is now a threaded actor.
     # NOTE(NKcqx): This is not just addr, but a party dict containing 'address'
-    party_addr = cluster[party]
-    listen_addr = party_addr.get('listen_addr', None)
-    if not listen_addr:
-        listen_addr = party_addr['address']
+    party_addr = addresses[party]
+    listening_address = proxy_config.listening_address
+    if not listening_address:
+        listening_address = party_addr
 
     actor_options = copy.deepcopy(_DEFAULT_RECEIVER_PROXY_OPTIONS)
     if proxy_config is not None and proxy_config.recv_resource_label is not None:
         actor_options.update({"resources": proxy_config.recv_resource_label})
 
     logger.debug(f"Starting ReceiverProxyActor with options: {actor_options}")
 
     receiver_proxy_actor = ReceiverProxyActor.options(
         name=f"ReceiverProxyActor-{party}", **actor_options
     ).remote(
-        listen_addr=listen_addr,
+        listening_address=listening_address,
         party=party,
         tls_config=tls_config,
         logging_level=logging_level,
         proxy_cls=proxy_cls
     )
     receiver_proxy_actor.start.remote()
     timeout = proxy_config.timeout_in_ms / 1000 if proxy_config is not None else 60
@@ -214,15 +214,15 @@
 _SENDER_PROXY_ACTOR = None
 _DEFAULT_SENDER_PROXY_OPTIONS = {
     "max_concurrency": 1000,
 }
 
 
 def _start_sender_proxy(
-    cluster: Dict,
+    addresses: Dict,
     party: str,
     logging_level: str,
     tls_config: Dict = None,
     proxy_cls=None,
     proxy_config: Optional[fed_config.CrossSiloMessageConfig] = None
 ):
     # Create SenderProxyActor
@@ -238,15 +238,15 @@
         actor_options.update({"resources": proxy_config.send_resource_label})
 
     logger.debug(f"Starting SenderProxyActor with options: {actor_options}")
     _SENDER_PROXY_ACTOR = SenderProxyActor.options(
         name="SenderProxyActor", **actor_options)
 
     _SENDER_PROXY_ACTOR = _SENDER_PROXY_ACTOR.remote(
-        cluster=cluster,
+        addresses=addresses,
         party=party,
         tls_config=tls_config,
         logging_level=logging_level,
         proxy_cls=proxy_cls
     )
     timeout = get_job_config().cross_silo_message_config.timeout_in_ms / 1000
     assert ray.get(_SENDER_PROXY_ACTOR.is_ready.remote(), timeout=timeout)
@@ -272,17 +272,17 @@
 
 def recv(party: str, src_party: str, upstream_seq_id, curr_seq_id):
     assert party, 'Party can not be None.'
     receiver_proxy = ray.get_actor(f"ReceiverProxyActor-{party}")
     return receiver_proxy.get_data.remote(src_party, upstream_seq_id, curr_seq_id)
 
 
-def ping_others(cluster: Dict[str, Dict], self_party: str, max_retries=3600):
+def ping_others(addresses: Dict[str, Dict], self_party: str, max_retries=3600):
     """Ping other parties until all are ready or timeout."""
-    others = [party for party in cluster if not party == self_party]
+    others = [party for party in addresses if not party == self_party]
     tried = 0
 
     while tried < max_retries and others:
         logger.info(
             f'Try ping {others} at {tried} attemp, up to {max_retries} attemps.'
         )
         tried += 1
```

## fed/proxy/base_proxy.py

```diff
@@ -17,20 +17,20 @@
 
 from fed.config import CrossSiloMessageConfig
 
 
 class SenderProxy(abc.ABC):
     def __init__(
         self,
-        cluster: Dict,
+        addresses: Dict,
         party: str,
         tls_config: Dict,
         proxy_config: CrossSiloMessageConfig = None
     ) -> None:
-        self._cluster = cluster
+        self._addresses = addresses
         self._party = party
         self._tls_config = tls_config
         self._proxy_config = proxy_config
 
     @abc.abstractmethod
     async def send(
         self,
```

## Comparing `rayfed_nightly-0.1.0b20230720.dev0.dist-info/LICENSE` & `rayfed_nightly-0.1.0b20230722.dev0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `rayfed_nightly-0.1.0b20230720.dev0.dist-info/METADATA` & `rayfed_nightly-0.1.0b20230722.dev0.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: rayfed-nightly
-Version: 0.1.0b20230720.dev0
+Version: 0.1.0b20230722.dev0
 Summary: A multiple parties joint, distributed execution engine based on Ray,to help build your own federated learning frameworks in minutes.
 Home-page: https://github.com/ray-project/rayfed
 Author: RayFed Team
 Author-email: rayfed-dev@googlegroups.com
 License: Apache 2.0
 Platform: UNKNOWN
 Description-Content-Type: text/markdown
@@ -121,19 +121,19 @@
 3. Execute the aggregation function in party 'bob'.
 
 ### Step 4: Declare Cross-party Cluster & Init 
 ```python
 def main(party):
     ray.init(address='local')
 
-    cluster = {
-        'alice': {'address': '127.0.0.1:11012'},
-        'bob': {'address': '127.0.0.1:11011'},
+    addresses = {
+        'alice': '127.0.0.1:11012',
+        'bob': '127.0.0.1:11011',
     }
-    fed.init(cluster=cluster, party=party)
+    fed.init(addresses=addresses, party=party)
 ```
 This first declares a two-party cluster, whose addresses corresponding to '127.0.0.1:11012' in 'alice' and '127.0.0.1:11011' in 'bob'.
 And then, the `fed.init` create a cluster in the specified party.
 Note that `fed.init` should be called twice, passing in the different party each time.
 
 When executing codes in step 1~3, the 'alice' cluster will only execute functions whose "party" are also declared as 'alice'.
 
@@ -159,19 +159,19 @@
 def aggregate(val1, val2):
     return val1 + val2
 
 
 def main(party):
     ray.init(address='local')
 
-    cluster = {
-        'alice': {'address': '127.0.0.1:11012'},
-        'bob': {'address': '127.0.0.1:11011'},
+    addresses = {
+        'alice': '127.0.0.1:11012',
+        'bob': '127.0.0.1:11011',
     }
-    fed.init(cluster=cluster, party=party)
+    fed.init(addresses=addresses, party=party)
 
     actor_alice = MyActor.party("alice").remote(1)
     actor_bob = MyActor.party("bob").remote(1)
 
     val_alice = actor_alice.inc.remote(1)
     val_bob = actor_bob.inc.remote(2)
```

## Comparing `rayfed_nightly-0.1.0b20230720.dev0.dist-info/RECORD` & `rayfed_nightly-0.1.0b20230722.dev0.dist-info/RECORD`

 * *Files 12% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 fed/__init__.py,sha256=WN5lu4fAPUVxzlL4T6Z_ygmP3d9-DAVLWFRkd92SVmc,859
-fed/api.py,sha256=jQLVb2iI22BZeGpCwYTALNO-kLXz1KcHSNuDWNoi-J0,14394
+fed/api.py,sha256=2jwG6egBJVRFiWr4iq-IZ9Qk-DJttz2Aj9amtrbqV3E,13013
 fed/cleanup.py,sha256=LeADQUgJ8n94PJdBqkbM9LbMnA-aZfMPe7bk0MMWZIU,3676
-fed/config.py,sha256=L4F_Rtd2FUfeORgb1VldPgb2o-eyVz3NJplNpzDIfqw,6115
+fed/config.py,sha256=HUaU_qmToYRLLSVXfba0nnSCMb55bL9wKiSL7YBa84k,6368
 fed/fed_object.py,sha256=l2BRa9WZ3jqXSDjwFPURcAIK8XkH8A5UYA_OcY4TOD0,2877
 fed/tree_util.py,sha256=25LiGASBcreE34OsGsoeRWH4t6BuBk3QVcKjCe38jTI,7908
-fed/utils.py,sha256=mT0yG7aeAEPCTe_ZuGyabIV_tz9-nrjX-d3VDuKlJNQ,7519
+fed/utils.py,sha256=tEzcc6LmH0gpg1aZD6zJZVSBeVYQ1rVxmG4h4niTxgA,7505
 fed/_private/__init__.py,sha256=MDXwlZ-y7_o-tfqh8DVkjlO-6MlWqwLdbSIZUJfXtF0,581
 fed/_private/api.py,sha256=MDXwlZ-y7_o-tfqh8DVkjlO-6MlWqwLdbSIZUJfXtF0,581
 fed/_private/compatible_utils.py,sha256=4JdcL1qGlLwQx6DMBAs5lphPxOIJyz1YqYbS1Hq8Ruk,5269
 fed/_private/constants.py,sha256=91H8u6UL_qvvUII-UlKbipuapOH_xVAGVcRv8qBWMnw,1074
-fed/_private/fed_actor.py,sha256=8nqXO_l9yOno5duMiEhWagp9q9-w696erKos-RgcnoU,3837
+fed/_private/fed_actor.py,sha256=juzgqrBsycl1kKaND-HwBeG0YOBcvk5rGcOQutA8RJ0,3851
 fed/_private/fed_call_holder.py,sha256=RDD3fet8CD2clUNfSX6ByXViaYlkcLQNDxaAADU-Ld4,3947
 fed/_private/global_context.py,sha256=JtRCuBHju_8OcIbtfNvhzPR9bDxeD_X8bRe-8SogNtY,1262
 fed/_private/serialization_utils.py,sha256=TbvlXDj8_r_uzkUkESs4Z8qOqKzUQ-Li7h0Xile-WkM,2419
 fed/grpc/__init__.py,sha256=MDXwlZ-y7_o-tfqh8DVkjlO-6MlWqwLdbSIZUJfXtF0,581
 fed/grpc/fed_pb2_grpc_in_protobuf3.py,sha256=Do9HCVH4CdclNRsX8LASBCrDUtcji8QP8voHl485Qw8,2968
 fed/grpc/fed_pb2_grpc_in_protobuf4.py,sha256=MyuFC-u-QMNNAyHsXRc3TvEq9U4DQ9EjBIGdcPzSQvk,2989
 fed/grpc/fed_pb2_in_protobuf3.py,sha256=wJRyg1d7dK6SHfw7lzQPlEHWkINq8JqiK0qbqXWhRro,2095
 fed/grpc/fed_pb2_in_protobuf4.py,sha256=0JbbKEqCKx31MiIMVU3UOJ93ZgTbAr6g51z1EgIRNG8,2113
 fed/proxy/__init__.py,sha256=zjmMrqPxcVeXa7sMvRccSdnmV8_A73tETlvUJtAd0lA,613
-fed/proxy/barriers.py,sha256=iwUgyqgHPs1IKPM3g7AJKC8kdlaBTjPMuG7KTjBx_dE,9726
-fed/proxy/base_proxy.py,sha256=2j2D5Bx8-AAcIU9n8W8ntdVwGgpAyRp5OqBMYI4rwBU,2019
-rayfed_nightly-0.1.0b20230720.dev0.dist-info/LICENSE,sha256=QwcOLU5TJoTeUhuIXzhdCEEDDvorGiC6-3YTOl4TecE,11356
-rayfed_nightly-0.1.0b20230720.dev0.dist-info/METADATA,sha256=dE-_m3mXBnfqVODRGarAkQNjgsCjoYaybiInl_t38w8,7367
-rayfed_nightly-0.1.0b20230720.dev0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-rayfed_nightly-0.1.0b20230720.dev0.dist-info/top_level.txt,sha256=5gd1qhbpzLAi36ONV8p_s65_-iAiOSwFljYh-ONEwts,4
-rayfed_nightly-0.1.0b20230720.dev0.dist-info/RECORD,,
+fed/proxy/barriers.py,sha256=mt-XVee-ezoxbTBbnkZPYp4s4w0Y13yg342s8tTb-gQ,9796
+fed/proxy/base_proxy.py,sha256=hCNmp66-gTvE-Xsfy1TThZfEiuPhSRFM5NMYLQNh1uc,2025
+rayfed_nightly-0.1.0b20230722.dev0.dist-info/LICENSE,sha256=QwcOLU5TJoTeUhuIXzhdCEEDDvorGiC6-3YTOl4TecE,11356
+rayfed_nightly-0.1.0b20230722.dev0.dist-info/METADATA,sha256=c1wvMgCNiqNI2GBXXRVxpnnTF73FgGpMpgd8Wy71WGk,7327
+rayfed_nightly-0.1.0b20230722.dev0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+rayfed_nightly-0.1.0b20230722.dev0.dist-info/top_level.txt,sha256=5gd1qhbpzLAi36ONV8p_s65_-iAiOSwFljYh-ONEwts,4
+rayfed_nightly-0.1.0b20230722.dev0.dist-info/RECORD,,
```

