# Comparing `tmp/kyupy-0.0.3-py3-none-any.whl.zip` & `tmp/kyupy-0.0.4-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,17 +1,19 @@
-Zip file size: 36390 bytes, number of entries: 15
--rw-r--r--  2.0 unx     6525 b- defN 21-Jan-16 05:40 kyupy/__init__.py
--rw-r--r--  2.0 unx     2193 b- defN 21-Jan-16 05:40 kyupy/bench.py
--rw-r--r--  2.0 unx    13807 b- defN 21-Jan-16 05:40 kyupy/circuit.py
--rw-r--r--  2.0 unx    18716 b- defN 21-Jan-16 05:40 kyupy/logic.py
--rw-r--r--  2.0 unx     7978 b- defN 21-Jan-16 05:40 kyupy/logic_sim.py
--rw-r--r--  2.0 unx     9636 b- defN 21-Jan-16 05:40 kyupy/sdf.py
--rw-r--r--  2.0 unx    10357 b- defN 21-Jan-16 05:40 kyupy/stil.py
--rw-r--r--  2.0 unx    16958 b- defN 21-Jan-16 05:40 kyupy/techlib.py
--rw-r--r--  2.0 unx     6934 b- defN 21-Jan-16 05:40 kyupy/verilog.py
--rw-r--r--  2.0 unx    37626 b- defN 21-Jan-16 05:40 kyupy/wave_sim.py
--rw-r--r--  2.0 unx     1074 b- defN 21-Jan-16 05:45 kyupy-0.0.3.dist-info/LICENSE.txt
--rw-r--r--  2.0 unx     2780 b- defN 21-Jan-16 05:45 kyupy-0.0.3.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 21-Jan-16 05:45 kyupy-0.0.3.dist-info/WHEEL
--rw-r--r--  2.0 unx        6 b- defN 21-Jan-16 05:45 kyupy-0.0.3.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     1107 b- defN 21-Jan-16 05:45 kyupy-0.0.3.dist-info/RECORD
-15 files, 135789 bytes uncompressed, 34616 bytes compressed:  74.5%
+Zip file size: 49240 bytes, number of entries: 17
+-rw-rw-r--  2.0 unx     9406 b- defN 23-Jul-22 07:04 kyupy/__init__.py
+-rw-rw-r--  2.0 unx     2244 b- defN 23-Jul-22 07:04 kyupy/bench.py
+-rw-rw-r--  2.0 unx    27685 b- defN 23-Jul-22 07:04 kyupy/circuit.py
+-rw-rw-r--  2.0 unx    10262 b- defN 23-Jul-22 07:04 kyupy/def_file.py
+-rw-rw-r--  2.0 unx    16828 b- defN 23-Jul-22 07:04 kyupy/logic.py
+-rw-rw-r--  2.0 unx    22213 b- defN 23-Jul-22 07:04 kyupy/logic_sim.py
+-rw-rw-r--  2.0 unx     8637 b- defN 23-Jul-22 07:04 kyupy/sdf.py
+-rw-rw-r--  2.0 unx    14994 b- defN 23-Jul-22 07:04 kyupy/sim.py
+-rw-rw-r--  2.0 unx    12625 b- defN 23-Jul-22 07:04 kyupy/stil.py
+-rw-rw-r--  2.0 unx    21997 b- defN 23-Jul-22 07:04 kyupy/techlib.py
+-rw-rw-r--  2.0 unx    10513 b- defN 23-Jul-22 07:04 kyupy/verilog.py
+-rw-rw-r--  2.0 unx    21260 b- defN 23-Jul-22 07:04 kyupy/wave_sim.py
+-rw-rw-r--  2.0 unx     1074 b- defN 23-Jul-22 07:06 kyupy-0.0.4.dist-info/LICENSE.txt
+-rw-rw-r--  2.0 unx     2790 b- defN 23-Jul-22 07:06 kyupy-0.0.4.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 23-Jul-22 07:06 kyupy-0.0.4.dist-info/WHEEL
+-rw-rw-r--  2.0 unx        6 b- defN 23-Jul-22 07:06 kyupy-0.0.4.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1254 b- defN 23-Jul-22 07:06 kyupy-0.0.4.dist-info/RECORD
+17 files, 183880 bytes uncompressed, 47256 bytes compressed:  74.3%
```

## zipnote {}

```diff
@@ -3,44 +3,50 @@
 
 Filename: kyupy/bench.py
 Comment: 
 
 Filename: kyupy/circuit.py
 Comment: 
 
+Filename: kyupy/def_file.py
+Comment: 
+
 Filename: kyupy/logic.py
 Comment: 
 
 Filename: kyupy/logic_sim.py
 Comment: 
 
 Filename: kyupy/sdf.py
 Comment: 
 
+Filename: kyupy/sim.py
+Comment: 
+
 Filename: kyupy/stil.py
 Comment: 
 
 Filename: kyupy/techlib.py
 Comment: 
 
 Filename: kyupy/verilog.py
 Comment: 
 
 Filename: kyupy/wave_sim.py
 Comment: 
 
-Filename: kyupy-0.0.3.dist-info/LICENSE.txt
+Filename: kyupy-0.0.4.dist-info/LICENSE.txt
 Comment: 
 
-Filename: kyupy-0.0.3.dist-info/METADATA
+Filename: kyupy-0.0.4.dist-info/METADATA
 Comment: 
 
-Filename: kyupy-0.0.3.dist-info/WHEEL
+Filename: kyupy-0.0.4.dist-info/WHEEL
 Comment: 
 
-Filename: kyupy-0.0.3.dist-info/top_level.txt
+Filename: kyupy-0.0.4.dist-info/top_level.txt
 Comment: 
 
-Filename: kyupy-0.0.3.dist-info/RECORD
+Filename: kyupy-0.0.4.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## kyupy/__init__.py

```diff
@@ -1,33 +1,38 @@
-"""A package for processing and analysis of non-hierarchical gate-level VLSI designs.
+"""The kyupy package itself contains a miscellaneous utility functions.
 
-The kyupy package itself contains a logger and other simple utility functions.
 In addition, it defines a ``numba`` and a ``cuda`` objects that point to the actual packages
 if they are available and otherwise point to mocks.
 """
 
 import time
+import sys
+from collections import defaultdict
 import importlib.util
 import gzip
 
 import numpy as np
 
 
 _pop_count_lut = np.asarray([bin(x).count('1') for x in range(256)])
 
 
+def cdiv(x, y):
+    return -(x // -y)
+
+
 def popcount(a):
-    """Returns the number of 1-bits in a given packed numpy array."""
+    """Returns the number of 1-bits in a given packed numpy array of type ``uint8``."""
     return np.sum(_pop_count_lut[a])
 
 
 def readtext(file):
     """Reads and returns the text in a given file. Transparently decompresses \\*.gz files."""
     if hasattr(file, 'read'):
-        return file.read()
+        return file.read().decode()
     if str(file).endswith('.gz'):
         with gzip.open(file, 'rt') as f:
             return f.read()
     else:
         with open(file, 'rt') as f:
             return f.read()
 
@@ -70,32 +75,106 @@
         if 'd' not in s:
             s += f'{int(m)}m'
     if 'h' not in s and 'd' not in s:
         s += f'{int(seconds)}s'
     return s
 
 
+def batchrange(nitems, maxsize):
+    """A simple generator that produces offsets and sizes for batch-loops."""
+    for offset in range(0, nitems, maxsize):
+        yield offset, min(nitems-offset, maxsize)
+
+
+class Timer:
+    def __init__(self, s=0): self.s = s
+    def __enter__(self): self.start_time = time.perf_counter(); return self
+    def __exit__(self, *args): self.s += time.perf_counter() - self.start_time
+    @property
+    def ms(self): return self.s*1e3
+    @property
+    def us(self): return self.s*1e6
+    def __repr__(self): return f'{self.s:.3f}'
+    def __add__(self, t):
+        return Timer(self.s + t.s)
+
+
+class Timers:
+    def __init__(self, t={}): self.timers = defaultdict(Timer) | t
+    def __getitem__(self, name): return self.timers[name]
+    def __repr__(self): return '{' + ', '.join([f'{k}: {v}' for k, v in self.timers.items()]) + '}'
+    def __add__(self, t):
+        tmr = Timers(self.timers)
+        for k, v in t.timers.items(): tmr.timers[k] += v
+        return tmr
+    def sum(self):
+        return sum([v.s for v in self.timers.values()])
+    def dict(self):
+        return dict([(k, v.s) for k, v in self.timers.items()])
+
+
 class Log:
     """A very simple logger that formats the messages with the number of seconds since
     program start.
     """
+
     def __init__(self):
         self.start = time.perf_counter()
-        self.logfile = None
+        self.logfile = sys.stdout
         """When set to a file handle, log messages are written to it instead to standard output.
-        After each write, ``flush()`` is called as well.
         """
+        self.indent = 0
+        self._limit = -1
+        self.filtered = 0
+
+    def limit(self, log_limit):
+        class Limiter:
+            def __init__(self, l): self.l = l
+            def __enter__(self): self.l.start_limit(log_limit); return self
+            def __exit__(self, *args): self.l.stop_limit()
+        return Limiter(self)
+
+    def start_limit(self, limit):
+        self.filtered = 0
+        self._limit = limit
+
+    def stop_limit(self):
+        if self.filtered > 0:
+            log.info(f'{self.filtered} more messages (filtered).')
+            self.filtered = 0
+        self._limit = -1
+
+    def __getstate__(self):
+        return {'elapsed': time.perf_counter() - self.start}
+
+    def __setstate__(self, state):
+        self.logfile = sys.stdout
+        self.indent = 0
+        self.start = time.perf_counter() - state['elapsed']
+
+    def write(self, s, indent=0):
+        self.logfile.write(' '*indent + s + '\n')
+        self.logfile.flush()
+
+    def li(self, item): self.write('- ' + str(item).replace('\n', '\n'+' '*(self.indent+1)), self.indent)
+    def lib(self): self.write('-', self.indent); self.indent += 1
+    def lin(self): self.write('-', self.indent-1)
+    def di(self, key, value): self.write(str(key) + ': ' + str(value).replace('\n', '\n'+' '*(self.indent+1)), self.indent)
+    def dib(self, key): self.write(str(key) + ':', self.indent); self.indent += 1
+    def din(self, key): self.write(str(key) + ':', self.indent-1)
+    def ie(self, n=1): self.indent -= n
 
     def log(self, level, message):
+        if self._limit == 0:
+            self.filtered += 1
+            return
         t = time.perf_counter() - self.start
-        if self.logfile is None:
-            print(f'{t:011.3f} {level} {message}')
-        else:
-            self.logfile.write(f'{t:011.3f} {level} {message}\n')
-            self.logfile.flush()
+        self.logfile.write(f'# {t:011.3f} {level} {message}\n')
+        self.logfile.flush()
+        self._limit -= 1
 
     def info(self, message):
         """Log an informational message."""
         self.log('-', message)
 
     def warn(self, message):
         """Log a warning message."""
@@ -116,15 +195,16 @@
             yield i
             current_time = time.perf_counter()
             if current_time > lastlog_time + log_interval:
                 done = (elem + 1) / elems
                 elapsed_time = current_time - start_time
                 total_time = elapsed_time / done
                 rem_time = total_time - elapsed_time
-                self.log(':', f'{done*100:.0f}% done {hr_time(elapsed_time)} elapsed {hr_time(rem_time)} remaining')
+                self.log(
+                    ':', f'{done*100:.0f}% done {hr_time(elapsed_time)} elapsed {hr_time(rem_time)} remaining')
                 log_interval = min(600, int(log_interval*1.5))
                 lastlog_time = current_time
 
 
 log = Log()
 """The standard logger instance."""
 
@@ -143,15 +223,15 @@
 
 class MockCuda:
 
     def __init__(self):
         self.x = 0
         self.y = 0
 
-    def jit(self, device=False):
+    def jit(self, func=None, device=False):
         _ = device  # silence "not used" warning
         outer = self
 
         def make_launcher(func):
             class Launcher:
                 def __init__(self, funcc):
                     self.func = funcc
@@ -163,21 +243,23 @@
                     grid_dim, block_dim = item
 
                     def inner(*args, **kwargs):
                         for grid_x in range(grid_dim[0]):
                             for grid_y in range(grid_dim[1]):
                                 for block_x in range(block_dim[0]):
                                     for block_y in range(block_dim[1]):
-                                        outer.x = grid_x * block_dim[0] + block_x
-                                        outer.y = grid_y * block_dim[1] + block_y
+                                        outer.x = grid_x * \
+                                            block_dim[0] + block_x
+                                        outer.y = grid_y * \
+                                            block_dim[1] + block_y
                                         self.func(*args, **kwargs)
                     return inner
             return Launcher(func)
 
-        return make_launcher
+        return make_launcher(func) if func else make_launcher
 
     @staticmethod
     def to_device(array, to=None):
         if to is not None:
             to[...] = array
             return to
         return array.copy()
@@ -193,14 +275,16 @@
 if importlib.util.find_spec('numba') is not None:
     import numba
     import numba.cuda
     from numba.cuda.cudadrv.error import CudaSupportError
     try:
         list(numba.cuda.gpus)
         from numba import cuda
+        from numba.core import config
+        config.CUDA_LOW_OCCUPANCY_WARNINGS = False
     except CudaSupportError:
         log.warn('Cuda unavailable. Falling back to pure Python.')
         cuda = MockCuda()
 else:
     numba = MockNumba()
     """If Numba is available on the system, it is the actual ``numba`` package.
     Otherwise, it simply defines an ``njit`` decorator that does nothing.
```

## kyupy/bench.py

```diff
@@ -17,17 +17,17 @@
 
     def __init__(self, name):
         super().__init__()
         self.c = Circuit(name)
 
     def start(self, _): return self.c
 
-    def parameters(self, args): return [self.c.get_or_add_fork(name) for name in args]
+    def parameters(self, args): return [self.c.get_or_add_fork(str(name)) for name in args]
 
-    def interface(self, args): self.c.interface.extend(args[0])
+    def interface(self, args): self.c.io_nodes.extend(args[0])
 
     def assignment(self, args):
         name, cell_type, drivers = args
         cell = Node(self.c, str(name), str(cell_type))
         Line(self.c, cell, self.c.get_or_add_fork(str(name)))
         for d in drivers: Line(self.c, d, cell)
 
@@ -53,12 +53,12 @@
     """
     return Lark(GRAMMAR, parser="lalr", transformer=BenchTransformer(name)).parse(text)
 
 
 def load(file, name=None):
     """Parses the contents of ``file`` as ISCAS89 bench code.
 
-    :param file: The file to be loaded.
-    :param name: The name of the circuit. If none given, the file name is used as circuit name.
+    :param file: The file to be loaded. Files with `.gz`-suffix are decompressed on-the-fly.
+    :param name: The name of the circuit. If None, the file name is used as circuit name.
     :return: A :class:`Circuit` object.
     """
     return parse(readtext(file), name=name or str(file))
```

## kyupy/circuit.py

```diff
@@ -1,15 +1,23 @@
-"""Data structures for representing non-hierarchical gate-level circuits.
+"""Core module for handling non-hierarchical gate-level circuits.
 
 The class :class:`Circuit` is a container of nodes connected by lines.
 A node is an instance of class :class:`Node`,
 and a line is an instance of class :class:`Line`.
+
+The data structures are designed to work together nicely with numpy arrays.
+For example, all the nodes and connections in the circuit graph have consecutive integer indices that can be used to access ndarrays with associated data.
+Circuit graphs also define an ordering of inputs, outputs and other nodes to easily process test vector data and alike.
+
 """
 
-from collections import deque
+from collections import deque, defaultdict
+import re
+
+import numpy as np
 
 
 class GrowingList(list):
     def __setitem__(self, index, value):
         if index >= len(self):
             self.extend([None] * (index + 1 - len(self)))
         super().__setitem__(index, value)
@@ -60,32 +68,34 @@
         In the circuit, the namespaces of forks and cells are kept separate.
         While :py:attr:`name` must be unique among all forks and all cells, a fork can have the same name as a cell.
         The :py:attr:`index`, however, is unique among all nodes; a fork cannot have the same index as a cell.
         """
         self.index = len(circuit.nodes) - 1
         """A unique and consecutive integer index of the node within the circuit.
 
-        It can be used to store additional data about the node :code:`n`
+        It can be used to associate additional data to a node :code:`n`
         by allocating an array or list :code:`my_data` of length :code:`len(n.circuit.nodes)` and
-        accessing it by :code:`my_data[n.index]`.
+        accessing it by :code:`my_data[n.index]` or simply by :code:`my_data[n]`.
         """
         self.ins = GrowingList()
         """A list of input connections (:class:`Line` objects).
         """
         self.outs = GrowingList()
         """A list of output connections (:class:`Line` objects).
         """
 
     def __index__(self):
         return self.index
 
     def __repr__(self):
         ins = ' '.join([f'<{line.index}' if line is not None else '<None' for line in self.ins])
         outs = ' '.join([f'>{line.index}' if line is not None else '>None' for line in self.outs])
-        return f'{self.index}:{self.kind}"{self.name}" {ins} {outs}'
+        ins = ' ' + ins if len(ins) else ''
+        outs = ' ' + outs if len(outs) else ''
+        return f'{self.index}:{self.kind}"{self.name}"{ins}{outs}'
 
     def remove(self):
         """Removes the node from its circuit.
 
         Lines may still reference the removed node.
         The user must connect such lines to other nodes or remove the lines from the circuit.
         To keep the indices consecutive, the node with the highest index within the circuit
@@ -95,14 +105,24 @@
             del self.circuit.nodes[self.index]
             if self.kind == '__fork__':
                 del self.circuit.forks[self.name]
             else:
                 del self.circuit.cells[self.name]
             self.circuit = None
 
+    def __eq__(self, other):
+        """Checks equality of node name and kind. Does not check pin connections.
+
+        This is ok, because (name, kind) is unique within a circuit.
+        """
+        return self.name == other.name and self.kind == other.kind
+
+    def __hash__(self):
+        return hash((self.name, self.kind))
+
 
 class Line:
     """A line is a directional 1:1 connection between two nodes.
 
     It always connects an output of one `driver` node to an input of one `reader` node.
     If a signal fans out to multiple readers, a '__fork__' node needs to be added.
 
@@ -121,46 +141,50 @@
         """
         self.circuit.lines.append(self)
         self.index = len(self.circuit.lines) - 1
         """A unique and consecutive integer index of the line within the circuit.
 
         It can be used to store additional data about the line :code:`l`
         by allocating an array or list :code:`my_data` of length :code:`len(l.circuit.lines)` and
-        accessing it by :code:`my_data[l.index]`.
+        accessing it by :code:`my_data[l.index]` or simply by :code:`my_data[l]`.
         """
         if not isinstance(driver, tuple): driver = (driver, driver.outs.free_index())
         self.driver = driver[0]
         """The :class:`Node` object that drives this line.
         """
         self.driver_pin = driver[1]
         """The output pin position of the driver node this line is connected to.
 
-        This is the position in the outs-list of the driving node this line referenced from:
+        This is the position in the list :py:attr:`Node.outs` of the driving node this line referenced from:
         :code:`self.driver.outs[self.driver_pin] == self`.
         """
         if not isinstance(reader, tuple): reader = (reader, reader.ins.free_index())
         self.reader = reader[0]
         """The :class:`Node` object that reads this line.
         """
         self.reader_pin = reader[1]
         """The input pin position of the reader node this line is connected to.
 
-        This is the position in the ins-list of the reader node this line referenced from:
+        This is the position in the list :py:attr:`Node.ins` of the reader node this line referenced from:
         :code:`self.reader.ins[self.reader_pin] == self`.
         """
         self.driver.outs[self.driver_pin] = self
         self.reader.ins[self.reader_pin] = self
 
     def remove(self):
         """Removes the line from its circuit and its referencing nodes.
 
         To keep the indices consecutive, the line with the highest index within the circuit
         will be assigned the index of the removed line.
         """
-        if self.driver is not None: self.driver.outs[self.driver_pin] = None
+        if self.driver is not None:
+            self.driver.outs[self.driver_pin] = None
+            if self.driver.kind == '__fork__':  # squeeze outputs
+                del self.driver.outs[self.driver_pin]
+                for i, l in enumerate(self.driver.outs): l.driver_pin = i
         if self.reader is not None: self.reader.ins[self.reader_pin] = None
         if self.circuit is not None: del self.circuit.lines[self.index]
         self.driver = None
         self.reader = None
         self.circuit = None
 
     def __index__(self):
@@ -168,131 +192,362 @@
 
     def __repr__(self):
         return f'{self.index}'
 
     def __lt__(self, other):
         return self.index < other.index
 
+    def __eq__(self, other):
+        return self.driver == other.driver and self.driver_pin == other.driver_pin and \
+               self.reader == other.reader and self.reader_pin == other.reader_pin
+
+    def __hash__(self):
+        return hash((self.driver, self.driver_pin, self.reader, self.reader_pin))
+
 
 class Circuit:
     """A Circuit is a container for interconnected nodes and lines.
 
     It provides access to lines by index and to nodes by index and by name.
     Nodes come in two flavors: `cells` and `forks` (see :py:attr:`Node.kind`).
     The name spaces of cells and forks are kept separate.
 
     The indices of nodes and lines are kept consecutive and unique.
     Whenever lines or nodes are removed from the circuit, the indices of some other lines or nodes may change
     to enforce consecutiveness.
 
     A subset of nodes can be designated as primary input- or output-ports of the circuit.
-    This is done by adding them to the :py:attr:`interface` list.
+    This is done by adding them to the :py:attr:`io_nodes` list.
     """
     def __init__(self, name=None):
         self.name = name
         """The name of the circuit.
         """
-        self.nodes = IndexList()
+        self.nodes : list[Node] = IndexList()
         """A list of all :class:`Node` objects contained in the circuit.
 
         The position of a node in this list equals its index :code:`self.nodes[42].index == 42`.
+        This list must not be changed directly.
+        Use the :class:`Node` constructor and :py:attr:`Node.remove()` to add and remove nodes.
         """
-        self.lines = IndexList()
+        self.lines : list[Line] = IndexList()
         """A list of all :class:`Line` objects contained in the circuit.
 
         The position of a line in this list equals its index :code:`self.lines[42].index == 42`.
+        This list must not be changed directly.
+        Use the :class:`Line` constructor and :py:attr:`Line.remove()` to add and remove lines.
         """
-        self.interface = GrowingList()
+        self.io_nodes : list[Node] = GrowingList()
         """A list of nodes that are designated as primary input- or output-ports.
 
-        Port-nodes are contained in :py:attr:`nodes` as well as :py:attr:`interface`.
-        The position of a node in the interface list corresponds to positions of logic values in test vectors.
+        Port-nodes are contained in :py:attr:`nodes` as well as :py:attr:`io_nodes`.
+        The position of a node in the io_nodes list corresponds to positions of logic values in test vectors.
         The port direction is not stored explicitly.
-        Usually, nodes in the interface list without any lines in their :py:attr:`Node.ins` list are primary inputs,
-        and nodes without any lines in their :py:attr:`Node.outs` list are regarded as primary outputs.
+        Usually, nodes in the io_nodes list without any lines in their :py:attr:`Node.ins` list are primary inputs,
+        and all other nodes in the io_nodes list are regarded as primary outputs.
         """
-        self.cells = {}
+        self.cells : dict[str, Node] = {}
         """A dictionary to access cells by name.
+
+        This dictionary must not be changed directly.
+        Use the :class:`Node` constructor and :py:attr:`Node.remove()` to add and remove nodes.
         """
-        self.forks = {}
+        self.forks : dict[str, Node] = {}
         """A dictionary to access forks by name.
+
+        This dictionary must not be changed directly.
+        Use the :class:`Node` constructor and :py:attr:`Node.remove()` to add and remove nodes.
         """
 
+    @property
+    def s_nodes(self):
+        """A list of all primary I/Os as well as all flip-flops and latches in the circuit (in that order).
+
+        The s_nodes list defines the order of all ports and all sequential elements in the circuit.
+        This list is constructed on-the-fly. If used in some inner toop, consider caching the list for better performance.
+        """
+        return list(self.io_nodes) + [n for n in self.nodes if 'dff' in n.kind.lower()] + [n for n in self.nodes if 'latch' in n.kind.lower()]
+
+    def io_locs(self, prefix):
+        """Returns the indices of primary I/Os that start with given name prefix.
+
+        The returned values are used to index into the :py:attr:`io_nodes` array.
+        If only one I/O cell matches the given prefix, a single integer is returned.
+        If a bus matches the given prefix, a sorted list of indices is returned.
+        Busses are identified by integers in the cell names following the given prefix.
+        Lists for bus indices are sorted from LSB (e.g. :code:`data[0]`) to MSB (e.g. :code:`data[31]`).
+        If a prefix matches multiple different signals or busses, alphanumerically sorted
+        lists of lists are returned. Therefore, higher-dimensional busses
+        (e.g. :code:`data0[0], data0[1], ...`, :code:`data1[0], data1[1], ...`) are supported as well.
+        """
+        return self._locs(prefix, list(self.io_nodes))
+
+    def s_locs(self, prefix):
+        """Returns the indices of I/Os and sequential elements that start with given name prefix.
+
+        The returned values are used to index into the :py:attr:`s_nodes` list.
+        It works the same as :py:attr:`io_locs`. See there for more details.
+        """
+        return self._locs(prefix, self.s_nodes)
+
+    def _locs(self, prefix, nodes):
+        d_top = dict()
+        for i, n in enumerate(nodes):
+            if m := re.match(fr'({prefix}.*?)((?:[\d_\[\]])*$)', n.name):
+                path = [m[1]] + [int(v) for v in re.split(r'[_\[\]]+', m[2]) if len(v) > 0]
+                d = d_top
+                for j in path[:-1]:
+                    d[j] = d.get(j, dict())
+                    d = d[j]
+                d[path[-1]] = i
+
+        # sort recursively for multi-dimensional lists.
+        def sorted_values(d): return [sorted_values(v) for k, v in sorted(d.items())] if isinstance(d, dict) else d
+        l = sorted_values(d_top)
+        while isinstance(l, list) and len(l) == 1: l = l[0]
+        return None if isinstance(l, list) and len(l) == 0 else l
+
+    @property
+    def stats(self):
+        """A dictionary with the counts of all different elements in the circuit.
+
+        The dictionary contains the number of all different kinds of nodes, the number
+        of lines, as well various sums like number of combinational gates, number of
+        primary I/Os, number of sequential elements, and so on.
+
+        The count of regular cells use their :py:attr:`Node.kind` as key, other statistics use
+        dunder-keys like: `__comb__`, `__io__`, `__seq__`, and so on.
+        """
+        stats = defaultdict(int)
+        stats['__node__'] = len(self.nodes)
+        stats['__cell__'] = len(self.cells)
+        stats['__fork__'] = len(self.forks)
+        stats['__io__'] = len(self.io_nodes)
+        stats['__line__'] = len(self.lines)
+        for n in self.cells.values():
+            stats[n.kind] += 1
+            if 'dff' in n.kind.lower(): stats['__dff__'] += 1
+            elif 'latch' in n.kind.lower(): stats['__latch__'] += 1
+            elif 'put' not in n.kind.lower(): stats['__comb__'] += 1 # no input or output
+        stats['__seq__'] = stats['__dff__'] + stats['__latch__']
+        return dict(stats)
+
     def get_or_add_fork(self, name):
         return self.forks[name] if name in self.forks else Node(self, name)
 
+    def remove_dangling_nodes(self, root_node:Node):
+        if len([l for l in root_node.outs if l is not None]) > 0: return
+        lines = [l for l in root_node.ins if l is not None]
+        drivers = [l.driver for l in lines]
+        root_node.remove()
+        for l in lines:
+            l.remove()
+        for d in drivers:
+            self.remove_dangling_nodes(d)
+
+    def eliminate_1to1_forks(self):
+        """Removes all forks that drive only one node.
+
+        Such forks are inserted by parsers to annotate signal names. If this
+        information is not needed, such forks can be removed and the two neighbors
+        can be connected directly using one line. Forks that drive more than one node
+        are not removed by this function.
+
+        This function may remove some nodes and some lines from the circuit.
+        Therefore that indices of other nodes and lines may change to keep the indices consecutive.
+        It may therefore invalidate external data for nodes and lines.
+        """
+        ios = set(self.io_nodes)
+        for n in list(self.forks.values()):
+            if n in ios: continue
+            if len(n.outs) != 1: continue
+            in_line = n.ins[0]
+            out_line = n.outs[0]
+            out_reader = out_line.reader
+            out_reader_pin = out_line.reader_pin
+            n.remove()
+            out_line.remove()
+            in_line.reader = out_reader
+            in_line.reader_pin = out_reader_pin
+            in_line.reader.ins[in_line.reader_pin] = in_line
+
+    def substitute(self, node, impl):
+        """Replaces a given node with the given implementation circuit.
+
+        The given node will be removed, the implementation is copied in and
+        the signal lines are connected appropriately. The number and arrangement
+        of the input and output ports must match the pins of the replaced node.
+
+        This function tries to preserve node and line indices as much as possible.
+        Usually, it only adds additional nodes and lines, preserving the order of
+        all existing nodes and lines. If an implementation is empty, however, nodes
+        and lines may get removed, changing indices and invalidating external data.
+        """
+        ios = set(impl.io_nodes)
+        impl_in_nodes = [n for n in impl.io_nodes if len(n.ins) == 0]
+        impl_out_lines = [n.ins[0] for n in impl.io_nodes if len(n.ins) > 0]
+        designated_cell = None
+        if len(impl_out_lines) > 0:
+            n = impl_out_lines[0].driver
+            while n.kind == '__fork__' and n not in ios:
+                n = n.ins[0].driver
+            designated_cell = n
+        node_in_lines = list(node.ins) + [None] * (len(impl_in_nodes)-len(node.ins))
+        node_out_lines = list(node.outs) + [None] * (len(impl_out_lines)-len(node.outs))
+        assert len(node_in_lines) == len(impl_in_nodes)
+        assert len(node_out_lines) == len(impl_out_lines)
+        node_map = dict()
+        if designated_cell is not None:
+            node.kind = designated_cell.kind
+            node_map[designated_cell] = node
+            node.ins = GrowingList()
+            node.outs = GrowingList()
+        else:
+            node.remove()
+        ios = set(impl.io_nodes)
+        for n in impl.nodes:  # add all nodes to main circuit
+            if n not in ios:
+                if n != designated_cell:
+                    node_map[n] = Node(self, f'{node.name}~{n.name}', n.kind)
+            elif len(n.outs) > 0 and len(n.ins) > 0:  # output is also read by impl. circuit, need to add a fork.
+                node_map[n] = Node(self, f'{node.name}~{n.name}')
+            elif len(n.ins) == 0 and len(n.outs) > 1:  # input is read by multiple nodes, need to add fork.
+                node_map[n] = Node(self, f'{node.name}~{n.name}')
+        for l in impl.lines:  # add all internal lines to main circuit
+            if l.reader in node_map and l.driver in node_map:
+                Line(self, (node_map[l.driver], l.driver_pin), (node_map[l.reader], l.reader_pin))
+        for inn, ll in zip(impl_in_nodes, node_in_lines):  # connect inputs
+            if ll is None: continue
+            if len(inn.outs) == 1:
+                l = inn.outs[0]
+                ll.reader = node_map[l.reader]
+                ll.reader_pin = l.reader_pin
+            else:
+                ll.reader = node_map[inn]  # connect to existing fork
+                ll.reader_pin = 0
+            ll.reader.ins[ll.reader_pin] = ll
+        for l, ll in zip(impl_out_lines, node_out_lines):  # connect outputs
+            if ll is None:
+                if l.driver in node_map:
+                    self.remove_dangling_nodes(node_map[l.driver])
+                continue
+            if len(l.reader.outs) > 0:  # output is also read by impl. circuit, connect to fork.
+                ll.driver = node_map[l.reader]
+                ll.driver_pin = len(l.reader.outs)
+            else:
+                ll.driver = node_map[l.driver]
+                ll.driver_pin = l.driver_pin
+            ll.driver.outs[ll.driver_pin] = ll
+
+    def resolve_tlib_cells(self, tlib):
+        """Substitute all technology library cells with kyupy native simulation primitives.
+
+        See :py:attr:`substitute()` for more detail.
+        """
+        for n in list(self.nodes):
+            if n.kind in tlib.cells:
+                self.substitute(n, tlib.cells[n.kind][0])
+
     def copy(self):
         """Returns a deep copy of the circuit.
         """
         c = Circuit(self.name)
         for node in self.nodes:
             Node(c, node.name, node.kind)
         for line in self.lines:
             d = c.forks[line.driver.name] if line.driver.kind == '__fork__' else c.cells[line.driver.name]
             r = c.forks[line.reader.name] if line.reader.kind == '__fork__' else c.cells[line.reader.name]
             Line(c, (d, line.driver_pin), (r, line.reader_pin))
-        for node in self.interface:
+        for node in self.io_nodes:
             if node.kind == '__fork__':
                 n = c.forks[node.name]
             else:
                 n = c.cells[node.name]
-            c.interface.append(n)
+            c.io_nodes.append(n)
         return c
 
-    def dump(self):
-        """Returns a string representation of the circuit and all its nodes.
-        """
-        header = f'{self.name}({",".join([str(n.index) for n in self.interface])})\n'
-        return header + '\n'.join([str(n) for n in self.nodes])
+    def __getstate__(self):
+        nodes = [(node.name, node.kind) for node in self.nodes]
+        lines = [(line.driver.index, line.driver_pin, line.reader.index, line.reader_pin) for line in self.lines]
+        io_nodes = [n.index for n in self.io_nodes]
+        return {'name': self.name,
+                'nodes': nodes,
+                'lines': lines,
+                'io_nodes': io_nodes }
+
+    def __setstate__(self, state):
+        self.name = state['name']
+        self.nodes = IndexList()
+        self.lines = IndexList()
+        self.io_nodes = GrowingList()
+        self.cells = {}
+        self.forks = {}
+        for s in state['nodes']:
+            Node(self, *s)
+        for driver, driver_pin, reader, reader_pin in state['lines']:
+            Line(self, (self.nodes[driver], driver_pin), (self.nodes[reader], reader_pin))
+        for n in state['io_nodes']:
+            self.io_nodes.append(self.nodes[n])
+
+    def __eq__(self, other):
+        return self.nodes == other.nodes and self.lines == other.lines and self.io_nodes == other.io_nodes
 
     def __repr__(self):
-        name = f' {self.name}' if self.name else ''
-        return f'<Circuit{name} cells={len(self.cells)} forks={len(self.forks)} ' + \
-               f'lines={len(self.lines)} ports={len(self.interface)}>'
+        return f'{{name: "{self.name}", cells: {len(self.cells)}, forks: {len(self.forks)}, lines: {len(self.lines)}, io_nodes: {len(self.io_nodes)}}}'
 
     def topological_order(self):
         """Generator function to iterate over all nodes in topological order.
 
-        Nodes without input lines and nodes whose :py:attr:`Node.kind` contains the substring 'DFF' are
-        yielded first.
+        Nodes without input lines and nodes whose :py:attr:`Node.kind` contains the
+        substrings 'dff' or 'latch' are yielded first.
         """
-        visit_count = [0] * len(self.nodes)
-        queue = deque(n for n in self.nodes if len(n.ins) == 0 or 'DFF' in n.kind)
+        visit_count = np.zeros(len(self.nodes), dtype=np.uint32)
+        queue = deque(n for n in self.nodes if len(n.ins) == 0 or 'dff' in n.kind.lower() or 'latch' in n.kind.lower())
         while len(queue) > 0:
             n = queue.popleft()
             for line in n.outs:
                 if line is None: continue
                 succ = line.reader
                 visit_count[succ] += 1
-                if visit_count[succ] == len(succ.ins) and 'DFF' not in succ.kind:
+                if visit_count[succ] == len(succ.ins) and 'dff' not in succ.kind.lower() and 'latch' not in succ.kind.lower():
                     queue.append(succ)
             yield n
 
+    def topological_order_with_level(self):
+        level = np.zeros(len(self.nodes), dtype=np.int32) - 1
+        for n in self.topological_order():
+            if len(n.ins) == 0 or 'dff' in n.kind.lower() or 'latch' in n.kind.lower():
+                l = 0
+            else:
+                l = level[[l.driver.index for l in n.ins if l is not None]].max() + 1
+            level[n] = l
+            yield n, l
+
     def topological_line_order(self):
         """Generator function to iterate over all lines in topological order.
         """
         for n in self.topological_order():
             for line in n.outs:
                 if line is not None:
                     yield line
 
     def reversed_topological_order(self):
         """Generator function to iterate over all nodes in reversed topological order.
 
-        Nodes without output lines and nodes whose :py:attr:`Node.kind` contains the substring 'DFF' are
-        yielded first.
+        Nodes without output lines and nodes whose :py:attr:`Node.kind` contains the
+        substrings 'dff' or 'latch' are yielded first.
         """
         visit_count = [0] * len(self.nodes)
-        queue = deque(n for n in self.nodes if len(n.outs) == 0 or 'DFF' in n.kind)
+        queue = deque(n for n in self.nodes if len(n.outs) == 0 or 'dff' in n.kind.lower() or 'latch' in n.kind.lower())
         while len(queue) > 0:
             n = queue.popleft()
             for line in n.ins:
                 pred = line.driver
                 visit_count[pred] += 1
-                if visit_count[pred] == len(pred.outs) and 'DFF' not in pred.kind:
+                if visit_count[pred] == len(pred.outs) and 'dff' not in pred.kind.lower() and 'latch' not in pred.kind.lower():
                     queue.append(pred)
             yield n
 
     def fanin(self, origin_nodes):
         """Generator function to iterate over the fan-in cone of a given list of origin nodes.
 
         Nodes are yielded in reversed topological order.
@@ -306,25 +561,55 @@
                     if line is not None:
                         marks[n] |= marks[line.reader]
             if marks[n]:
                 yield n
 
     def fanout_free_regions(self):
         for stem in self.reversed_topological_order():
-            if len(stem.outs) == 1 and 'DFF' not in stem.kind: continue
+            if len(stem.outs) == 1 and 'dff' not in stem.kind.lower(): continue
             region = []
-            if 'DFF' in stem.kind:
+            if 'dff' in stem.kind.lower():
                 n = stem.ins[0]
-                if len(n.driver.outs) == 1 and 'DFF' not in n.driver.kind:
+                if len(n.driver.outs) == 1 and 'dff' not in n.driver.kind.lower():
                     queue = deque([n.driver])
                 else:
                     queue = deque()
             else:
                 queue = deque(n.driver for n in stem.ins
-                              if len(n.driver.outs) == 1 and 'DFF' not in n.driver.kind)
+                              if len(n.driver.outs) == 1 and 'dff' not in n.driver.kind.lower())
             while len(queue) > 0:
                 n = queue.popleft()
                 preds = [pred.driver for pred in n.ins
-                         if len(pred.driver.outs) == 1 and 'DFF' not in pred.driver.kind]
+                         if len(pred.driver.outs) == 1 and 'dff' not in pred.driver.kind.lower()]
                 queue.extend(preds)
                 region.append(n)
             yield stem, region
+
+    def dot(self, format='svg'):
+        from graphviz import Digraph
+        dot = Digraph(format=format, graph_attr={'rankdir': 'LR', 'splines': 'true'})
+
+        s_dict = dict((n, i) for i, n in enumerate(self.s_nodes))
+        node_level = np.zeros(len(self.nodes), dtype=np.uint32)
+        level_nodes = defaultdict(list)
+        for n, lv in self.topological_order_with_level():
+            level_nodes[lv].append(n)
+            node_level[n] = lv
+
+        for lv in level_nodes:
+            with dot.subgraph() as s:
+                s.attr(rank='same')
+                for n in level_nodes[lv]:
+                    ins = '|'.join([f'<i{i}>{i}' for i in range(len(n.ins))])
+                    outs = '|'.join([f'<o{i}>{i}' for i in range(len(n.outs))])
+                    io = f' [{s_dict[n]}]' if n in s_dict else ''
+                    s.node(name=str(n.index), label = f'{{{{{ins}}}|{n.index}{io}\n{n.kind}\n{n.name}|{{{outs}}}}}', shape='record')
+
+        for l in self.lines:
+            driver, reader = f'{l.driver.index}:o{l.driver_pin}', f'{l.reader.index}:i{l.reader_pin}'
+            if node_level[l.driver] >= node_level[l.reader]:
+                dot.edge(driver, reader, style='dotted', label=str(l.index))
+                pass
+            else:
+                dot.edge(driver, reader, label=str(l.index))
+
+        return dot
```

## kyupy/logic.py

```diff
@@ -1,30 +1,53 @@
-"""This module contains definitions and data structures for 2-, 4-, and 8-valued logic operations.
+"""Core module for handling 2-, 4-, and 8-valued logic data and signal values.
+
+Logic values are stored in numpy arrays with data type ``np.uint8``.
+There are no explicit data structures in KyuPy for holding patterns, pattern sets or vectors.
+However, there are conventions on logic value encoding and on the order of axes.
+Utility functions defined here follow these conventions.
 
 8 logic values are defined as integer constants.
 
 * For 2-valued logic: ``ZERO`` and ``ONE``
 * 4-valued logic adds: ``UNASSIGNED`` and ``UNKNOWN``
 * 8-valued logic adds: ``RISE``, ``FALL``, ``PPULSE``, and ``NPULSE``.
 
-The bits in these constants have the following meaning:
+In general, the bits in these constants have the following meaning:
+
+* bit0: Final/settled binary value of a signal
+* bit1: Initial binary value of a signal
+* bit2: Activity or transitions are present on a signal
+
+Except when bit0 differs from bit1, but bit2 (activity) is 0:
+
+* bit0 = 1, bit1 = 0, bit2 = 0 means ``UNKNOWN`` in 4-valued and 8-valued logic.
+* bit0 = 0, bit1 = 1, bit2 = 0 means ``UNASSIGNED`` in 4-valued and 8-valued logic.
+
+2-valued logic only considers bit0, but should store logic one as ``ONE=0b011`` for interoperability.
+4-valued logic only considers bit0 and bit1.
+8-valued logic considers all 3 bits.
+
+Logic values are stored in numpy arrays of data type ``np.uint8``.
+The axis convention is as follows:
+
+* The **last** axis goes along patterns/vectors. I.e. ``values[...,0]`` is pattern 0, ``values[...,1]`` is pattern 1, etc.
+* The **second-to-last** axis goes along the I/O and flip-flops of circuits. For a circuit ``c``, this axis is usually
+  ``len(c.s_nodes)`` long. The values of all inputs, outputs and flip-flops are stored within the same array and the location
+  along the second-to-last axis is determined by the order in :py:attr:`~kyupy.circuit.Circuit.s_nodes`.
+
+Two storage formats are used in KyuPy:
+
+* ``mv...`` (for "multi-valued"): Each logic value is stored in the least significant 3 bits of ``np.uint8``.
+* ``bp...`` (for "bit-parallel"): Groups of 8 logic values are stored as three ``np.uint8``. This format is used
+  for bit-parallel logic simulations. It is also more memory-efficient.
+
+The functions in this module use the ``mv...`` and ``bp...`` prefixes to signify the storage format they operate on.
 
-  * bit 0: Final/settled binary value of a signal
-  * bit 1: Initial binary value of a signal
-  * bit 2: Activity or transitions are present on a signal
-
-Special meaning is given to values where bits 0 and 1 differ, but bit 2 (activity) is 0.
-These values are interpreted as ``UNKNOWN`` or ``UNASSIGNED`` in 4-valued and 8-valued logic.
-
-In general, 2-valued logic only considers bit 0, 4-valued logic considers bits 0 and 1, and 8-valued logic
-considers all 3 bits.
-The only exception is constant ``ONE=0b11`` which has two bits set for all logics including 2-valued logic.
 """
 
-import math
 from collections.abc import Iterable
 
 import numpy as np
 
 from . import numba, hr_bytes
 
 
@@ -62,401 +85,349 @@
 
     :param value: A character (string of length 1), Boolean, Integer, None, or Iterable.
         Iterables (such as strings) are traversed and their individual characters are interpreted.
     :return: A logic constant or a (possibly multi-dimensional) list of logic constants.
     """
     if isinstance(value, Iterable) and not (isinstance(value, str) and len(value) == 1):
         return list(map(interpret, value))
-    if value in [0, '0', False, 'L', 'l']:
-        return ZERO
-    if value in [1, '1', True, 'H', 'h']:
-        return ONE
-    if value in [None, '-', 'Z', 'z']:
-        return UNASSIGNED
-    if value in ['R', 'r', '/']:
-        return RISE
-    if value in ['F', 'f', '\\']:
-        return FALL
-    if value in ['P', 'p', '^']:
-        return PPULSE
-    if value in ['N', 'n', 'v']:
-        return NPULSE
+    if value in [0, '0', False, 'L', 'l']: return ZERO
+    if value in [1, '1', True, 'H', 'h']: return ONE
+    if value in [None, '-', 'Z', 'z']: return UNASSIGNED
+    if value in ['R', 'r', '/']: return RISE
+    if value in ['F', 'f', '\\']: return FALL
+    if value in ['P', 'p', '^']: return PPULSE
+    if value in ['N', 'n', 'v']: return NPULSE
     return UNKNOWN
 
 
-_bit_in_lut = np.array([2 ** x for x in range(7, -1, -1)], dtype='uint8')
-
+def mvarray(*a):
+    """Converts (lists of) Boolean values or strings into a multi-valued array.
 
-@numba.njit
-def bit_in(a, pos):
-    return a[pos >> 3] & _bit_in_lut[pos & 7]
-
-
-class MVArray:
-    """An n-dimensional array of m-valued logic values.
-
-    This class wraps a numpy.ndarray of type uint8 and adds support for encoding and
-    interpreting 2-valued, 4-valued, and 8-valued logic values.
-    Each logic value is stored as an uint8, manipulations of individual values are cheaper than in
-    :py:class:`BPArray`.
-
-    :param a: If a tuple is given, it is interpreted as desired shape. To make an array of ``n`` vectors
-        compatible with a simulator ``sim``, use ``(len(sim.interface), n)``. If a :py:class:`BPArray` or
-        :py:class:`MVArray` is given, a deep copy is made. If a string, a list of strings, a list of characters,
-        or a list of lists of characters are given, the data is interpreted best-effort and the array is
-        initialized accordingly.
-    :param m: The arity of the logic. Can be set to 2, 4, or 8. If None is given, the arity of a given
-        :py:class:`BPArray` or :py:class:`MVArray` is used, or, if the array is initialized differently, 8 is used.
-    """
-
-    def __init__(self, a, m=None):
-        self.m = m or 8
-        assert self.m in [2, 4, 8]
-
-        # Try our best to interpret given a.
-        if isinstance(a, MVArray):
-            self.data = a.data.copy()
-            """The wrapped 2-dimensional ndarray of logic values.
-
-            * Axis 0 is PI/PO/FF position, the length of this axis is called "width".
-            * Axis 1 is vector/pattern, the length of this axis is called "length".
-            """
-            self.m = m or a.m
-        elif hasattr(a, 'data'):  # assume it is a BPArray. Can't use isinstance() because BPArray isn't declared yet.
-            self.data = np.zeros((a.width, a.length), dtype=np.uint8)
-            self.m = m or a.m
-            for i in range(a.data.shape[-2]):
-                self.data[...] <<= 1
-                self.data[...] |= np.unpackbits(a.data[..., -i-1, :], axis=1)[:, :a.length]
-            if a.data.shape[-2] == 1:
-                self.data *= 3
-        elif isinstance(a, int):
-            self.data = np.full((a, 1), UNASSIGNED, dtype=np.uint8)
-        elif isinstance(a, tuple):
-            self.data = np.full(a, UNASSIGNED, dtype=np.uint8)
-        else:
-            if isinstance(a, str): a = [a]
-            self.data = np.asarray(interpret(a), dtype=np.uint8)
-            self.data = self.data[:, np.newaxis] if self.data.ndim == 1 else np.moveaxis(self.data, -2, -1)
-
-        # Cast data to m-valued logic.
-        if self.m == 2:
-            self.data[...] = ((self.data & 0b001) & ((self.data >> 1) & 0b001) | (self.data == RISE)) * ONE
-        elif self.m == 4:
-            self.data[...] = (self.data & 0b011) & ((self.data != FALL) * ONE) | ((self.data == RISE) * ONE)
-        elif self.m == 8:
-            self.data[...] = self.data & 0b111
-
-        self.length = self.data.shape[-1]
-        self.width = self.data.shape[-2]
-
-    def __repr__(self):
-        return f'<MVArray length={self.length} width={self.width} m={self.m} mem={hr_bytes(self.data.nbytes)}>'
-
-    def __str__(self):
-        return str([self[idx] for idx in range(self.length)])
-
-    def __getitem__(self, vector_idx):
-        """Returns a string representing the desired vector."""
-        chars = ["0", "X", "-", "1", "P", "R", "F", "N"]
-        return ''.join(chars[v] for v in self.data[:, vector_idx])
-
-    def __len__(self):
-        return self.length
-
-
-def mv_cast(*args, m=8):
-    return [a if isinstance(a, MVArray) else MVArray(a, m=m) for a in args]
+    The given values are interpreted and the axes are arranged as per KyuPy's convention.
+    Use this function to convert strings into multi-valued arrays.
+    """
+    mva = np.array(interpret(a), dtype=np.uint8)
+    if mva.ndim < 2: return mva
+    if mva.shape[-2] > 1: return mva.swapaxes(-1, -2)
+    return mva[..., 0, :]
 
 
-def mv_getm(*args):
-    return max([a.m for a in args if isinstance(a, MVArray)] + [0]) or 8
+def mv_str(mva, delim='\n'):
+    """Renders a given multi-valued array into a string.
+    """
+    sa = np.choose(mva, np.array([*'0X-1PRFN'], dtype=np.unicode_))
+    if not hasattr(mva, 'ndim') or mva.ndim == 0: return sa
+    if mva.ndim == 1: return ''.join(sa)
+    return delim.join([''.join(c) for c in sa.swapaxes(-1,-2)])
 
 
-def _mv_not(m, out, inp):
+def _mv_not(out, inp):
     np.bitwise_xor(inp, 0b11, out=out)  # this also exchanges UNASSIGNED <-> UNKNOWN
-    if m > 2:
-        np.putmask(out, (inp == UNKNOWN), UNKNOWN)  # restore UNKNOWN
+    np.putmask(out, (inp == UNKNOWN), UNKNOWN)  # restore UNKNOWN
 
 
-def mv_not(x1, out=None):
+def mv_not(x1 : np.ndarray, out=None):
     """A multi-valued NOT operator.
 
-    :param x1: An :py:class:`MVArray` or data the :py:class:`MVArray` constructor accepts.
-    :param out: Optionally an :py:class:`MVArray` as storage destination. If None, a new :py:class:`MVArray`
-        is returned.
-    :return: An :py:class:`MVArray` with the result.
-    """
-    m = mv_getm(x1)
-    x1 = mv_cast(x1, m=m)[0]
-    out = out or MVArray(x1.data.shape, m=m)
-    _mv_not(m, out.data, x1.data)
+    :param x1: A multi-valued array.
+    :param out: An optional storage destination. If None, a new multi-valued array is returned.
+    :return: A multi-valued array with the result.
+    """
+    out = out or np.empty(x1.shape, dtype=np.uint8)
+    _mv_not(out, x1)
     return out
 
 
-def _mv_or(m, out, *ins):
-    if m > 2:
-        any_unknown = (ins[0] == UNKNOWN) | (ins[0] == UNASSIGNED)
-        for inp in ins[1:]: any_unknown |= (inp == UNKNOWN) | (inp == UNASSIGNED)
-        any_one = (ins[0] == ONE)
-        for inp in ins[1:]: any_one |= (inp == ONE)
-
-        out[...] = ZERO
-        np.putmask(out, any_one, ONE)
-        for inp in ins:
-            np.bitwise_or(out, inp, out=out, where=~any_one)
-        np.putmask(out, (any_unknown & ~any_one), UNKNOWN)
-    else:
-        out[...] = ZERO
-        for inp in ins: np.bitwise_or(out, inp, out=out)
+def _mv_or(out, *ins):
+    any_unknown = (ins[0] == UNKNOWN) | (ins[0] == UNASSIGNED)
+    for inp in ins[1:]: any_unknown |= (inp == UNKNOWN) | (inp == UNASSIGNED)
+    any_one = (ins[0] == ONE)
+    for inp in ins[1:]: any_one |= (inp == ONE)
+
+    out[...] = ZERO
+    np.putmask(out, any_one, ONE)
+    for inp in ins:
+        np.bitwise_or(out, inp, out=out, where=~any_one)
+    np.putmask(out, (any_unknown & ~any_one), UNKNOWN)
 
 
 def mv_or(x1, x2, out=None):
     """A multi-valued OR operator.
 
-    :param x1: An :py:class:`MVArray` or data the :py:class:`MVArray` constructor accepts.
-    :param x2: An :py:class:`MVArray` or data the :py:class:`MVArray` constructor accepts.
-    :param out: Optionally an :py:class:`MVArray` as storage destination. If None, a new :py:class:`MVArray`
-        is returned.
-    :return: An :py:class:`MVArray` with the result.
-    """
-    m = mv_getm(x1, x2)
-    x1, x2 = mv_cast(x1, x2, m=m)
-    out = out or MVArray(np.broadcast(x1.data, x2.data).shape, m=m)
-    _mv_or(m, out.data, x1.data, x2.data)
+    :param x1: A multi-valued array.
+    :param x2: A multi-valued array.
+    :param out: An optional storage destination. If None, a new multi-valued array is returned.
+    :return: A multi-valued array with the result.
+    """
+    out = out or np.empty(np.broadcast(x1, x2).shape, dtype=np.uint8)
+    _mv_or(out, x1, x2)
     return out
 
 
-def _mv_and(m, out, *ins):
-    if m > 2:
-        any_unknown = (ins[0] == UNKNOWN) | (ins[0] == UNASSIGNED)
-        for inp in ins[1:]: any_unknown |= (inp == UNKNOWN) | (inp == UNASSIGNED)
-        any_zero = (ins[0] == ZERO)
-        for inp in ins[1:]: any_zero |= (inp == ZERO)
-
-        out[...] = ONE
-        np.putmask(out, any_zero, ZERO)
-        for inp in ins:
-            np.bitwise_and(out, inp | 0b100, out=out, where=~any_zero)
-            if m > 4: np.bitwise_or(out, inp & 0b100, out=out, where=~any_zero)
-        np.putmask(out, (any_unknown & ~any_zero), UNKNOWN)
-    else:
-        out[...] = ONE
-        for inp in ins: np.bitwise_and(out, inp, out=out)
+def _mv_and(out, *ins):
+    any_unknown = (ins[0] == UNKNOWN) | (ins[0] == UNASSIGNED)
+    for inp in ins[1:]: any_unknown |= (inp == UNKNOWN) | (inp == UNASSIGNED)
+    any_zero = (ins[0] == ZERO)
+    for inp in ins[1:]: any_zero |= (inp == ZERO)
+
+    out[...] = ONE
+    np.putmask(out, any_zero, ZERO)
+    for inp in ins:
+        np.bitwise_and(out, inp | 0b100, out=out, where=~any_zero)
+        np.bitwise_or(out, inp & 0b100, out=out, where=~any_zero)
+    np.putmask(out, (any_unknown & ~any_zero), UNKNOWN)
 
 
 def mv_and(x1, x2, out=None):
     """A multi-valued AND operator.
 
-    :param x1: An :py:class:`MVArray` or data the :py:class:`MVArray` constructor accepts.
-    :param x2: An :py:class:`MVArray` or data the :py:class:`MVArray` constructor accepts.
-    :param out: Optionally an :py:class:`MVArray` as storage destination. If None, a new :py:class:`MVArray`
-        is returned.
-    :return: An :py:class:`MVArray` with the result.
-    """
-    m = mv_getm(x1, x2)
-    x1, x2 = mv_cast(x1, x2, m=m)
-    out = out or MVArray(np.broadcast(x1.data, x2.data).shape, m=m)
-    _mv_and(m, out.data, x1.data, x2.data)
+    :param x1: A multi-valued array.
+    :param x2: A multi-valued array.
+    :param out: An optional storage destination. If None, a new multi-valued array is returned.
+    :return: A multi-valued array with the result.
+    """
+    out = out or np.empty(np.broadcast(x1, x2).shape, dtype=np.uint8)
+    _mv_and(out, x1, x2)
     return out
 
 
-def _mv_xor(m, out, *ins):
-    if m > 2:
-        any_unknown = (ins[0] == UNKNOWN) | (ins[0] == UNASSIGNED)
-        for inp in ins[1:]: any_unknown |= (inp == UNKNOWN) | (inp == UNASSIGNED)
-
-        out[...] = ZERO
-        for inp in ins:
-            np.bitwise_xor(out, inp & 0b011, out=out)
-            if m > 4: np.bitwise_or(out, inp & 0b100, out=out)
-        np.putmask(out, any_unknown, UNKNOWN)
-    else:
-        out[...] = ZERO
-        for inp in ins: np.bitwise_xor(out, inp, out=out)
+def _mv_xor(out, *ins):
+    any_unknown = (ins[0] == UNKNOWN) | (ins[0] == UNASSIGNED)
+    for inp in ins[1:]: any_unknown |= (inp == UNKNOWN) | (inp == UNASSIGNED)
+
+    out[...] = ZERO
+    for inp in ins:
+        np.bitwise_xor(out, inp & 0b011, out=out)
+        np.bitwise_or(out, inp & 0b100, out=out)
+    np.putmask(out, any_unknown, UNKNOWN)
 
 
 def mv_xor(x1, x2, out=None):
     """A multi-valued XOR operator.
 
-    :param x1: An :py:class:`MVArray` or data the :py:class:`MVArray` constructor accepts.
-    :param x2: An :py:class:`MVArray` or data the :py:class:`MVArray` constructor accepts.
-    :param out: Optionally an :py:class:`MVArray` as storage destination. If None, a new :py:class:`MVArray`
-        is returned.
-    :return: An :py:class:`MVArray` with the result.
-    """
-    m = mv_getm(x1, x2)
-    x1, x2 = mv_cast(x1, x2, m=m)
-    out = out or MVArray(np.broadcast(x1.data, x2.data).shape, m=m)
-    _mv_xor(m, out.data, x1.data, x2.data)
+    :param x1: A multi-valued array.
+    :param x2: A multi-valued array.
+    :param out: An optional storage destination. If None, a new multi-valued array is returned.
+    :return: A multi-valued array with the result.
+    """
+    out = out or np.empty(np.broadcast(x1, x2).shape, dtype=np.uint8)
+    _mv_xor(out, x1, x2)
+    return out
+
+
+def mv_latch(d, t, q_prev, out=None):
+    """A multi-valued latch operator.
+
+    A latch outputs ``d`` when transparent (``t`` is high).
+    It outputs ``q_prev`` when in latched state (``t`` is low).
+
+    :param d: A multi-valued array for the data input.
+    :param t: A multi-valued array for the control input.
+    :param q_prev: A multi-valued array with the output value of this latch from the previous clock cycle.
+    :param out: An optional storage destination. If None, a new multi-valued array is returned.
+    :return: A multi-valued array for the latch output ``q``.
+    """
+    out = out or np.empty(np.broadcast(d, t, q_prev).shape, dtype=np.uint8)
+    out[...] = t & d & 0b011
+    out[...] |= ~t & 0b010 & (q_prev << 1)
+    out[...] |= ~t & 0b001 & (out >> 1)
+    out[...] |= ((out << 1) ^ (out << 2)) & 0b100
+    unknown = (t == UNKNOWN) \
+              | (t == UNASSIGNED) \
+              | (((d == UNKNOWN) | (d == UNASSIGNED)) & (t != ZERO))
+    np.putmask(out, unknown, UNKNOWN)
     return out
 
 
 def mv_transition(init, final, out=None):
     """Computes the logic transitions from the initial values of ``init`` to the final values of ``final``.
     Pulses in the input data are ignored. If any of the inputs are ``UNKNOWN``, the result is ``UNKNOWN``.
     If both inputs are ``UNASSIGNED``, the result is ``UNASSIGNED``.
 
-    :param init: An :py:class:`MVArray` or data the :py:class:`MVArray` constructor accepts.
-    :param final: An :py:class:`MVArray` or data the :py:class:`MVArray` constructor accepts.
-    :param out: Optionally an :py:class:`MVArray` as storage destination. If None, a new :py:class:`MVArray`
-        is returned.
-    :return: An :py:class:`MVArray` with the result.
-    """
-    m = mv_getm(init, final)
-    init, final = mv_cast(init, final, m=m)
-    init = init.data
-    final = final.data
-    out = out or MVArray(np.broadcast(init, final).shape, m=8)
-    out.data[...] = (init & 0b010) | (final & 0b001)
-    out.data[...] |= ((out.data << 1) ^ (out.data << 2)) & 0b100
+    :param init: A multi-valued array.
+    :param final: A multi-valued array.
+    :param out: An optional storage destination. If None, a new multi-valued array is returned.
+    :return: A multi-valued array with the result.
+    """
+    out = out or np.empty(np.broadcast(init, final).shape, dtype=np.uint8)
+    out[...] = (init & 0b010) | (final & 0b001)
+    out[...] |= ((out << 1) ^ (out << 2)) & 0b100
     unknown = (init == UNKNOWN) | (init == UNASSIGNED) | (final == UNKNOWN) | (final == UNASSIGNED)
     unassigned = (init == UNASSIGNED) & (final == UNASSIGNED)
-    np.putmask(out.data, unknown, UNKNOWN)
-    np.putmask(out.data, unassigned, UNASSIGNED)
+    np.putmask(out, unknown, UNKNOWN)
+    np.putmask(out, unassigned, UNASSIGNED)
+    return out
+
+
+def mv_to_bp(mva):
+    """Converts a multi-valued array into a bit-parallel array.
+    """
+    if mva.ndim == 1: mva = mva[..., np.newaxis]
+    return np.packbits(unpackbits(mva)[...,:3], axis=-2, bitorder='little').swapaxes(-1,-2)
+
+
+def bparray(*a):
+    """Converts (lists of) Boolean values or strings into a bit-parallel array.
+
+    The given values are interpreted and the axes are arranged as per KyuPy's convention.
+    Use this function to convert strings into bit-parallel arrays.
+    """
+    return mv_to_bp(mvarray(*a))
+
+
+def bp_to_mv(bpa):
+    """Converts a bit-parallel array into a multi-valued array.
+    """
+    return packbits(np.unpackbits(bpa, axis=-1, bitorder='little').swapaxes(-1,-2))
+
+
+def bp4v_buf(out, inp):
+    unknown = inp[..., 0, :] ^ inp[..., 1, :]
+    out[..., 0, :] = inp[..., 0, :] | unknown
+    out[..., 1, :] = inp[..., 1, :] & ~unknown
+    return out
+
+
+def bp8v_buf(out, inp):
+    unknown = (inp[..., 0, :] ^ inp[..., 1, :]) & ~inp[..., 2, :]
+    out[..., 0, :] = inp[..., 0, :] | unknown
+    out[..., 1, :] = inp[..., 1, :] & ~unknown
+    out[..., 2, :] = inp[..., 2, :] & ~unknown
+    return out
+
+
+def bp4v_not(out, inp):
+    unknown = inp[..., 0, :] ^ inp[..., 1, :]
+    out[..., 0, :] = ~inp[..., 0, :] | unknown
+    out[..., 1, :] = ~inp[..., 1, :] & ~unknown
+    return out
+
+
+def bp8v_not(out, inp):
+    unknown = (inp[..., 0, :] ^ inp[..., 1, :]) & ~inp[..., 2, :]
+    out[..., 0, :] = ~inp[..., 0, :] | unknown
+    out[..., 1, :] = ~inp[..., 1, :] & ~unknown
+    out[..., 2, :] = inp[..., 2, :] & ~unknown
     return out
 
 
-class BPArray:
-    """An n-dimensional array of m-valued logic values that uses bit-parallel storage.
+def bp4v_or(out, *ins):
+    out[...] = 0
+    any_unknown = ins[0][..., 0, :] ^ ins[0][..., 1, :]
+    for inp in ins[1:]: any_unknown |= inp[..., 0, :] ^ inp[..., 1, :]
+    any_one = ins[0][..., 0, :] & ins[0][..., 1, :]
+    for inp in ins[1:]: any_one |= inp[..., 0, :] & inp[..., 1, :]
+    for inp in ins:
+        out[..., 0, :] |= inp[..., 0, :] | any_unknown
+        out[..., 1, :] |= inp[..., 1, :] & (~any_unknown | any_one)
+    return out
+
 
-    The primary use of this format is in aiding efficient bit-parallel logic simulation.
-    The secondary benefit over :py:class:`MVArray` is its memory efficiency.
-    Accessing individual values is more expensive than with :py:class:`MVArray`.
-    Therefore it may be more efficient to unpack the data into an :py:class:`MVArray` and pack it again into a
-    :py:class:`BPArray` for simulation.
-
-    See :py:class:`MVArray` for constructor parameters.
-    """
-
-    def __init__(self, a, m=None):
-        if not isinstance(a, MVArray) and not isinstance(a, BPArray):
-            a = MVArray(a, m)
-            self.m = a.m
-        if isinstance(a, MVArray):
-            if m is not None and m != a.m:
-                a = MVArray(a, m)  # cast data
-            self.m = a.m
-            assert self.m in [2, 4, 8]
-            nwords = math.ceil(math.log2(self.m))
-            nbytes = (a.data.shape[-1] - 1) // 8 + 1
-            self.data = np.zeros(a.data.shape[:-1] + (nwords, nbytes), dtype=np.uint8)
-            """The wrapped 3-dimensional ndarray.
-
-            * Axis 0 is PI/PO/FF position, the length of this axis is called "width".
-            * Axis 1 has length ``ceil(log2(m))`` for storing all bits.
-            * Axis 2 are the vectors/patterns packed into uint8 words.
-            """
-            for i in range(self.data.shape[-2]):
-                self.data[..., i, :] = np.packbits((a.data >> i) & 1, axis=-1)
-        else:  # we have a BPArray
-            self.data = a.data.copy()  # TODO: support conversion to different m
-            self.m = a.m
-        self.length = a.length
-        self.width = a.width
-
-    def __repr__(self):
-        return f'<BPArray length={self.length} width={self.width} m={self.m} mem={hr_bytes(self.data.nbytes)}>'
-
-    def __len__(self):
-        return self.length
-
-
-def bp_buf(out, inp):
-    md = out.shape[-2]
-    assert md == inp.shape[-2]
-    if md > 1:
-        unknown = inp[..., 0, :] ^ inp[..., 1, :]
-        if md > 2: unknown &= ~inp[..., 2, :]
-        out[..., 0, :] = inp[..., 0, :] | unknown
-        out[..., 1, :] = inp[..., 1, :] & ~unknown
-        if md > 2: out[..., 2, :] = inp[..., 2, :] & ~unknown
-    else:
-        out[..., 0, :] = inp[..., 0, :]
-
-
-def bp_not(out, inp):
-    md = out.shape[-2]
-    assert md == inp.shape[-2]
-    if md > 1:
-        unknown = inp[..., 0, :] ^ inp[..., 1, :]
-        if md > 2: unknown &= ~inp[..., 2, :]
-        out[..., 0, :] = ~inp[..., 0, :] | unknown
-        out[..., 1, :] = ~inp[..., 1, :] & ~unknown
-        if md > 2: out[..., 2, :] = inp[..., 2, :] & ~unknown
-    else:
-        out[..., 0, :] = ~inp[..., 0, :]
-
-
-def bp_or(out, *ins):
-    md = out.shape[-2]
-    for inp in ins: assert md == inp.shape[-2]
+def bp8v_or(out, *ins):
     out[...] = 0
-    if md == 1:
-        for inp in ins: out[..., 0, :] |= inp[..., 0, :]
-    elif md == 2:
-        any_unknown = ins[0][..., 0, :] ^ ins[0][..., 1, :]
-        for inp in ins[1:]: any_unknown |= inp[..., 0, :] ^ inp[..., 1, :]
-        any_one = ins[0][..., 0, :] & ins[0][..., 1, :]
-        for inp in ins[1:]: any_one |= inp[..., 0, :] & inp[..., 1, :]
-        for inp in ins:
-            out[..., 0, :] |= inp[..., 0, :] | any_unknown
-            out[..., 1, :] |= inp[..., 1, :] & (~any_unknown | any_one)
-    else:
-        any_unknown = (ins[0][..., 0, :] ^ ins[0][..., 1, :]) & ~ins[0][..., 2, :]
-        for inp in ins[1:]: any_unknown |= (inp[..., 0, :] ^ inp[..., 1, :]) & ~inp[..., 2, :]
-        any_one = ins[0][..., 0, :] & ins[0][..., 1, :] & ~ins[0][..., 2, :]
-        for inp in ins[1:]: any_one |= inp[..., 0, :] & inp[..., 1, :] & ~inp[..., 2, :]
-        for inp in ins:
-            out[..., 0, :] |= inp[..., 0, :] | any_unknown
-            out[..., 1, :] |= inp[..., 1, :] & (~any_unknown | any_one)
-            out[..., 2, :] |= inp[..., 2, :] & (~any_unknown | any_one) & ~any_one
-
-
-def bp_and(out, *ins):
-    md = out.shape[-2]
-    for inp in ins: assert md == inp.shape[-2]
+    any_unknown = (ins[0][..., 0, :] ^ ins[0][..., 1, :]) & ~ins[0][..., 2, :]
+    for inp in ins[1:]: any_unknown |= (inp[..., 0, :] ^ inp[..., 1, :]) & ~inp[..., 2, :]
+    any_one = ins[0][..., 0, :] & ins[0][..., 1, :] & ~ins[0][..., 2, :]
+    for inp in ins[1:]: any_one |= inp[..., 0, :] & inp[..., 1, :] & ~inp[..., 2, :]
+    for inp in ins:
+        out[..., 0, :] |= inp[..., 0, :] | any_unknown
+        out[..., 1, :] |= inp[..., 1, :] & (~any_unknown | any_one)
+        out[..., 2, :] |= inp[..., 2, :] & (~any_unknown | any_one) & ~any_one
+    return out
+
+
+def bp4v_and(out, *ins):
+    out[...] = 0xff
+    any_unknown = ins[0][..., 0, :] ^ ins[0][..., 1, :]
+    for inp in ins[1:]: any_unknown |= inp[..., 0, :] ^ inp[..., 1, :]
+    any_zero = ~ins[0][..., 0, :] & ~ins[0][..., 1, :]
+    for inp in ins[1:]: any_zero |= ~inp[..., 0, :] & ~inp[..., 1, :]
+    for inp in ins:
+        out[..., 0, :] &= inp[..., 0, :] | (any_unknown & ~any_zero)
+        out[..., 1, :] &= inp[..., 1, :] & ~any_unknown
+    return out
+
+
+def bp8v_and(out, *ins):
     out[...] = 0xff
-    if md == 1:
-        for inp in ins: out[..., 0, :] &= inp[..., 0, :]
-    elif md == 2:
-        any_unknown = ins[0][..., 0, :] ^ ins[0][..., 1, :]
-        for inp in ins[1:]: any_unknown |= inp[..., 0, :] ^ inp[..., 1, :]
-        any_zero = ~ins[0][..., 0, :] & ~ins[0][..., 1, :]
-        for inp in ins[1:]: any_zero |= ~inp[..., 0, :] & ~inp[..., 1, :]
-        for inp in ins:
-            out[..., 0, :] &= inp[..., 0, :] | (any_unknown & ~any_zero)
-            out[..., 1, :] &= inp[..., 1, :] & ~any_unknown
-    else:
-        any_unknown = (ins[0][..., 0, :] ^ ins[0][..., 1, :]) & ~ins[0][..., 2, :]
-        for inp in ins[1:]: any_unknown |= (inp[..., 0, :] ^ inp[..., 1, :]) & ~inp[..., 2, :]
-        any_zero = ~ins[0][..., 0, :] & ~ins[0][..., 1, :] & ~ins[0][..., 2, :]
-        for inp in ins[1:]: any_zero |= ~inp[..., 0, :] & ~inp[..., 1, :] & ~inp[..., 2, :]
-        out[..., 2, :] = 0
-        for inp in ins:
-            out[..., 0, :] &= inp[..., 0, :] | (any_unknown & ~any_zero)
-            out[..., 1, :] &= inp[..., 1, :] & ~any_unknown
-            out[..., 2, :] |= inp[..., 2, :] & (~any_unknown | any_zero) & ~any_zero
-
-
-def bp_xor(out, *ins):
-    md = out.shape[-2]
-    for inp in ins: assert md == inp.shape[-2]
+    any_unknown = (ins[0][..., 0, :] ^ ins[0][..., 1, :]) & ~ins[0][..., 2, :]
+    for inp in ins[1:]: any_unknown |= (inp[..., 0, :] ^ inp[..., 1, :]) & ~inp[..., 2, :]
+    any_zero = ~ins[0][..., 0, :] & ~ins[0][..., 1, :] & ~ins[0][..., 2, :]
+    for inp in ins[1:]: any_zero |= ~inp[..., 0, :] & ~inp[..., 1, :] & ~inp[..., 2, :]
+    out[..., 2, :] = 0
+    for inp in ins:
+        out[..., 0, :] &= inp[..., 0, :] | (any_unknown & ~any_zero)
+        out[..., 1, :] &= inp[..., 1, :] & ~any_unknown
+        out[..., 2, :] |= inp[..., 2, :] & (~any_unknown | any_zero) & ~any_zero
+    return out
+
+
+def bp4v_xor(out, *ins):
     out[...] = 0
-    if md == 1:
-        for inp in ins: out[..., 0, :] ^= inp[..., 0, :]
-    elif md == 2:
-        any_unknown = ins[0][..., 0, :] ^ ins[0][..., 1, :]
-        for inp in ins[1:]: any_unknown |= inp[..., 0, :] ^ inp[..., 1, :]
-        for inp in ins: out[...] ^= inp
-        out[..., 0, :] |= any_unknown
-        out[..., 1, :] &= ~any_unknown
-    else:
-        any_unknown = (ins[0][..., 0, :] ^ ins[0][..., 1, :]) & ~ins[0][..., 2, :]
-        for inp in ins[1:]: any_unknown |= (inp[..., 0, :] ^ inp[..., 1, :]) & ~inp[..., 2, :]
-        for inp in ins:
-            out[..., 0, :] ^= inp[..., 0, :]
-            out[..., 1, :] ^= inp[..., 1, :]
-            out[..., 2, :] |= inp[..., 2, :]
-        out[..., 0, :] |= any_unknown
-        out[..., 1, :] &= ~any_unknown
-        out[..., 2, :] &= ~any_unknown
+    any_unknown = ins[0][..., 0, :] ^ ins[0][..., 1, :]
+    for inp in ins[1:]: any_unknown |= inp[..., 0, :] ^ inp[..., 1, :]
+    for inp in ins:
+        out[..., 0, :] ^= inp[..., 0, :]
+        out[..., 1, :] ^= inp[..., 1, :]
+    out[..., 0, :] |= any_unknown
+    out[..., 1, :] &= ~any_unknown
+    return out
+
+
+def bp8v_xor(out, *ins):
+    out[...] = 0
+    any_unknown = (ins[0][..., 0, :] ^ ins[0][..., 1, :]) & ~ins[0][..., 2, :]
+    for inp in ins[1:]: any_unknown |= (inp[..., 0, :] ^ inp[..., 1, :]) & ~inp[..., 2, :]
+    for inp in ins:
+        out[..., 0, :] ^= inp[..., 0, :]
+        out[..., 1, :] ^= inp[..., 1, :]
+        out[..., 2, :] |= inp[..., 2, :]
+    out[..., 0, :] |= any_unknown
+    out[..., 1, :] &= ~any_unknown
+    out[..., 2, :] &= ~any_unknown
+    return out
+
+
+def bp8v_latch(out, d, t, q_prev):
+    any_unknown = (t[..., 0, :] ^ t[..., 1, :]) & ~t[..., 2, :]
+    any_unknown |= ((d[..., 0, :] ^ d[..., 1, :]) & ~d[..., 2, :]) & (t[..., 0, :] | t[..., 1, :] | t[..., 2, :])
+    out[..., 1, :] = (d[..., 1, :] & t[..., 1, :]) | (q_prev[..., 0, :] & ~t[..., 1, :])
+    out[..., 0, :] = (d[..., 0, :] & t[..., 0, :]) | (out[..., 1, :] & ~t[..., 0, :])
+    out[..., 2, :] = out[..., 1, :] ^ out[..., 0, :]
+    out[..., 0, :] |= any_unknown
+    out[..., 1, :] &= ~any_unknown
+    out[..., 2, :] &= ~any_unknown
+    return out
+
+
+_bit_in_lut = np.array([2 ** x for x in range(7, -1, -1)], dtype='uint8')
+
+
+@numba.njit
+def bit_in(a, pos):
+    return a[pos >> 3] & _bit_in_lut[pos & 7]
+
+
+def unpackbits(a : np.ndarray):
+    """Unpacks the bits of given ndarray ``a``.
+
+    Similar to ``np.unpackbits``, but accepts any dtype, preserves the shape of ``a`` and
+    adds a new last axis with the bits of each item. Bits are in 'little'-order, i.e.,
+    a[...,0] is the least significant bit of each item.
+    """
+    return np.unpackbits(a.view(np.uint8), bitorder='little').reshape(*a.shape, 8*a.itemsize)
+
+
+def packbits(a, dtype=np.uint8):
+    """Packs the values of a boolean-valued array ``a`` along its last axis into bits.
+
+    Similar to ``np.packbits``, but returns an array of given dtype and the shape of ``a`` with the last axis removed.
+    The last axis of `a` is truncated or padded according to the bit-width of the given dtype.
+    Signed integer datatypes are padded with the most significant bit, all others are padded with `0`.
+    """
+    dtype = np.dtype(dtype)
+    bits = 8 * dtype.itemsize
+    a = a[...,:bits]
+    if a.shape[-1] < bits:
+        p = [(0,0)]*(len(a.shape)-1) + [(0, bits-a.shape[-1])]
+        a = np.pad(a, p, 'edge') if dtype.name[0] == 'i' else np.pad(a, p, 'constant', constant_values=0)
+    return np.packbits(a, bitorder='little').view(dtype).reshape(a.shape[:-1])
```

## kyupy/logic_sim.py

```diff
@@ -1,195 +1,335 @@
 """A high-throughput combinational logic simulator.
 
 The class :py:class:`~kyupy.logic_sim.LogicSim` performs parallel simulations of the combinational part of a circuit.
-The logic operations are performed bit-parallel on packed numpy arrays.
+The logic operations are performed bit-parallel on packed numpy arrays (see bit-parallel (bp) array description in :py:mod:`~kyupy.logic`).
 Simple sequential circuits can be simulated by repeated assignments and propagations.
 However, this simulator ignores the clock network and simply assumes that all state-elements are clocked all the time.
 """
 
 import math
 
 import numpy as np
 
-from . import logic, hr_bytes
+from . import numba, logic, hr_bytes, sim
+from .circuit import Circuit
 
-
-class LogicSim:
+class LogicSim(sim.SimOps):
     """A bit-parallel naïve combinational simulator for 2-, 4-, or 8-valued logic.
 
     :param circuit: The circuit to simulate.
-    :type circuit: :py:class:`~kyupy.circuit.Circuit`
     :param sims: The number of parallel logic simulations to perform.
-    :type sims: int
     :param m: The arity of the logic, must be 2, 4, or 8.
-    :type m: int
+    :param c_reuse: If True, intermediate signal values may get overwritten when not needed anymore to save memory.
+    :param strip_forks: If True, forks are not included in the simulation model to save memory and simulation time.
     """
-    def __init__(self, circuit, sims=8, m=8):
+    def __init__(self, circuit: Circuit, sims: int = 8, m: int = 8, c_reuse: bool = False, strip_forks: bool = False):
         assert m in [2, 4, 8]
+        super().__init__(circuit, c_reuse=c_reuse, strip_forks=strip_forks)
         self.m = m
-        mdim = math.ceil(math.log2(m))
-        self.circuit = circuit
+        self.mdim = math.ceil(math.log2(m))
         self.sims = sims
         nbytes = (sims - 1) // 8 + 1
-        self.interface = list(circuit.interface) + [n for n in circuit.nodes if 'dff' in n.kind.lower()]
-        self.width = len(self.interface)
-        """The number of bits in the circuit state (number of ports + number of state-elements)."""
-        self.state = np.zeros((len(circuit.lines), mdim, nbytes), dtype='uint8')
-        self.state_epoch = np.zeros(len(circuit.nodes), dtype='int8') - 1
-        self.tmp = np.zeros((5, mdim, nbytes), dtype='uint8')
-        self.zero = np.zeros((mdim, nbytes), dtype='uint8')
-        self.epoch = 0
-
-        known_fct = [(f[:-4], getattr(self, f)) for f in dir(self) if f.endswith('_fct')]
-        self.node_fct = []
-        for n in circuit.nodes:
-            t = n.kind.lower().replace('__fork__', 'fork')
-            t = t.replace('nbuff', 'fork')
-            t = t.replace('input', 'fork')
-            t = t.replace('output', 'fork')
-            t = t.replace('__const0__', 'const0')
-            t = t.replace('__const1__', 'const1')
-            t = t.replace('tieh', 'const1')
-            t = t.replace('ibuff', 'not')
-            t = t.replace('inv', 'not')
-
-            fcts = [f for n, f in known_fct if t.startswith(n)]
-            if len(fcts) < 1:
-                raise ValueError(f'Unknown node kind {n.kind}')
-            self.node_fct.append(fcts[0])
 
-    def __repr__(self):
-        return f'<LogicSim {self.circuit.name} sims={self.sims} m={self.m} state_mem={hr_bytes(self.state.nbytes)}>'
+        self.c = np.zeros((self.c_len, self.mdim, nbytes), dtype=np.uint8)
+        self.s = np.zeros((2, self.s_len, 3, nbytes), dtype=np.uint8)
+        """Logic values of the sequential elements (flip-flops) and ports.
 
-    def assign(self, stimuli):
-        """Assign stimuli to the primary inputs and state-elements (flip-flops).
+        It is a pair of arrays in bit-parallel (bp) storage format:
 
-        :param stimuli: The input data to assign. Must be in bit-parallel storage format and in a compatible shape.
-        :type stimuli: :py:class:`~kyupy.logic.BPArray`
-        :returns: The given stimuli object.
-        """
-        for node, stim in zip(self.interface, stimuli.data if hasattr(stimuli, 'data') else stimuli):
-            if len(node.outs) == 0: continue
-            outputs = [self.state[line] if line else self.tmp[3] for line in node.outs]
-            self.node_fct[node]([stim], outputs)
-            for line in node.outs:
-                if line is not None: self.state_epoch[line.reader] = self.epoch
-        for n in self.circuit.nodes:
-            if n.kind in ('__const1__', '__const0__'):
-                outputs = [self.state[line] if line else self.tmp[3] for line in n.outs]
-                self.node_fct[n]([], outputs)
-                for line in n.outs:
-                    if line is not None: self.state_epoch[line.reader] = self.epoch
-        return stimuli
-
-    def capture(self, responses):
-        """Capture the current values at the primary outputs and in the state-elements (flip-flops).
-
-        :param responses: A bit-parallel storage target for the responses in a compatible shape.
-        :type responses: :py:class:`~kyupy.logic.BPArray`
-        :returns: The given responses object.
-        """
-        for node, resp in zip(self.interface, responses.data if hasattr(responses, 'data') else responses):
-            if len(node.ins) > 0: resp[...] = self.state[node.ins[0]]
-        return responses
+        * ``s[0]`` Assigned values. Simulator will read (P)PI value from here.
+        * ``s[1]`` Result values. Simulator will write (P)PO values here.
 
-    def propagate(self, inject_cb=None):
-        """Propagate the input values towards the outputs (Perform all logic operations in topological order).
+        Access this array to assign new values to the (P)PIs or read values from the (P)POs.
+        """
+        self.s[:,:,1,:] = 255  # unassigned
 
-        If the circuit is sequential (it contains flip-flops), one call simulates one clock cycle.
-        Multiple clock cycles are simulated by a assign-propagate-capture loop:
+    def __repr__(self):
+        return f'{{name: "{self.circuit.name}", sims: {self.sims}, m: {self.m}, c_bytes: {self.c.nbytes}}}'
+
+    def s_to_c(self):
+        """Copies the values from ``s[0]`` the inputs of the combinational portion.
+        """
+        self.c[self.pippi_c_locs] = self.s[0, self.pippi_s_locs, :self.mdim]
 
-        .. code-block:: python
+    def c_prop(self, inject_cb=None):
+        """Propagate the input values through the combinational circuit towards the outputs.
 
-           # initial state in state_bp
-           for cycle in range(10):  # simulate 10 clock cycles
-               sim.assign(state_bp)
-               sim.propagate()
-               sim.capture(state_bp)
+        Performs all logic operations in topological order.
+        If the circuit is sequential (it contains flip-flops), one call simulates one clock cycle.
 
         :param inject_cb: A callback function for manipulating intermediate signal values.
-            This function is called with a line index and its new logic values (in bit-parallel format) after
+            This function is called with a line and its new logic values (in bit-parallel format) after
             evaluation of a node. The callback may manipulate the given values in-place, the simulation
             resumes with the manipulated values after the callback returns.
-        :type inject_cb: ``f(int, ndarray)``
+        :type inject_cb: ``f(Line, ndarray)``
+        """
+        t0 = self.c_locs[self.tmp_idx]
+        t1 = self.c_locs[self.tmp2_idx]
+        if self.m == 2:
+            if inject_cb is None:
+                _prop_cpu(self.ops, self.c_locs, self.c)
+            else:
+                for op, o0, i0, i1, i2, i3 in self.ops[:,:6]:
+                    o0, i0, i1, i2, i3 = [self.c_locs[x] for x in (o0, i0, i1, i2, i3)]
+                    if op == sim.BUF1: self.c[o0]=self.c[i0]
+                    elif op == sim.INV1: self.c[o0] = ~self.c[i0]
+                    elif op == sim.AND2: self.c[o0] = self.c[i0] & self.c[i1]
+                    elif op == sim.AND3: self.c[o0] = self.c[i0] & self.c[i1] & self.c[i2]
+                    elif op == sim.AND4: self.c[o0] = self.c[i0] & self.c[i1] & self.c[i2] & self.c[i3]
+                    elif op == sim.NAND2: self.c[o0] = ~(self.c[i0] & self.c[i1])
+                    elif op == sim.NAND3: self.c[o0] = ~(self.c[i0] & self.c[i1] & self.c[i2])
+                    elif op == sim.NAND4: self.c[o0] = ~(self.c[i0] & self.c[i1] & self.c[i2] & self.c[i3])
+                    elif op == sim.OR2: self.c[o0] = self.c[i0] | self.c[i1]
+                    elif op == sim.OR3: self.c[o0] = self.c[i0] | self.c[i1] | self.c[i2]
+                    elif op == sim.OR4: self.c[o0] = self.c[i0] | self.c[i1] | self.c[i2] | self.c[i3]
+                    elif op == sim.NOR2: self.c[o0] = ~(self.c[i0] | self.c[i1])
+                    elif op == sim.NOR3: self.c[o0] = ~(self.c[i0] | self.c[i1] | self.c[i2])
+                    elif op == sim.NOR4: self.c[o0] = ~(self.c[i0] | self.c[i1] | self.c[i2] | self.c[i3])
+                    elif op == sim.XOR2: self.c[o0] = self.c[i0] ^ self.c[i1]
+                    elif op == sim.XOR3: self.c[o0] = self.c[i0] ^ self.c[i1] ^ self.c[i2]
+                    elif op == sim.XOR4: self.c[o0] = self.c[i0] ^ self.c[i1] ^ self.c[i2] ^ self.c[i3]
+                    elif op == sim.XNOR2: self.c[o0] = ~(self.c[i0] ^ self.c[i1])
+                    elif op == sim.XNOR3: self.c[o0] = ~(self.c[i0] ^ self.c[i1] ^ self.c[i2])
+                    elif op == sim.XNOR4: self.c[o0] = ~(self.c[i0] ^ self.c[i1] ^ self.c[i2] ^ self.c[i3])
+                    elif op == sim.AO21: self.c[o0] = (self.c[i0] & self.c[i1]) | self.c[i2]
+                    elif op == sim.AOI21: self.c[o0] = ~((self.c[i0] & self.c[i1]) | self.c[i2])
+                    elif op == sim.OA21: self.c[o0] = (self.c[i0] | self.c[i1]) & self.c[i2]
+                    elif op == sim.OAI21: self.c[o0] = ~((self.c[i0] | self.c[i1]) & self.c[i2])
+                    elif op == sim.AO22: self.c[o0] = (self.c[i0] & self.c[i1]) | (self.c[i2] & self.c[i3])
+                    elif op == sim.AOI22: self.c[o0] = ~((self.c[i0] & self.c[i1]) | (self.c[i2] & self.c[i3]))
+                    elif op == sim.OA22: self.c[o0] = (self.c[i0] | self.c[i1]) & (self.c[i2] | self.c[i3])
+                    elif op == sim.OAI22: self.c[o0] = ~((self.c[i0] | self.c[i1]) & (self.c[i2] | self.c[i3]))
+                    elif op == sim.AO211: self.c[o0] =  (self.c[i0] & self.c[i1]) | self.c[i2] | self.c[i3]
+                    elif op == sim.AOI211:self.c[o0] = ~((self.c[i0] & self.c[i1]) | self.c[i2] | self.c[i3])
+                    elif op == sim.OA211: self.c[o0] =  (self.c[i0] | self.c[i1]) & self.c[i2] & self.c[i3]
+                    elif op == sim.OAI211:self.c[o0] = ~((self.c[i0] | self.c[i1]) & self.c[i2] & self.c[i3])
+                    elif op == sim.MUX21: self.c[o0] = (self.c[i0] & ~self.c[i2]) | (self.c[i1] & self.c[i2])
+                    else: print(f'unknown op {op}')
+                    inject_cb(o0, self.s[o0])
+        elif self.m == 4:
+            for op, o0, i0, i1, i2, i3 in self.ops[:,:6]:
+                o0, i0, i1, i2, i3 = [self.c_locs[x] for x in (o0, i0, i1, i2, i3)]
+                if op == sim.BUF1: self.c[o0]=self.c[i0]
+                elif op == sim.INV1: logic.bp4v_not(self.c[o0], self.c[i0])
+                elif op == sim.AND2: logic.bp4v_and(self.c[o0], self.c[i0], self.c[i1])
+                elif op == sim.AND3: logic.bp4v_and(self.c[o0], self.c[i0], self.c[i1], self.c[i2])
+                elif op == sim.AND4: logic.bp4v_and(self.c[o0], self.c[i0], self.c[i1], self.c[i2], self.c[i3])
+                elif op == sim.NAND2: logic.bp4v_and(self.c[o0], self.c[i0], self.c[i1]); logic.bp4v_not(self.c[o0], self.c[o0])
+                elif op == sim.NAND3: logic.bp4v_and(self.c[o0], self.c[i0], self.c[i1], self.c[i2]); logic.bp4v_not(self.c[o0], self.c[o0])
+                elif op == sim.NAND4: logic.bp4v_and(self.c[o0], self.c[i0], self.c[i1], self.c[i2], self.c[i3]); logic.bp4v_not(self.c[o0], self.c[o0])
+                elif op == sim.OR2: logic.bp4v_or(self.c[o0], self.c[i0], self.c[i1])
+                elif op == sim.OR3: logic.bp4v_or(self.c[o0], self.c[i0], self.c[i1], self.c[i2])
+                elif op == sim.OR4: logic.bp4v_or(self.c[o0], self.c[i0], self.c[i1], self.c[i2], self.c[i3])
+                elif op == sim.NOR2: logic.bp4v_or(self.c[o0], self.c[i0], self.c[i1]); logic.bp4v_not(self.c[o0], self.c[o0])
+                elif op == sim.NOR3: logic.bp4v_or(self.c[o0], self.c[i0], self.c[i1], self.c[i2]); logic.bp4v_not(self.c[o0], self.c[o0])
+                elif op == sim.NOR4: logic.bp4v_or(self.c[o0], self.c[i0], self.c[i1], self.c[i2], self.c[i3]); logic.bp4v_not(self.c[o0], self.c[o0])
+                elif op == sim.XOR2: logic.bp4v_xor(self.c[o0], self.c[i0], self.c[i1])
+                elif op == sim.XOR3: logic.bp4v_xor(self.c[o0], self.c[i0], self.c[i1], self.c[i2])
+                elif op == sim.XOR4: logic.bp4v_xor(self.c[o0], self.c[i0], self.c[i1], self.c[i2], self.c[i3])
+                elif op == sim.XNOR2: logic.bp4v_xor(self.c[o0], self.c[i0], self.c[i1]); logic.bp4v_not(self.c[o0], self.c[o0])
+                elif op == sim.XNOR3: logic.bp4v_xor(self.c[o0], self.c[i0], self.c[i1], self.c[i2]); logic.bp4v_not(self.c[o0], self.c[o0])
+                elif op == sim.XNOR4: logic.bp4v_xor(self.c[o0], self.c[i0], self.c[i1], self.c[i2], self.c[i3]); logic.bp4v_not(self.c[o0], self.c[o0])
+                elif op == sim.AO21:
+                    logic.bp4v_and(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp4v_or(self.c[o0], self.c[t0], self.c[i2])
+                elif op == sim.AOI21:
+                    logic.bp4v_and(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp4v_or(self.c[o0], self.c[t0], self.c[i2])
+                    logic.bp4v_not(self.c[o0], self.c[o0])
+                elif op == sim.OA21:
+                    logic.bp4v_or(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp4v_and(self.c[o0], self.c[t0], self.c[i2])
+                elif op == sim.OAI21:
+                    logic.bp4v_or(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp4v_and(self.c[o0], self.c[t0], self.c[i2])
+                    logic.bp4v_not(self.c[o0], self.c[o0])
+                elif op == sim.AO22:
+                    logic.bp4v_and(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp4v_and(self.c[t1], self.c[i2], self.c[i3])
+                    logic.bp4v_or(self.c[o0], self.c[t0], self.c[t1])
+                elif op == sim.AOI22:
+                    logic.bp4v_and(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp4v_and(self.c[t1], self.c[i2], self.c[i3])
+                    logic.bp4v_or(self.c[o0], self.c[t0], self.c[t1])
+                    logic.bp4v_not(self.c[o0], self.c[o0])
+                elif op == sim.OA22:
+                    logic.bp4v_or(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp4v_or(self.c[t1], self.c[i2], self.c[i3])
+                    logic.bp4v_and(self.c[o0], self.c[t0], self.c[t1])
+                elif op == sim.OAI22:
+                    logic.bp4v_or(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp4v_or(self.c[t1], self.c[i2], self.c[i3])
+                    logic.bp4v_and(self.c[o0], self.c[t0], self.c[t1])
+                    logic.bp4v_not(self.c[o0], self.c[o0])
+                elif op == sim.AO211:
+                    logic.bp4v_and(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp4v_or(self.c[o0], self.c[t0], self.c[i2], self.c[i3])
+                elif op == sim.AOI211:
+                    logic.bp4v_and(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp4v_or(self.c[o0], self.c[t0], self.c[i2], self.c[i3])
+                    logic.bp4v_not(self.c[o0], self.c[o0])
+                elif op == sim.OA211:
+                    logic.bp4v_or(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp4v_and(self.c[o0], self.c[t0], self.c[i2], self.c[i3])
+                elif op == sim.OAI211:
+                    logic.bp4v_or(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp4v_and(self.c[o0], self.c[t0], self.c[i2], self.c[i3])
+                    logic.bp4v_not(self.c[o0], self.c[o0])
+                elif op == sim.MUX21:
+                    logic.bp4v_not(self.c[t1], self.c[i2])
+                    logic.bp4v_and(self.c[t0], self.c[i0], self.c[t1])
+                    logic.bp4v_and(self.c[t1], self.c[i1], self.c[i2])
+                    logic.bp4v_or(self.c[o0], self.c[t0], self.c[t1])
+                else: print(f'unknown op {op}')
+        else:
+            for op, o0, i0, i1, i2, i3 in self.ops[:,:6]:
+                o0, i0, i1, i2, i3 = [self.c_locs[x] for x in (o0, i0, i1, i2, i3)]
+                if op == sim.BUF1: self.c[o0]=self.c[i0]
+                elif op == sim.INV1: logic.bp8v_not(self.c[o0], self.c[i0])
+                elif op == sim.AND2: logic.bp8v_and(self.c[o0], self.c[i0], self.c[i1])
+                elif op == sim.AND3: logic.bp8v_and(self.c[o0], self.c[i0], self.c[i1], self.c[i2])
+                elif op == sim.AND4: logic.bp8v_and(self.c[o0], self.c[i0], self.c[i1], self.c[i2], self.c[i3])
+                elif op == sim.NAND2: logic.bp8v_and(self.c[o0], self.c[i0], self.c[i1]); logic.bp8v_not(self.c[o0], self.c[o0])
+                elif op == sim.NAND3: logic.bp8v_and(self.c[o0], self.c[i0], self.c[i1], self.c[i2]); logic.bp8v_not(self.c[o0], self.c[o0])
+                elif op == sim.NAND4: logic.bp8v_and(self.c[o0], self.c[i0], self.c[i1], self.c[i2], self.c[i3]); logic.bp8v_not(self.c[o0], self.c[o0])
+                elif op == sim.OR2: logic.bp8v_or(self.c[o0], self.c[i0], self.c[i1])
+                elif op == sim.OR3: logic.bp8v_or(self.c[o0], self.c[i0], self.c[i1], self.c[i2])
+                elif op == sim.OR4: logic.bp8v_or(self.c[o0], self.c[i0], self.c[i1], self.c[i2], self.c[i3])
+                elif op == sim.NOR2: logic.bp8v_or(self.c[o0], self.c[i0], self.c[i1]); logic.bp8v_not(self.c[o0], self.c[o0])
+                elif op == sim.NOR3: logic.bp8v_or(self.c[o0], self.c[i0], self.c[i1], self.c[i2]); logic.bp8v_not(self.c[o0], self.c[o0])
+                elif op == sim.NOR4: logic.bp8v_or(self.c[o0], self.c[i0], self.c[i1], self.c[i2], self.c[i3]); logic.bp8v_not(self.c[o0], self.c[o0])
+                elif op == sim.XOR2: logic.bp8v_xor(self.c[o0], self.c[i0], self.c[i1])
+                elif op == sim.XOR3: logic.bp8v_xor(self.c[o0], self.c[i0], self.c[i1], self.c[i2])
+                elif op == sim.XOR4: logic.bp8v_xor(self.c[o0], self.c[i0], self.c[i1], self.c[i2], self.c[i3])
+                elif op == sim.XNOR2: logic.bp8v_xor(self.c[o0], self.c[i0], self.c[i1]); logic.bp8v_not(self.c[o0], self.c[o0])
+                elif op == sim.XNOR3: logic.bp8v_xor(self.c[o0], self.c[i0], self.c[i1], self.c[i2]); logic.bp8v_not(self.c[o0], self.c[o0])
+                elif op == sim.XNOR4: logic.bp8v_xor(self.c[o0], self.c[i0], self.c[i1], self.c[i2], self.c[i3]); logic.bp8v_not(self.c[o0], self.c[o0])
+                elif op == sim.AO21:
+                    logic.bp8v_and(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp8v_or(self.c[o0], self.c[t0], self.c[i2])
+                elif op == sim.AOI21:
+                    logic.bp8v_and(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp8v_or(self.c[o0], self.c[t0], self.c[i2])
+                    logic.bp8v_not(self.c[o0], self.c[o0])
+                elif op == sim.OA21:
+                    logic.bp8v_or(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp8v_and(self.c[o0], self.c[t0], self.c[i2])
+                elif op == sim.OAI21:
+                    logic.bp8v_or(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp8v_and(self.c[o0], self.c[t0], self.c[i2])
+                    logic.bp8v_not(self.c[o0], self.c[o0])
+                elif op == sim.AO22:
+                    logic.bp8v_and(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp8v_and(self.c[t1], self.c[i2], self.c[i3])
+                    logic.bp8v_or(self.c[o0], self.c[t0], self.c[t1])
+                elif op == sim.AOI22:
+                    logic.bp8v_and(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp8v_and(self.c[t1], self.c[i2], self.c[i3])
+                    logic.bp8v_or(self.c[o0], self.c[t0], self.c[t1])
+                    logic.bp8v_not(self.c[o0], self.c[o0])
+                elif op == sim.OA22:
+                    logic.bp8v_or(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp8v_or(self.c[t1], self.c[i2], self.c[i3])
+                    logic.bp8v_and(self.c[o0], self.c[t0], self.c[t1])
+                elif op == sim.OAI22:
+                    logic.bp8v_or(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp8v_or(self.c[t1], self.c[i2], self.c[i3])
+                    logic.bp8v_and(self.c[o0], self.c[t0], self.c[t1])
+                    logic.bp8v_not(self.c[o0], self.c[o0])
+                elif op == sim.AO211:
+                    logic.bp8v_and(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp8v_or(self.c[o0], self.c[t0], self.c[i2], self.c[i3])
+                elif op == sim.AOI211:
+                    logic.bp8v_and(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp8v_or(self.c[o0], self.c[t0], self.c[i2], self.c[i3])
+                    logic.bp8v_not(self.c[o0], self.c[o0])
+                elif op == sim.OA211:
+                    logic.bp8v_or(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp8v_and(self.c[o0], self.c[t0], self.c[i2], self.c[i3])
+                elif op == sim.OAI211:
+                    logic.bp8v_or(self.c[t0], self.c[i0], self.c[i1])
+                    logic.bp8v_and(self.c[o0], self.c[t0], self.c[i2], self.c[i3])
+                    logic.bp8v_not(self.c[o0], self.c[o0])
+                elif op == sim.MUX21:
+                    logic.bp8v_not(self.c[t1], self.c[i2])
+                    logic.bp8v_and(self.c[t0], self.c[i0], self.c[t1])
+                    logic.bp8v_and(self.c[t1], self.c[i1], self.c[i2])
+                    logic.bp8v_or(self.c[o0], self.c[t0], self.c[t1])
+                else: print(f'unknown op {op}')
+                if inject_cb is not None: inject_cb(o0, self.s[o0])
+
+    def c_to_s(self):
+        """Copies (captures) the results of the combinational portion to ``s[1]``.
+        """
+        self.s[1, self.poppo_s_locs, :self.mdim] = self.c[self.poppo_c_locs]
+        if self.mdim == 1:
+            self.s[1, self.poppo_s_locs, 1:2] = self.c[self.poppo_c_locs]
+
+    def s_ppo_to_ppi(self):
+        """Constructs a new assignment based on the current data in ``s``.
+
+        Use this function for simulating consecutive clock cycles.
+
+        For 2-valued or 4-valued simulations, all valued from PPOs (in ``s[1]``) and copied to the PPIs (in ``s[0]``).
+        For 8-valued simulations, PPI transitions are constructed from the final values of the assignment (in ``s[0]``) and the
+        final values of the results (in ``s[1]``).
+        """
+        # TODO: handle latches correctly
+        if self.mdim < 3:
+            self.s[0, self.ppio_s_locs] = self.s[1, self.ppio_s_locs]
+        else:
+            self.s[0, self.ppio_s_locs, 1] = self.s[0, self.ppio_s_locs, 0]  # initial value is previously assigned final value
+            self.s[0, self.ppio_s_locs, 0] = self.s[1, self.ppio_s_locs, 0]  # final value is newly captured final value
+            self.s[0, self.ppio_s_locs, 2] = self.s[0, self.ppio_s_locs, 0] ^ self.s[0, self.ppio_s_locs, 1]  # TODO: not correct for X, -
+
+    def cycle(self, cycles: int = 1, inject_cb=None):
+        """Repeatedly assigns a state, propagates it, captures the new state, and transfers PPOs to PPIs.
+
+        :param cycles: The number of cycles to simulate.
+        :param inject_cb: A callback function for manipulating intermediate signal values. See :py:func:`c_prop`.
         """
-        for node in self.circuit.topological_order():
-            if self.state_epoch[node] != self.epoch: continue
-            inputs = [self.state[line] if line else self.zero for line in node.ins]
-            outputs = [self.state[line] if line else self.tmp[3] for line in node.outs]
-            # print('sim', node)
-            self.node_fct[node](inputs, outputs)
-            for line in node.outs:
-                if inject_cb is not None: inject_cb(line, self.state[line])
-                self.state_epoch[line.reader] = self.epoch
-        self.epoch = (self.epoch + 1) % 128
-
-    def cycle(self, state, inject_cb=None):
-        """Assigns the given state, propagates it and captures the new state.
-
-        :param state: A bit-parallel array in a compatible shape holding the current circuit state.
-            The contained data is assigned to the PI and PPI and overwritten by data at the PO and PPO after
-            propagation.
-        :type state: :py:class:`~kyupy.logic.BPArray`
-        :param inject_cb: A callback function for manipulating intermediate signal values. See :py:func:`propagate`.
-        :returns: The given state object.
-        """
-        self.assign(state)
-        self.propagate(inject_cb)
-        return self.capture(state)
-
-    @staticmethod
-    def fork_fct(inputs, outputs):
-        for o in outputs: o[...] = inputs[0]
-
-    @staticmethod
-    def const0_fct(_, outputs):
-        for o in outputs: o[...] = 0
-
-    @staticmethod
-    def const1_fct(_, outputs):
-        for o in outputs:
-            o[...] = 0
-            logic.bp_not(o, o)
-
-    @staticmethod
-    def not_fct(inputs, outputs):
-        logic.bp_not(outputs[0], inputs[0])
-
-    @staticmethod
-    def and_fct(inputs, outputs):
-        logic.bp_and(outputs[0], *inputs)
-
-    @staticmethod
-    def or_fct(inputs, outputs):
-        logic.bp_or(outputs[0], *inputs)
-
-    @staticmethod
-    def xor_fct(inputs, outputs):
-        logic.bp_xor(outputs[0], *inputs)
-
-    @staticmethod
-    def sdff_fct(inputs, outputs):
-        logic.bp_buf(outputs[0], inputs[0])
-        if len(outputs) > 1:
-            logic.bp_not(outputs[1], inputs[0])
-
-    @staticmethod
-    def dff_fct(inputs, outputs):
-        logic.bp_buf(outputs[0], inputs[0])
-        if len(outputs) > 1:
-            logic.bp_not(outputs[1], inputs[0])
-
-    @staticmethod
-    def nand_fct(inputs, outputs):
-        logic.bp_and(outputs[0], *inputs)
-        logic.bp_not(outputs[0], outputs[0])
-
-    @staticmethod
-    def nor_fct(inputs, outputs):
-        logic.bp_or(outputs[0], *inputs)
-        logic.bp_not(outputs[0], outputs[0])
-
-    @staticmethod
-    def xnor_fct(inputs, outputs):
-        logic.bp_xor(outputs[0], *inputs)
-        logic.bp_not(outputs[0], outputs[0])
+        for _ in range(cycles):
+            self.s_to_c()
+            self.c_prop(inject_cb)
+            self.c_to_s()
+            self.s_ppo_to_ppi()
+
+
+@numba.njit
+def _prop_cpu(ops, c_locs, c):
+    for op, o0, i0, i1, i2, i3 in ops[:,:6]:
+        o0, i0, i1, i2, i3 = [c_locs[x] for x in (o0, i0, i1, i2, i3)]
+        if op == sim.BUF1: c[o0]=c[i0]
+        elif op == sim.INV1: c[o0] = ~c[i0]
+        elif op == sim.AND2: c[o0] = c[i0] & c[i1]
+        elif op == sim.AND3: c[o0] = c[i0] & c[i1] & c[i2]
+        elif op == sim.AND4: c[o0] = c[i0] & c[i1] & c[i2] & c[i3]
+        elif op == sim.NAND2: c[o0] = ~(c[i0] & c[i1])
+        elif op == sim.NAND3: c[o0] = ~(c[i0] & c[i1] & c[i2])
+        elif op == sim.NAND4: c[o0] = ~(c[i0] & c[i1] & c[i2] & c[i3])
+        elif op == sim.OR2: c[o0] = c[i0] | c[i1]
+        elif op == sim.OR3: c[o0] = c[i0] | c[i1] | c[i2]
+        elif op == sim.OR4: c[o0] = c[i0] | c[i1] | c[i2] | c[i3]
+        elif op == sim.NOR2: c[o0] = ~(c[i0] | c[i1])
+        elif op == sim.NOR3: c[o0] = ~(c[i0] | c[i1] | c[i2])
+        elif op == sim.NOR4: c[o0] = ~(c[i0] | c[i1] | c[i2] | c[i3])
+        elif op == sim.XOR2: c[o0] = c[i0] ^ c[i1]
+        elif op == sim.XOR3: c[o0] = c[i0] ^ c[i1] ^ c[i2]
+        elif op == sim.XOR4: c[o0] = c[i0] ^ c[i1] ^ c[i2] ^ c[i3]
+        elif op == sim.XNOR2: c[o0] = ~(c[i0] ^ c[i1])
+        elif op == sim.XNOR3: c[o0] = ~(c[i0] ^ c[i1] ^ c[i2])
+        elif op == sim.XNOR4: c[o0] = ~(c[i0] ^ c[i1] ^ c[i2] ^ c[i3])
+        elif op == sim.AO21: c[o0] = (c[i0] & c[i1]) | c[i2]
+        elif op == sim.OA21: c[o0] = (c[i0] | c[i1]) & c[i2]
+        elif op == sim.AO22: c[o0] = (c[i0] & c[i1]) | (c[i2] & c[i3])
+        elif op == sim.OA22: c[o0] = (c[i0] | c[i1]) & (c[i2] | c[i3])
+        elif op == sim.AOI21: c[o0] = ~((c[i0] & c[i1]) | c[i2])
+        elif op == sim.OAI21: c[o0] = ~((c[i0] | c[i1]) & c[i2])
+        elif op == sim.AOI22: c[o0] = ~((c[i0] & c[i1]) | (c[i2] & c[i3]))
+        elif op == sim.OAI22: c[o0] = ~((c[i0] | c[i1]) & (c[i2] | c[i3]))
+        elif op == sim.AO211: c[o0] = (c[i0] & c[i1]) | c[i2] | c[i3]
+        elif op == sim.OA211: c[o0] = (c[i0] | c[i1]) & c[i2] & c[i3]
+        elif op == sim.AOI211: c[o0] = ~((c[i0] & c[i1]) | c[i2] | c[i3])
+        elif op == sim.OAI211: c[o0] = ~((c[i0] | c[i1]) & c[i2] & c[i3])
+        elif op == sim.MUX21: c[o0] = (c[i0] & ~c[i2]) | (c[i1] & c[i2])
+        else: print(f'unknown op {op}')
```

## kyupy/sdf.py

```diff
@@ -1,171 +1,142 @@
 """A simple and incomplete parser for the Standard Delay Format (SDF).
 
-The main purpose of this parser is to extract pin-to-pin delay and interconnect delay information from SDF files.
-Sophisticated timing specifications (timing checks, conditional delays, etc.) are currently not supported.
-
-The functions :py:func:`load` and :py:func:`read` return an intermediate representation (:class:`DelayFile` object).
-Call :py:func:`DelayFile.annotation` to match the intermediate representation to a given circuit.
+This parser extracts pin-to-pin delay and interconnect delay information from SDF files.
+Sophisticated timing specifications (timing checks, conditional delays, etc.) are ignored.
 
+The functions :py:func:`parse` and :py:func:`load` return an intermediate representation (:class:`DelayFile` object).
+Call :py:func:`DelayFile.iopaths` and :py:func:`DelayFile.interconnects` to generate delay information for a given circuit.
 """
 
 from collections import namedtuple
+import re
 
 import numpy as np
 from lark import Lark, Transformer
 
 from . import log, readtext
+from .circuit import Circuit
 from .techlib import TechLib
 
 
 Interconnect = namedtuple('Interconnect', ['orig', 'dest', 'r', 'f'])
 IOPath = namedtuple('IOPath', ['ipin', 'opin', 'r', 'f'])
 
 
 class DelayFile:
     """An intermediate representation of an SDF file.
     """
     def __init__(self, name, cells):
         self.name = name
-        if None in cells:
-            self.interconnects = cells[None]
-        else:
-            self.interconnects = None
+        self._interconnects = cells.get(None, None)
         self.cells = dict((n, l) for n, l in cells.items() if n)
 
     def __repr__(self):
         return '\n'.join(f'{n}: {l}' for n, l in self.cells.items()) + '\n' + \
-               '\n'.join(str(i) for i in self.interconnects)
+               '\n'.join(str(i) for i in self._interconnects)
+
+    def iopaths(self, circuit:Circuit, tlib:TechLib):
+        """Constructs an ndarray containing all IOPATH delays.
+
+        All IOPATH delays for a node ``n`` are annotated to the line connected to the input pin specified in the IOPATH.
 
-    def annotation(self, circuit, tlib=TechLib(), dataset=1, interconnect=True, ffdelays=True):
-        """Constructs an 3-dimensional ndarray with timing data for each line in ``circuit``.
+        Limited support of SDF spec:
 
-        An IOPATH delay for a node is annotated to the line connected to the input pin specified in the IOPATH.
+        * Only ABSOLUTE delay values are supported.
+        * Only two delvals per delval_list is supported. First is rising/posedge, second is falling/negedge
+          transition at the output of the IOPATH (SDF spec, pp. 3-17).
+        * PATHPULSE declarations are ignored.
 
-        Currently, only ABSOLUTE IOPATH and INTERCONNECT delays are supported.
-        Pulse rejection limits are derived from absolute delays, explicit declarations (PATHPULSE etc.) are ignored.
-
-        :param circuit: The circuit to annotate. Names from the STIL file are matched to the node names.
-        :type circuit: :class:`~kyupy.circuit.Circuit`
-        :param tlib: A technology library object that provides pin name mappings.
-        :type tlib: :py:class:`~kyupy.techlib.TechLib`
-        :param dataset: SDFs store multiple values for each delay (e.g. minimum, typical, maximum).
-            An integer selects the dataset to use (default is 1 for 'typical').
-            If a tuple is given, the annotator will calculate the average of multiple datasets.
-        :type dataset: ``int`` or ``tuple``
-        :param interconnect: Whether or not to include the delays of interconnects in the annotation.
-            To properly annotate interconnect delays, the circuit model has to include a '__fork__' node on
-            every signal and every fanout-branch. The Verilog parser aids in this by setting the parameter
-            `branchforks=True` in :py:func:`kyupy.verilog.parse`.
-        :type interconnect: ``bool``
-        :param ffdelays: Whether or not to include the delays of flip-flops in the annotation.
-        :type ffdelays: ``bool``
-        :return: A 3-dimensional ndarray with timing data.
-
-            * Axis 0: line index.
-            * Axis 1: type of timing data: 0='delay', 1='pulse rejection limit'.
-            * Axis 2: The polarity of the output transition of the reading node: 0='rising', 1='falling'.
-
-            The polarity for pulse rejection is determined by the latter transition of the pulse.
-            E.g., ``timing[42, 1, 0]`` is the rejection limit of a negative pulse at the output
-            of the reader of line 42.
+        The axes convention of KyuPy's delay data arrays is as follows:
+
+        * Axis 0: dataset (usually 3 datasets per SDF-file)
+        * Axis 1: line index (e.g. ``n.ins[0]``, ``n.ins[1]``)
+        * Axis 2: polarity of the transition at the IOPATH-input (e.g. at ``n.ins[0]`` or ``n.ins[1]``), 0='rising/posedge', 1='falling/negedge'
+        * Axis 3: polarity of the transition at the IOPATH-output (at ``n.outs[0]``), 0='rising/posedge', 1='falling/negedge'
         """
-        def select_del(_delvals, idx):
-            if isinstance(dataset, tuple):
-                return sum(_delvals[idx][d] for d in dataset) / len(dataset)
-            return _delvals[idx][dataset]
-
-        def find_cell(name):
-            if name not in circuit.cells:
-                name = name.replace('\\', '')
-            if name not in circuit.cells:
-                name = name.replace('[', '_').replace(']', '_')
-            if name not in circuit.cells:
-                return None
-            return circuit.cells[name]
-
-        timing = np.zeros((len(circuit.lines), 2, 2))
-        for cn, iopaths in self.cells.items():
-            for ipn, opn, *delvals in iopaths:
-                delvals = [d if len(d) > 0 else [0, 0, 0] for d in delvals]
-                if max(max(delvals)) == 0:
-                    continue
-                cell = find_cell(cn)
-                if cell is None:
-                    log.warn(f'Cell from SDF not found in circuit: {cn}')
-                    continue
-                ipin = tlib.pin_index(cell.kind, ipn)
-                opin = tlib.pin_index(cell.kind, opn)
-                kind = cell.kind.lower()
-
-                ipn2 = ipn.replace('(posedge A1)', 'A1').replace('(negedge A1)', 'A1')\
-                    .replace('(posedge A2)', 'A2').replace('(negedge A2)', 'A2')
-
-                def add_delays(_line):
-                    if _line is not None:
-                        timing[_line, :, 0] += select_del(delvals, 0)
-                        timing[_line, :, 1] += select_del(delvals, 1)
-
-                take_avg = False
-                if kind.startswith('sdff'):
-                    if not ipn.startswith('(posedge CLK'):
-                        continue
-                    if ffdelays and (len(cell.outs) > opin):
-                        add_delays(cell.outs[opin])
-                else:
-                    if kind.startswith(('xor', 'xnor')):
-                        ipin = tlib.pin_index(cell.kind, ipn2)
-                        # print(ipn, ipin, times[cell.i_lines[ipin], 0, 0])
-                        take_avg = timing[cell.ins[ipin]].sum() > 0
-                    add_delays(cell.ins[ipin])
-                    if take_avg:
-                        timing[cell.ins[ipin]] /= 2
 
-        if not interconnect or self.interconnects is None:
-            return timing
+        def find_cell(name:str):
+            if name not in circuit.cells: name = name.replace('\\', '')
+            if name not in circuit.cells: name = name.replace('[', '_').replace(']', '_')
+            return circuit.cells.get(name, None)
+
+        delays = np.zeros((len(circuit.lines), 2, 2, 3))  # dataset last during construction.
+
+        for name, iopaths in self.cells.items():
+            name = name.replace('\\', '')
+            if cell := circuit.cells.get(name, None):
+                for i_pin_spec, o_pin_spec, *dels in iopaths:
+                    if i_pin_spec.startswith('(posedge '): i_pol_idxs = [0]
+                    elif i_pin_spec.startswith('(negedge '): i_pol_idxs = [1]
+                    else: i_pol_idxs = [0, 1]
+                    i_pin_spec = re.sub(r'\((neg|pos)edge ([^)]+)\)', r'\2', i_pin_spec)
+                    if line := cell.ins[tlib.pin_index(cell.kind, i_pin_spec)]:
+                        delays[line, i_pol_idxs] = [d if len(d) > 0 else [0, 0, 0] for d in dels]
+                    else:
+                        log.warn(f'No line to annotate in circuit: {i_pin_spec} for {cell}')
+            else:
+                log.warn(f'Name from SDF not found in circuit: {name}')
+
+        return np.moveaxis(delays, -1, 0)
+
+    def interconnects(self, circuit:Circuit, tlib:TechLib):
+        """Constructs an ndarray containing all INTERCONNECT delays.
+
+        To properly annotate interconnect delays, the circuit model has to include a '__fork__' node on
+        every signal and every fanout-branch. The Verilog parser aids in this by setting the parameter
+        `branchforks=True` in :py:func:`~kyupy.verilog.parse` or :py:func:`~kyupy.verilog.load`.
+
+        Limited support of SDF spec:
+
+        * Only ABSOLUTE delay values are supported.
+        * Only two delvals per delval_list is supported. First is rising/posedge, second is falling/negedge
+          transition.
+        * PATHPULSE declarations are ignored.
 
-        for n1, n2, *delvals in self.interconnects:
+        The axes convention of KyuPy's delay data arrays is as follows:
+
+        * Axis 0: dataset (usually 3 datasets per SDF-file)
+        * Axis 1: line index. Usually input line of a __fork__.
+        * Axis 2: (axis of size 2 for compatability to IOPATH results. Values are broadcast along this axis.)
+        * Axis 3: polarity of the transition, 0='rising/posedge', 1='falling/negedge'
+        """
+
+        delays = np.zeros((len(circuit.lines), 2, 2, 3))  # dataset last during construction.
+
+        for n1, n2, *delvals in self._interconnects:
             delvals = [d if len(d) > 0 else [0, 0, 0] for d in delvals]
-            if max(max(delvals)) == 0:
+            if max(max(delvals)) == 0: continue
+            cn1, pn1 = n1.split('/') if '/' in n1 else (n1, None)
+            cn2, pn2 = n2.split('/') if '/' in n2 else (n2, None)
+            cn1 = cn1.replace('\\','')
+            cn2 = cn2.replace('\\','')
+            c1, c2 = circuit.cells[cn1], circuit.cells[cn2]
+            p1 = tlib.pin_index(c1.kind, pn1) if pn1 is not None else 0
+            p2 = tlib.pin_index(c2.kind, pn2) if pn2 is not None else 0
+            if len(c1.outs) <= p1 or c1.outs[p1] is None:
+                log.warn(f'No line to annotate pin {pn1} of {c1}')
                 continue
-            if '/' in n1:
-                i = n1.rfind('/')
-                cn1 = n1[0:i]
-                pn1 = n1[i+1:]
-            else:
-                cn1, pn1 = (n1, 'Z')
-            if '/' in n2:
-                i = n2.rfind('/')
-                cn2 = n2[0:i]
-                pn2 = n2[i+1:]
-            else:
-                cn2, pn2 = (n2, 'IN')
-            c1 = find_cell(cn1)
-            if c1 is None:
-                log.warn(f'Cell from SDF not found in circuit: {cn1}')
-                continue
-            c2 = find_cell(cn2)
-            if c2 is None:
-                log.warn(f'Cell from SDF not found in circuit: {cn2}')
+            if len(c2.ins) <= p2 or c2.ins[p2] is None:
+                log.warn(f'No line to annotate pin {pn2} of {c2}')
                 continue
-            p1, p2 = tlib.pin_index(c1.kind, pn1), tlib.pin_index(c2.kind, pn2)
-            line = None
-            f1, f2 = c1.outs[p1].reader, c2.ins[p2].driver
-            if f1 != f2:  # possible branchfork
-                assert len(f2.ins) == 1
+            f1, f2 = c1.outs[p1].reader, c2.ins[p2].driver  # find the forks between cells.
+            assert f1.kind == '__fork__'
+            assert f2.kind == '__fork__'
+            if f1 != f2:  # at least two forks, make sure f2 is a branchfork connected to f1
+                assert len(f2.outs) == 1
+                assert f1.outs[f2.ins[0].driver_pin] == f2.ins[0]
                 line = f2.ins[0]
-                assert f1.outs[f2.ins[0].driver_pin] == line
-            elif len(f2.outs) == 1:  # no fanout?
+            elif len(f2.outs) == 1:  # f1==f2, only OK when there is no fanout.
                 line = f2.ins[0]
-            if line is not None:
-                timing[line, :, 0] += select_del(delvals, 0)
-                timing[line, :, 1] += select_del(delvals, 1)
             else:
-                log.warn(f'No branchfork for annotating interconnect delay {c1.name}/{p1}->{c2.name}/{p2}')
-        return timing
+                log.warn(f'No branchfork to annotate interconnect delay {c1.name}/{p1}->{c2.name}/{p2}')
+                continue
+            delays[line, :] = delvals
+
+        return np.moveaxis(delays, -1, 0)
 
 
 def sanitize(args):
     if len(args) == 3: args.append(args[2])
     return [str(args[0]), str(args[1])] + args[2:]
 
 
@@ -228,10 +199,10 @@
     """Parses the given ``text`` and returns a :class:`DelayFile` object."""
     return Lark(GRAMMAR, parser="lalr", transformer=SdfTransformer()).parse(text)
 
 
 def load(file):
     """Parses the contents of ``file`` and returns a :class:`DelayFile` object.
 
-    The given file may be gzip compressed.
+    Files with `.gz`-suffix are decompressed on-the-fly.
     """
     return parse(readtext(file))
```

## kyupy/stil.py

```diff
@@ -1,20 +1,21 @@
 """A simple and incomplete parser for the Standard Test Interface Language (STIL).
 
 The main purpose of this parser is to load scan pattern sets from STIL files.
-It supports only a very limited subset of STIL.
+It supports only a subset of STIL.
 
-The functions :py:func:`load` and :py:func:`read` return an intermediate representation (:class:`StilFile` object).
-Call :py:func:`StilFile.tests`, :py:func:`StilFile.tests_loc`, or :py:func:`StilFile.responses` to
+The functions :py:func:`parse` and :py:func:`load` return an intermediate representation (:py:class:`StilFile` object).
+Call :py:func:`StilFile.tests()`, :py:func:`StilFile.tests_loc()`, or :py:func:`StilFile.responses()` to
 obtain the appropriate vector sets.
 """
 
 import re
 from collections import namedtuple
 
+import numpy as np
 from lark import Lark, Transformer
 
 from . import readtext, logic
 from .logic_sim import LogicSim
 
 
 Call = namedtuple('Call', ['name', 'parameters'])
@@ -36,31 +37,30 @@
         capture = {}
         sload = {}
         for call in self.calls:
             if call.name == 'load_unload':
                 unload = {}
                 for so_port in self.so_ports:
                     if so_port in call.parameters:
-                        unload[so_port] = call.parameters[so_port].replace('\n', '')
-                if len(launch) > 0:
+                        unload[so_port] = call.parameters[so_port].replace('\n', '').replace('N', '-')
+                if len(capture) > 0:
                     self.patterns.append(ScanPattern(sload, launch, capture, unload))
                     capture = {}
                     launch = {}
                 sload = {}
                 for si_port in self.si_ports:
                     if si_port in call.parameters:
-                        sload[si_port] = call.parameters[si_port].replace('\n', '')
-            if call.name.endswith('_launch') or call.name.endswith('_capture'):
-                if len(launch) == 0:
-                    launch = dict((k, v.replace('\n', '')) for k, v in call.parameters.items())
-                else:
-                    capture = dict((k, v.replace('\n', '')) for k, v in call.parameters.items())
+                        sload[si_port] = call.parameters[si_port].replace('\n', '').replace('N', '-')
+            if call.name.endswith('_launch'):
+                launch = dict((k, v.replace('\n', '').replace('N', '-')) for k, v in call.parameters.items())
+            if call.name.endswith('_capture'):
+                capture = dict((k, v.replace('\n', '').replace('N', '-')) for k, v in call.parameters.items())
 
     def _maps(self, c):
-        interface = list(c.interface) + [n for n in c.nodes if 'DFF' in n.kind]
+        interface = list(c.io_nodes) + [n for n in c.nodes if 'DFF' in n.kind]
         intf_pos = dict((n.name, i) for i, n in enumerate(interface))
         pi_map = [intf_pos[n] for n in self.signal_groups['_pi']]
         po_map = [intf_pos[n] for n in self.signal_groups['_po']]
         scan_maps = {}
         scan_inversions = {}
         for chain in self.scan_chains.values():
             scan_map = []
@@ -78,81 +78,107 @@
                 if n == '!':
                     inversion = not inversion
                 else:
                     scan_map.append(intf_pos[n])
                     scan_out_inversion.append(inversion)
             scan_maps[chain[0]] = scan_map
             scan_maps[chain[-1]] = scan_map
-            scan_inversions[chain[0]] = scan_in_inversion
-            scan_inversions[chain[-1]] = scan_out_inversion
+            scan_inversions[chain[0]] = logic.mvarray(scan_in_inversion)[0]
+            scan_inversions[chain[-1]] = logic.mvarray(scan_out_inversion)[0]
         return interface, pi_map, po_map, scan_maps, scan_inversions
 
     def tests(self, circuit):
         """Assembles and returns a scan test pattern set for given circuit.
 
         This function assumes a static (stuck-at fault) test.
+
+        :param circuit: The circuit to assemble the patterns for. The patterns will follow the
+            :py:attr:`~kyupy.circuit.Circuit.s_nodes` ordering of the this circuit.
+        :return: A 4-valued multi-valued (mv) logic array (see :py:mod:`~kyupy.logic`).
+            The values for primary inputs and sequential elements are filled, the primary outputs are left unassigned.
         """
         interface, pi_map, _, scan_maps, scan_inversions = self._maps(circuit)
-        tests = logic.MVArray((len(interface), len(self.patterns)))
+        tests = np.full((len(interface), len(self.patterns)), logic.UNASSIGNED)
         for i, p in enumerate(self.patterns):
             for si_port in self.si_ports.keys():
-                pattern = logic.mv_xor(p.load[si_port], scan_inversions[si_port])
-                tests.data[scan_maps[si_port], i] = pattern.data[:, 0]
-            tests.data[pi_map, i] = logic.MVArray(p.launch['_pi']).data[:, 0]
+                pattern = logic.mvarray(p.load[si_port])
+                inversions = np.choose((pattern == logic.UNASSIGNED) | (pattern == logic.UNKNOWN),
+                                       [scan_inversions[si_port], logic.ZERO]).astype(np.uint8)
+                np.bitwise_xor(pattern, inversions, out=pattern)
+                tests[scan_maps[si_port], i] = pattern
+            tests[pi_map, i] = logic.mvarray(p.capture['_pi'])
         return tests
 
-    def tests_loc(self, circuit):
+    def tests_loc(self, circuit, init_filter=None, launch_filter=None):
         """Assembles and returns a LoC scan test pattern set for given circuit.
 
         This function assumes a launch-on-capture (LoC) delay test.
-        It performs a logic simulation to obtain the first capture pattern (the one that launches the
-        delay test) and assembles the test pattern set from from pairs for initialization- and launch-patterns.
+        It performs a logic simulation to obtain the first capture pattern (the one that launches the delay
+        test) and assembles the test pattern set from from pairs for initialization- and launch-patterns.
+
+        :param circuit: The circuit to assemble the patterns for. The patterns will follow the
+            :py:attr:`~kyupy.circuit.Circuit.s_nodes` ordering of the this circuit.
+        :param init_filter: A function for filtering the initialization patterns. This function is called
+            with the initialization patterns from the STIL file as mvarray before logic simulation.
+            It shall return an mvarray with the same shape. This function can be used, for example, to fill
+            patterns.
+        :param launch_filter: A function for filtering the launch patterns. This function is called
+            with the launch patterns generated by logic simulation before they are combined with
+            the initialization patterns to form the final 8-valued test patterns.
+            The function shall return an mvarray with the same shape. This function can be used, for example, to fill
+            patterns.
+        :return: An 8-valued multi-valued (mv) logic array (see :py:mod:`~kyupy.logic`). The values for primary
+            inputs and sequential elements are filled, the primary outputs are left unassigned.
         """
         interface, pi_map, po_map, scan_maps, scan_inversions = self._maps(circuit)
-        init = logic.MVArray((len(interface), len(self.patterns)), m=4)
-        # init = PackedVectors(len(self.patterns), len(interface), 2)
+        init = np.full((len(interface), len(self.patterns)), logic.UNASSIGNED)
         for i, p in enumerate(self.patterns):
             # init.set_values(i, '0' * len(interface))
             for si_port in self.si_ports.keys():
-                pattern = logic.mv_xor(p.load[si_port], scan_inversions[si_port])
-                init.data[scan_maps[si_port], i] = pattern.data[:, 0]
-            init.data[pi_map, i] = logic.MVArray(p.launch['_pi']).data[:, 0]
-        launch_bp = logic.BPArray(init)
-        sim4v = LogicSim(circuit, len(init), m=4)
-        sim4v.assign(launch_bp)
-        sim4v.propagate()
-        sim4v.capture(launch_bp)
-        launch = logic.MVArray(launch_bp)
+                pattern = logic.mvarray(p.load[si_port])
+                inversions = np.choose((pattern == logic.UNASSIGNED) | (pattern == logic.UNKNOWN),
+                                       [scan_inversions[si_port], logic.ZERO]).astype(np.uint8)
+                np.bitwise_xor(pattern, inversions, out=pattern)
+                init[scan_maps[si_port], i] = pattern
+            init[pi_map, i] = logic.mvarray(p.launch['_pi'] if '_pi' in p.launch else p.capture['_pi'])
+        if init_filter: init = init_filter(init)
+        sim8v = LogicSim(circuit, init.shape[-1], m=8)
+        sim8v.s[0] = logic.mv_to_bp(init)
+        sim8v.s_to_c()
+        sim8v.c_prop()
+        sim8v.c_to_s()
+        launch = logic.bp_to_mv(sim8v.s[1])[..., :init.shape[-1]]
         for i, p in enumerate(self.patterns):
-            # if there was no launch clock, then init = launch
-            if ('P' not in p.launch['_pi']) or ('P' not in p.capture['_pi']):
+            # if there was no launch cycle or launch clock, then init = launch
+            if '_pi' not in p.launch or 'P' not in p.launch['_pi'] or 'P' not in p.capture['_pi']:
                 for si_port in self.si_ports.keys():
-                    pattern = logic.mv_xor(p.load[si_port], scan_inversions[si_port])
-                    launch.data[scan_maps[si_port], i] = pattern.data[:, 0]
+                    pattern = logic.mv_xor(logic.mvarray(p.load[si_port]), scan_inversions[si_port])
+                    launch[scan_maps[si_port], i] = pattern
             if '_pi' in p.capture and 'P' in p.capture['_pi']:
-                launch.data[pi_map, i] = logic.MVArray(p.capture['_pi']).data[:, 0]
-            launch.data[po_map, i] = logic.UNASSIGNED
+                launch[pi_map, i] = logic.mvarray(p.capture['_pi'])
+            launch[po_map, i] = logic.UNASSIGNED
+        if launch_filter: launch = launch_filter(launch)
 
         return logic.mv_transition(init, launch)
 
     def responses(self, circuit):
-        """Assembles and returns a scan test response pattern set for given circuit."""
+        """Assembles and returns a scan test response pattern set for given circuit.
+
+        :param circuit: The circuit to assemble the patterns for. The patterns will follow the
+            :py:attr:`~kyupy.circuit.Circuit.s_nodes` ordering of the this circuit.
+        :return: A 4-valued multi-valued (mv) logic array (see :py:mod:`~kyupy.logic`).
+            The values for primary outputs and sequential elements are filled, the primary inputs are left unassigned.
+        """
         interface, _, po_map, scan_maps, scan_inversions = self._maps(circuit)
-        resp = logic.MVArray((len(interface), len(self.patterns)))
-        # resp = PackedVectors(len(self.patterns), len(interface), 2)
+        resp = np.full((len(interface), len(self.patterns)), logic.UNASSIGNED)
         for i, p in enumerate(self.patterns):
-            resp.data[po_map, i] = logic.MVArray(p.capture['_po'] if len(p.capture) > 0 else p.launch['_po']).data[:, 0]
-            # if len(p.capture) > 0:
-            #    resp.set_values(i, p.capture['_po'], po_map)
-            # else:
-            #    resp.set_values(i, p.launch['_po'], po_map)
+            resp[po_map, i] = logic.mvarray(p.capture['_po'] if len(p.capture) > 0 else p.launch['_po'])
             for so_port in self.so_ports.keys():
-                pattern = logic.mv_xor(p.unload[so_port], scan_inversions[so_port])
-                resp.data[scan_maps[so_port], i] = pattern.data[:, 0]
-                # resp.set_values(i, p.unload[so_port], scan_maps[so_port], scan_inversions[so_port])
+                pattern = logic.mv_xor(logic.mvarray(p.unload[so_port]), scan_inversions[so_port])
+                resp[scan_maps[so_port], i] = pattern
         return resp
 
 
 class StilTransformer(Transformer):
     def __init__(self):
         super().__init__()
         self._signal_groups = None
@@ -193,23 +219,24 @@
     def scan_structures(self, args): self._scan_chains = dict(args)
 
     def start(self, args):
         return StilFile(float(args[0]), self._signal_groups, self._scan_chains, self._calls)
 
 
 GRAMMAR = r"""
-    start: "STIL" FLOAT _ignore _block*
+    start: "STIL" FLOAT ( _ignore | ";" ) _block*
     _block: signal_groups | scan_structures | pattern
         | "Header" _ignore
         | "Signals" _ignore
         | "Timing" _ignore
         | "PatternBurst" quoted _ignore
         | "PatternExec" _ignore
         | "Procedures" _ignore
         | "MacroDefs" _ignore
+        | "UserKeywords" /[a-zA-Z]*;/
 
     signal_groups: "SignalGroups" "{" signal_group* "}"
     signal_group: quoted "=" "'" quoted ( "+" quoted)* "'" _ignore? ";"?
 
     scan_structures: "ScanStructures" "{" scan_chain* "}"
     scan_chain: "ScanChain" quoted "{" ( scan_length
         | scan_in | scan_out | scan_inversion | scan_cells | scan_master_clock )* "}"
@@ -242,10 +269,10 @@
     """Parses the given ``text`` and returns a :class:`StilFile` object."""
     return Lark(GRAMMAR, parser="lalr", transformer=StilTransformer()).parse(text)
 
 
 def load(file):
     """Parses the contents of ``file`` and returns a :class:`StilFile` object.
 
-    The given file may be gzip compressed.
+    Files with `.gz`-suffix are decompressed on-the-fly.
     """
     return parse(readtext(file))
```

## kyupy/techlib.py

```diff
@@ -1,301 +1,415 @@
-from .circuit import Node, Line
+"""KyuPy's Built-In Technology Libraries
 
+Technology libraries provide cell definitions and their implementation with simulation primitives.
+A couple of common standard cell libraries are built-in.
+Others can be easily added by providing a bench-like description of the cells.
+"""
 
-def add_and_connect(circuit, name, kind, in1=None, in2=None, out=None):
-    n = Node(circuit, name, kind)
-    if in1 is not None:
-        n.ins[0] = in1
-        in1.reader = n
-        in1.reader_pin = 0
-    if in2 is not None:
-        n.ins[1] = in2
-        in2.reader = n
-        in2.reader_pin = 1
-    if out is not None:
-        n.outs[0] = out
-        out.driver = n
-        out.driver_pin = 0
-    return n
+import re
+from itertools import product
 
+from . import bench
 
-class TechLib:
-    """Provides some information specific to standard cell libraries necessary
-    for loading gate-level designs. :py:class:`~kyupy.circuit.Node` objects do not
-    have pin names. The methods defined here map pin names to pin directions and defined
-    positions in the ``node.ins`` and ``node.outs`` lists. The default implementation
-    provides mappings for SAED-inspired standard cell libraries.
-    """
 
+class TechLibOld:
     @staticmethod
     def pin_index(kind, pin):
-        """Returns a pin list position for a given node kind and pin name."""
+        if isinstance(pin, int):
+            return max(0, pin-1)
+        if kind[:3] in ('OAI', 'AOI'):
+            if pin[0] == 'A': return int(pin[1]) - 1
+            if pin == 'B': return int(kind[3])
+            if pin[0] == 'B': return int(pin[1]) - 1 + int(kind[3])
         for prefix, pins, index in [('HADD', ('B0', 'SO'), 1),
-                                    ('MUX21', ('S',), 2),
+                                    ('HADD', ('A0', 'C1'), 0),
+                                    ('MUX21', ('S', 'S0'), 2),
+                                    ('MX2', ('S0',), 2),
+                                    ('TBUF', ('OE',), 1),
+                                    ('TINV', ('OE',), 1),
+                                    ('LATCH', ('D',), 0),
+                                    ('LATCH', ('QN',), 1),
+                                    ('DFF', ('D',), 0),
                                     ('DFF', ('QN',), 1),
+                                    ('SDFF', ('D',), 0),
                                     ('SDFF', ('QN',), 1),
                                     ('SDFF', ('CLK',), 3),
-                                    ('SDFF', ('RSTB',), 4),
-                                    ('SDFF', ('SETB',), 5)]:
+                                    ('SDFF', ('RSTB', 'RN'), 4),
+                                    ('SDFF', ('SETB',), 5),
+                                    ('ISOL', ('ISO',), 0),
+                                    ('ISOL', ('D',), 1)]:
             if kind.startswith(prefix) and pin in pins: return index
-        for index, pins in enumerate([('A1', 'IN1', 'D', 'S', 'INP', 'A', 'Q', 'QN', 'Y', 'Z', 'ZN'),
-                                      ('A2', 'IN2', 'CLK', 'CO', 'SE', 'B'),
-                                      ('A3', 'IN3', 'RSTB', 'CI', 'SI'),
-                                      ('A4', 'IN4', 'SETB'),
-                                      ('A5', 'IN5'),
-                                      ('A6', 'IN6')]):
+        for index, pins in enumerate([('A1', 'IN1', 'A', 'S', 'INP', 'I', 'Q', 'QN', 'Y', 'Z', 'ZN'),
+                                      ('A2', 'IN2', 'B', 'CK', 'CLK', 'CO', 'SE'),
+                                      ('A3', 'IN3', 'C', 'RN', 'RSTB', 'CI', 'SI'),
+                                      ('A4', 'IN4', 'D', 'SN', 'SETB'),
+                                      ('A5', 'IN5', 'E'),
+                                      ('A6', 'IN6', 'F')]):
             if pin in pins: return index
         raise ValueError(f'Unknown pin index for {kind}.{pin}')
 
     @staticmethod
     def pin_is_output(kind, pin):
-        """Returns True, if given pin name of a node kind is an output."""
+        if isinstance(pin, int):
+            return pin == 0
         if 'MUX' in kind and pin == 'S': return False
         return pin in ('Q', 'QN', 'Z', 'ZN', 'Y', 'CO', 'S', 'SO', 'C1')
 
-    @staticmethod
-    def split_complex_gates(circuit):
-        node_list = circuit.nodes
-        for n in node_list:
-            name = n.name
-            ins = n.ins
-            outs = n.outs
-            if n.kind.startswith('AO21X'):
-                n.remove()
-                n_and = add_and_connect(circuit, name+'~and', 'AND2', ins[0], ins[1], None)
-                n_or = add_and_connect(circuit, name+'~or', 'OR2', None, ins[2], outs[0])
-                Line(circuit, n_and, n_or)
-            elif n.kind.startswith('AOI21X'):
-                n.remove()
-                n_and = add_and_connect(circuit, name+'~and', 'AND2', ins[0], ins[1], None)
-                n_nor = add_and_connect(circuit, name+'~nor', 'NOR2', None, ins[2], outs[0])
-                Line(circuit, n_and, n_nor)
-            elif n.kind.startswith('OA21X'):
-                n.remove()
-                n_or = add_and_connect(circuit, name+'~or', 'OR2', ins[0], ins[1], None)
-                n_and = add_and_connect(circuit, name+'~and', 'AND2', None, ins[2], outs[0])
-                Line(circuit, n_or, n_and)
-            elif n.kind.startswith('OAI21X'):
-                n.remove()
-                n_or = add_and_connect(circuit, name+'~or', 'OR2', ins[0], ins[1], None)
-                n_nand = add_and_connect(circuit, name+'~nand', 'NAND2', None, ins[2], outs[0])
-                Line(circuit, n_or, n_nand)
-            elif n.kind.startswith('OA22X'):
-                n.remove()
-                n_or0 = add_and_connect(circuit, name+'~or0', 'OR2', ins[0], ins[1], None)
-                n_or1 = add_and_connect(circuit, name+'~or1', 'OR2', ins[2], ins[3], None)
-                n_and = add_and_connect(circuit, name+'~and', 'AND2', None, None, outs[0])
-                Line(circuit, n_or0, n_and)
-                Line(circuit, n_or1, n_and)
-            elif n.kind.startswith('OAI22X'):
-                n.remove()
-                n_or0 = add_and_connect(circuit, name+'~or0', 'OR2', ins[0], ins[1], None)
-                n_or1 = add_and_connect(circuit, name+'~or1', 'OR2', ins[2], ins[3], None)
-                n_nand = add_and_connect(circuit, name+'~nand', 'NAND2', None, None, outs[0])
-                Line(circuit, n_or0, n_nand)
-                Line(circuit, n_or1, n_nand)
-            elif n.kind.startswith('AO22X'):
-                n.remove()
-                n_and0 = add_and_connect(circuit, name+'~and0', 'AND2', ins[0], ins[1], None)
-                n_and1 = add_and_connect(circuit, name+'~and1', 'AND2', ins[2], ins[3], None)
-                n_or = add_and_connect(circuit, name+'~or', 'OR2', None, None, outs[0])
-                Line(circuit, n_and0, n_or)
-                Line(circuit, n_and1, n_or)
-            elif n.kind.startswith('AOI22X'):
-                n.remove()
-                n_and0 = add_and_connect(circuit, name+'~and0', 'AND2', ins[0], ins[1], None)
-                n_and1 = add_and_connect(circuit, name+'~and1', 'AND2', ins[2], ins[3], None)
-                n_nor = add_and_connect(circuit, name+'~nor', 'NOR2', None, None, outs[0])
-                Line(circuit, n_and0, n_nor)
-                Line(circuit, n_and1, n_nor)
-            elif n.kind.startswith('AO221X'):
-                n.remove()
-                n_and0 = add_and_connect(circuit, name+'~and0', 'AND2', ins[0], ins[1], None)
-                n_and1 = add_and_connect(circuit, name+'~and1', 'AND2', ins[2], ins[3], None)
-                n_or0 = add_and_connect(circuit, name+'~or0', 'OR2', None, None, None)
-                n_or1 = add_and_connect(circuit, name+'~or1', 'OR2', None, ins[4], outs[0])
-                Line(circuit, n_and0, n_or0)
-                Line(circuit, n_and1, n_or0)
-                Line(circuit, n_or0, n_or1)
-            elif n.kind.startswith('AOI221X'):
-                n.remove()
-                n_and0 = add_and_connect(circuit, name+'~and0', 'AND2', ins[0], ins[1], None)
-                n_and1 = add_and_connect(circuit, name+'~and1', 'AND2', ins[2], ins[3], None)
-                n_or = add_and_connect(circuit, name+'~or', 'OR2', None, None, None)
-                n_nor = add_and_connect(circuit, name+'~nor', 'NOR2', None, ins[4], outs[0])
-                Line(circuit, n_and0, n_or)
-                Line(circuit, n_and1, n_or)
-                Line(circuit, n_or, n_nor)
-            elif n.kind.startswith('OA221X'):
-                n.remove()
-                n_or0 = add_and_connect(circuit, name+'~or0', 'OR2', ins[0], ins[1], None)
-                n_or1 = add_and_connect(circuit, name+'~or1', 'OR2', ins[2], ins[3], None)
-                n_and0 = add_and_connect(circuit, name+'~and0', 'AND2', None, None, None)
-                n_and1 = add_and_connect(circuit, name+'~and1', 'AND2', None, ins[4], outs[0])
-                Line(circuit, n_or0, n_and0)
-                Line(circuit, n_or1, n_and0)
-                Line(circuit, n_and0, n_and1)
-            elif n.kind.startswith('OAI221X'):
-                n.remove()
-                n_or0 = add_and_connect(circuit, name+'~or0', 'OR2', ins[0], ins[1], None)
-                n_or1 = add_and_connect(circuit, name+'~or1', 'OR2', ins[2], ins[3], None)
-                n_and0 = add_and_connect(circuit, name+'~and0', 'AND2', None, None, None)
-                n_nand1 = add_and_connect(circuit, name+'~nand1', 'NAND2', None, ins[4], outs[0])
-                Line(circuit, n_or0, n_and0)
-                Line(circuit, n_or1, n_and0)
-                Line(circuit, n_and0, n_nand1)
-            elif n.kind.startswith('AO222X'):
-                n.remove()
-                n_and0 = add_and_connect(circuit, name+'~and0', 'AND2', ins[0], ins[1], None)
-                n_and1 = add_and_connect(circuit, name+'~and1', 'AND2', ins[2], ins[3], None)
-                n_and2 = add_and_connect(circuit, name+'~and2', 'AND2', ins[4], ins[5], None)
-                n_or0 = add_and_connect(circuit, name+'~or0', 'OR2', None, None, None)
-                n_or1 = add_and_connect(circuit, name+'~or1', 'OR2', None, None, outs[0])
-                Line(circuit, n_and0, n_or0)
-                Line(circuit, n_and1, n_or0)
-                Line(circuit, n_and2, n_or1)
-                Line(circuit, n_or0, n_or1)
-            elif n.kind.startswith('AOI222X'):
-                n.remove()
-                n_and0 = add_and_connect(circuit, name+'~and0', 'AND2', ins[0], ins[1], None)
-                n_and1 = add_and_connect(circuit, name+'~and1', 'AND2', ins[2], ins[3], None)
-                n_and2 = add_and_connect(circuit, name+'~and2', 'AND2', ins[4], ins[5], None)
-                n_or0 = add_and_connect(circuit, name+'~or0', 'OR2', None, None, None)
-                n_nor1 = add_and_connect(circuit, name+'~nor1', 'NOR2', None, None, outs[0])
-                Line(circuit, n_and0, n_or0)
-                Line(circuit, n_and1, n_or0)
-                Line(circuit, n_and2, n_nor1)
-                Line(circuit, n_or0, n_nor1)
-            elif n.kind.startswith('OA222X'):
-                n.remove()
-                n_or0 = add_and_connect(circuit, name+'~or0', 'OR2', ins[0], ins[1], None)
-                n_or1 = add_and_connect(circuit, name+'~or1', 'OR2', ins[2], ins[3], None)
-                n_or2 = add_and_connect(circuit, name+'~or2', 'OR2', ins[4], ins[5], None)
-                n_and0 = add_and_connect(circuit, name+'~and0', 'AND2', None, None, None)
-                n_and1 = add_and_connect(circuit, name+'~and1', 'AND2', None, None, outs[0])
-                Line(circuit, n_or0, n_and0)
-                Line(circuit, n_or1, n_and0)
-                Line(circuit, n_or2, n_and1)
-                Line(circuit, n_and0, n_and1)
-            elif n.kind.startswith('OAI222X'):
-                n.remove()
-                n0 = add_and_connect(circuit, name+'~or0', 'OR2', ins[0], ins[1], None)
-                n1 = add_and_connect(circuit, name+'~or1', 'OR2', ins[2], ins[3], None)
-                n2 = add_and_connect(circuit, name+'~or2', 'OR2', ins[4], ins[5], None)
-                n3 = add_and_connect(circuit, name+'~and0', 'AND2', None, None, None)
-                n4 = add_and_connect(circuit, name+'~nand1', 'NAND2', None, None, outs[0])
-                Line(circuit, n0, n3)
-                Line(circuit, n1, n3)
-                Line(circuit, n2, n4)
-                Line(circuit, n3, n4)
-            elif n.kind.startswith('AND3X'):
-                n.remove()
-                n0 = add_and_connect(circuit, name+'~and0', 'AND2', ins[0], ins[1], None)
-                n1 = add_and_connect(circuit, name+'~and1', 'AND2', None, ins[2], outs[0])
-                Line(circuit, n0, n1)
-            elif n.kind.startswith('OR3X'):
-                n.remove()
-                n0 = add_and_connect(circuit, name+'~or0', 'OR2', ins[0], ins[1], None)
-                n1 = add_and_connect(circuit, name+'~or1', 'OR2', None, ins[2], outs[0])
-                Line(circuit, n0, n1)
-            elif n.kind.startswith('XOR3X'):
-                n.remove()
-                n0 = add_and_connect(circuit, name+'~xor0', 'XOR2', ins[0], ins[1], None)
-                n1 = add_and_connect(circuit, name+'~xor1', 'XOR2', None, ins[2], outs[0])
-                Line(circuit, n0, n1)
-            elif n.kind.startswith('NAND3X'):
-                n.remove()
-                n0 = add_and_connect(circuit, name+'~and', 'AND2', ins[0], ins[1], None)
-                n1 = add_and_connect(circuit, name+'~nand', 'NAND2', None, ins[2], outs[0])
-                Line(circuit, n0, n1)
-            elif n.kind.startswith('NOR3X'):
-                n.remove()
-                n0 = add_and_connect(circuit, name+'~or', 'OR2', ins[0], ins[1], None)
-                n1 = add_and_connect(circuit, name+'~nor', 'NOR2', None, ins[2], outs[0])
-                Line(circuit, n0, n1)
-            elif n.kind.startswith('XNOR3X'):
-                n.remove()
-                n0 = add_and_connect(circuit, name+'~xor', 'XOR2', ins[0], ins[1], None)
-                n1 = add_and_connect(circuit, name+'~xnor', 'XNOR2', None, ins[2], outs[0])
-                Line(circuit, n0, n1)
-            elif n.kind.startswith('AND4X'):
-                n.remove()
-                n0 = add_and_connect(circuit, name+'~and0', 'AND2', ins[0], ins[1], None)
-                n1 = add_and_connect(circuit, name+'~and1', 'AND2', ins[2], ins[3], None)
-                n2 = add_and_connect(circuit, name+'~and2', 'AND2', None, None, outs[0])
-                Line(circuit, n0, n2)
-                Line(circuit, n1, n2)
-            elif n.kind.startswith('OR4X'):
-                n.remove()
-                n0 = add_and_connect(circuit, name+'~or0', 'OR2', ins[0], ins[1], None)
-                n1 = add_and_connect(circuit, name+'~or1', 'OR2', ins[2], ins[3], None)
-                n2 = add_and_connect(circuit, name+'~or2', 'OR2', None, None, outs[0])
-                Line(circuit, n0, n2)
-                Line(circuit, n1, n2)
-            elif n.kind.startswith('NAND4X'):
-                n.remove()
-                n0 = add_and_connect(circuit, name+'~and0', 'AND2', ins[0], ins[1], None)
-                n1 = add_and_connect(circuit, name+'~and1', 'AND2', ins[2], ins[3], None)
-                n2 = add_and_connect(circuit, name+'~nand2', 'NAND2', None, None, outs[0])
-                Line(circuit, n0, n2)
-                Line(circuit, n1, n2)
-            elif n.kind.startswith('NOR4X'):
-                n.remove()
-                n0 = add_and_connect(circuit, name+'~or0', 'OR2', ins[0], ins[1], None)
-                n1 = add_and_connect(circuit, name+'~or1', 'OR2', ins[2], ins[3], None)
-                n2 = add_and_connect(circuit, name+'~nor2', 'NOR2', None, None, outs[0])
-                Line(circuit, n0, n2)
-                Line(circuit, n1, n2)
-            elif n.kind.startswith('FADDX'):
-                n.remove()
-                # forks for fan-outs
-                f_a = add_and_connect(circuit, name + '~fork0', '__fork__', ins[0])
-                f_b = add_and_connect(circuit, name + '~fork1', '__fork__', ins[1])
-                f_ci = add_and_connect(circuit, name + '~fork2', '__fork__', ins[2])
-                f_ab = Node(circuit, name + '~fork3')
-                # sum-block
-                n_xor0 = Node(circuit, name + '~xor0', 'XOR2')
-                Line(circuit, f_a, n_xor0)
-                Line(circuit, f_b, n_xor0)
-                Line(circuit, n_xor0, f_ab)
-                if len(outs) > 0 and outs[0] is not None:
-                    n_xor1 = add_and_connect(circuit, name + '~xor1', 'XOR2', None, None, outs[0])
-                    Line(circuit, f_ab, n_xor1)
-                    Line(circuit, f_ci, n_xor1)
-                # carry-block
-                if len(outs) > 1 and outs[1] is not None:
-                    n_and0 = Node(circuit, name + '~and0', 'AND2')
-                    Line(circuit, f_ab, n_and0)
-                    Line(circuit, f_ci, n_and0)
-                    n_and1 = Node(circuit, name + '~and1', 'AND2')
-                    Line(circuit, f_a, n_and1)
-                    Line(circuit, f_b, n_and1)
-                    n_or = add_and_connect(circuit, name + '~or0', 'OR2', None, None, outs[1])
-                    Line(circuit, n_and0, n_or)
-                    Line(circuit, n_and1, n_or)
-            elif n.kind.startswith('HADDX'):
-                n.remove()
-                # forks for fan-outs
-                f_a = add_and_connect(circuit, name + '~fork0', '__fork__', ins[0])
-                f_b = add_and_connect(circuit, name + '~fork1', '__fork__', ins[1])
-                n_xor0 = add_and_connect(circuit, name + '~xor0', 'XOR2', None, None, outs[1])
-                Line(circuit, f_a, n_xor0)
-                Line(circuit, f_b, n_xor0)
-                n_and0 = add_and_connect(circuit, name + '~and0', 'AND2', None, None, outs[0])
-                Line(circuit, f_a, n_and0)
-                Line(circuit, f_b, n_and0)
-            elif n.kind.startswith('MUX21X'):
-                n.remove()
-                f_s = add_and_connect(circuit, name + '~fork0', '__fork__', ins[2])
-                n_not = Node(circuit, name + '~not', 'INV')
-                Line(circuit, f_s, n_not)
-                n_and0 = add_and_connect(circuit, name + '~and0', 'AND2', ins[0])
-                n_and1 = add_and_connect(circuit, name + '~and1', 'AND2', ins[1])
-                n_or0 = add_and_connect(circuit, name + '~or0', 'OR2', None, None, outs[0])
-                Line(circuit, n_not, n_and0)
-                Line(circuit, f_s, n_and1)
-                Line(circuit, n_and0, n_or0)
-                Line(circuit, n_and1, n_or0)
-            elif n.kind.startswith('DFFSSR'):
-                n.kind = 'DFFX1'
-                n_and0 = add_and_connect(circuit, name + '~and0', 'AND2', ins[0], ins[2], None)
-                Line(circuit, n_and0, (n, 0))
+
+class TechLib:
+    """Class for standard cell library definitions.
+
+    :py:class:`~kyupy.circuit.Node` objects do not have pin names.
+    This class maps pin names to pin directions and defined positions in the ``node.ins`` and ``node.outs`` lists.
+    Furthermore, it gives access to implementations of complex cells. See also :py:func:`~kyupy.circuit.substitute` and
+    :py:func:`~kyupy.circuit.resolve_tlib_cells`.
+    """
+    def __init__(self, lib_src):
+        self.cells = dict()
+        """A dictionary with pin definitions and circuits for each cell kind (type).
+        """
+        for c_str in re.split(r';\s+', lib_src):
+            c_str = re.sub(r'^\s+', '', c_str)
+            name_len = c_str.find(' ')
+            if name_len <= 0: continue
+            c = bench.parse(c_str[name_len:])
+            c.name = c_str[:name_len]
+            c.eliminate_1to1_forks()
+            i_idx, o_idx = 0, 0
+            pin_dict = dict()
+            for n in c.io_nodes:
+                if len(n.ins) == 0:
+                    pin_dict[n.name] = (i_idx, False)
+                    i_idx += 1
+                else:
+                    pin_dict[n.name] = (o_idx, True)
+                    o_idx += 1
+            parts = [s[1:-1].split(',') if s[0] == '{' else [s] for s in re.split(r'({[^}]+})', c.name) if len(s) > 0]
+            for name in [''.join(item) for item in product(*parts)]:
+                self.cells[name] = (c, pin_dict)
+
+    def pin_index(self, kind, pin):
+        """Returns a pin list position for a given node kind and pin name."""
+        assert kind in self.cells, f'Unknown cell: {kind}'
+        assert pin in self.cells[kind][1], f'Unknown pin: {pin} for cell {kind}'
+        return self.cells[kind][1][pin][0]
+
+    def pin_is_output(self, kind, pin):
+        """Returns True, if given pin name of a node kind is an output."""
+        assert kind in self.cells, f'Unknown cell: {kind}'
+        assert pin in self.cells[kind][1], f'Unknown pin: {pin} for cell {kind}'
+        return self.cells[kind][1][pin][1]
+
+
+GSC180 = TechLib(r"""
+BUFX{1,3}      input(A)    output(Y) Y=BUF1(A)    ;
+CLKBUFX{1,2,3} input(A)    output(Y) Y=BUF1(A)    ;
+INVX{1,2,4,8}  input(A)    output(Y) Y=INV1(A)    ;
+TBUFX{1,2,4,8} input(A,OE) output(Y) Y=AND2(A,OE) ;
+TINVX1         input(A,OE) output(Y) AB=INV1(A) Y=AND2(AB,OE) ;
+
+AND2X1      input(A,B)     output(Y) Y=AND2(A,B)      ;
+NAND2X{1,2} input(A,B)     output(Y) Y=NAND2(A,B)     ;
+NAND3X1     input(A,B,C)   output(Y) Y=NAND3(A,B,C)   ;
+NAND4X1     input(A,B,C,D) output(Y) Y=NAND4(A,B,C,D) ;
+OR2X1       input(A,B)     output(Y) Y=OR2(A,B)       ;
+OR4X1       input(A,B,C,D) output(Y) Y=OR4(A,B,C,D)   ;
+NOR2X1      input(A,B)     output(Y) Y=NOR2(A,B)      ;
+NOR3X1      input(A,B,C)   output(Y) Y=NOR3(A,B,C)    ;
+NOR4X1      input(A,B,C,D) output(Y) Y=NOR4(A,B,C,D)  ;
+XOR2X1      input(A,B)     output(Y) Y=XOR2(A,B)      ;
+
+MX2X1   input(A,B,S0)            output(Y)    Y=MUX21(A,B,S0)      ;
+AOI21X1 input(A0,A1,B0)          output(Y)    Y=AOI21(A0,A1,B0)    ;
+AOI22X1 input(A0,A1,B0,B1)       output(Y)    Y=AOI22(A0,A1,B0,B1) ;
+OAI21X1 input(A0,A1,B0)          output(Y)    Y=OAI21(A0,A1,B0)    ;
+OAI22X1 input(A0,A1,B0,B1)       output(Y)    Y=OAI22(A0,A1,B0,B1) ;
+OAI33X1 input(A0,A1,A2,B0,B1,B2) output(Y)    AA=OR2(A0,A1) BB=OR2(B0,B1) Y=OAI22(AA,A2,BB,B2) ;
+ADDFX1  input(A,B,CI)            output(CO,S) AB=XOR2(A,B) CO=XOR2(AB,CI) S=AO22(AB,CI,A,B)    ;
+ADDHX1  input(A,B)               output(CO,S) CO=XOR2(A,B) S=AND2(A,B)                         ;
+
+DFFX1    input(CK,D)             output(Q,QN) Q=DFF(D,CK) QN=INV1(Q) ;
+DFFSRX1  input(CK,D,RN,SN)       output(Q,QN) DR=AND2(D,RN) SET=INV1(SN) DRS=OR2(DR,SET) Q=DFF(DRS,CK) QN=INV1(Q) ;
+SDFFSRX1 input(CK,D,RN,SE,SI,SN) output(Q,QN) DR=AND2(D,RN) SET=INV1(SN) DRS=OR2(DR,SET) DI=MUX21(DRS,SI,SE) Q=DFF(DI,CK) QN=INV1(Q) ;
+
+TLATSRX1 input(D,G,RN,SN) output(Q,QN) DR=AND2(D,RN) SET=INV1(SN) DRS=OR2(DR,SET) Q=LATCH(DRS,G) QN=INV1(Q) ;
+TLATX1   input(C,D)       output(Q,QN) Q=LATCH(D,C) QN=INV1(Q) ;
+""")
+"""The GSC 180nm generic standard cell library.
+"""
+
+
+_nangate_common = r"""
+FILLCELL_X{1,2,4,8,16,32} ;
+
+LOGIC0_X1 output(Z) Z=__const0__() ;
+LOGIC1_X1 output(Z) Z=__const1__() ;
+
+BUF_X{1,2,4,8,16,32}  input(A) output(Z)  Z=BUF1(A)  ;
+CLKBUF_X{1,2,3}       input(A) output(Z)  Z=BUF1(A)  ;
+
+NAND2_X{1,2,4} input(A1,A2)       output(ZN) ZN=NAND2(A1,A2)       ;
+NAND3_X{1,2,4} input(A1,A2,A3)    output(ZN) ZN=NAND3(A1,A2,A3)    ;
+NAND4_X{1,2,4} input(A1,A2,A3,A4) output(ZN) ZN=NAND4(A1,A2,A3,A4) ;
+NOR2_X{1,2,4}  input(A1,A2)       output(ZN) ZN=NOR2(A1,A2)        ;
+NOR3_X{1,2,4}  input(A1,A2,A3)    output(ZN) ZN=NOR3(A1,A2,A3)     ;
+NOR4_X{1,2,4}  input(A1,A2,A3,A4) output(ZN) ZN=NOR4(A1,A2,A3,A4)  ;
+
+AOI21_X{1,2,4} input(A,B1,B2)     output(ZN) ZN=AOI21(B1,B2,A)     ;
+OAI21_X{1,2,4} input(A,B1,B2)     output(ZN) ZN=OAI21(B1,B2,A)     ;
+AOI22_X{1,2,4} input(A1,A2,B1,B2) output(ZN) ZN=AOI22(A1,A2,B1,B2) ;
+OAI22_X{1,2,4} input(A1,A2,B1,B2) output(ZN) ZN=OAI22(A1,A2,B1,B2) ;
+
+OAI211_X{1,2,4} input(A,B,C1,C2) output(ZN) ZN=OAI211(C1,C2,A,B)   ;
+AOI211_X{1,2,4} input(A,B,C1,C2) output(ZN) ZN=AOI211(C1,C2,A,B)   ;
+
+MUX2_X{1,2} input(A,B,S) output(Z) Z=MUX21(A,B,S) ;
+
+AOI221_X{1,2,4} input(A,B1,B2,C1,C2) output(ZN) BC=AO22(B1,B2,C1,C2) ZN=NOR2(BC,A)  ;
+OAI221_X{1,2,4} input(A,B1,B2,C1,C2) output(ZN) BC=OA22(B1,B2,C1,C2) ZN=NAND2(BC,A) ;
+
+AOI222_X{1,2,4} input(A1,A2,B1,B2,C1,C2) output(ZN) BC=AO22(B1,B2,C1,C2) ZN=AOI21(A1,A2,BC) ;
+OAI222_X{1,2,4} input(A1,A2,B1,B2,C1,C2) output(ZN) BC=OA22(B1,B2,C1,C2) ZN=OAI21(A1,A2,BC) ;
+
+OAI33_X1 input(A1,A2,A3,B1,B2,B3) output(ZN) AA=OR2(A1,A2) BB=OR2(B1,B2) ZN=OAI22(AA,A3,BB,B3) ;
+
+HA_X1 input(A,B) output(CO,S) CO=XOR2(A,B) S=AND2(A,B) ;
+
+FA_X1 input(A,B,CI) output(CO,S) AB=XOR2(A,B) CO=XOR2(AB,CI) S=AO22(CI,A,B) ;
+
+CLKGATE_X{1,2,4,8} input(CK,E) output(GCK) GCK=AND2(CK,E) ;
+
+CLKGATETST_X{1,2,4,8} input(CK,E,SE) output(GCK) GCK=OA21(CK,E,SE) ;
+
+DFF_X{1,2}   input(D,CK)       output(Q,QN)  Q=DFF(D,CK) QN=INV1(Q) ;
+DFFR_X{1,2}  input(D,RN,CK)    output(Q,QN)  DR=AND2(D,RN) Q=DFF(DR,CK) QN=INV1(Q) ;
+DFFS_X{1,2}  input(D,SN,CK)    output(Q,QN)  S=INV1(SN) DS=OR2(D,S) Q=DFF(DS,CK) QN=INV1(Q) ;
+DFFRS_X{1,2} input(D,RN,SN,CK) output(Q,QN)  S=INV1(SN) DS=OR2(D,S) DRS=AND2(DS,RN) Q=DFF(DRS,CK) QN=INV1(Q) ;
+
+SDFF_X{1,2}   input(D,SE,SI,CK)       output(Q,QN)  DI=MUX21(D,SI,SE) Q=DFF(DI,CK) QN=INV1(Q) ;
+SDFFR_X{1,2}  input(D,RN,SE,SI,CK)    output(Q,QN)  DR=AND2(D,RN) DI=MUX21(DR,SI,SE) Q=DFF(DI,CK) QN=INV1(Q) ;
+SDFFS_X{1,2}  input(D,SE,SI,SN,CK)    output(Q,QN)  S=INV1(SN) DS=OR2(D,S) DI=MUX21(DS,SI,SE) Q=DFF(DI,CK) QN=INV1(Q) ;
+SDFFRS_X{1,2} input(D,RN,SE,SI,SN,CK) output(Q,QN)  S=INV1(SN) DS=OR2(D,S) DRS=AND2(DS,RN) DI=MUX21(DRS,SI,SE) Q=DFF(DI,CK) QN=INV1(Q) ;
+
+TBUF_X{1,2,4,8,16} input(A,EN)   output(Z)  Z=BUF1(A)    ;
+TINV_X1            input(I,EN)   output(ZN) ZN=INV1(I)   ;
+TLAT_X1            input(D,G,OE) output(Q)  Q=LATCH(D,G) ;
+
+DLH_X{1,2} input(D,G) output(Q)  Q=LATCH(D,G)            ;
+DLL_X{1,2} input(D,GN) output(Q) G=INV1(GN) Q=LATCH(D,G) ;
+"""
+
+
+NANGATE = TechLib(_nangate_common + r"""
+INV_X{1,2,4,8,16,32}  input(I) output(ZN) ZN=INV1(I) ;
+
+AND2_X{1,2,4}  input(A1,A2)       output(Z)  Z=AND2(A1,A2)        ;
+AND3_X{1,2,4}  input(A1,A2,A3)    output(Z)  Z=AND3(A1,A2,A3)     ;
+AND4_X{1,2,4}  input(A1,A2,A3,A4) output(Z)  Z=AND4(A1,A2,A3,A4)  ;
+OR2_X{1,2,4}   input(A1,A2)       output(Z)  Z=OR2(A1,A2)         ;
+OR3_X{1,2,4}   input(A1,A2,A3)    output(Z)  Z=OR3(A1,A2,A3)      ;
+OR4_X{1,2,4}   input(A1,A2,A3,A4) output(Z)  Z=OR4(A1,A2,A3,A4)   ;
+XOR2_X{1,2}    input(A1,A2)       output(Z)  Z=XOR2(A1,A2)        ;
+XNOR2_X{1,2}   input(A1,A2)       output(ZN) ZN=XNOR2(A1,A2)      ;
+""")
+"""An newer NANGATE-variant that uses 'Z' as output pin names for AND and OR gates.
+"""
+
+
+NANGATE_ZN = TechLib(_nangate_common + r"""
+INV_X{1,2,4,8,16,32}  input(A) output(ZN) ZN=INV1(A) ;
+
+AND2_X{1,2,4}  input(A1,A2)       output(ZN) ZN=AND2(A1,A2)        ;
+AND3_X{1,2,4}  input(A1,A2,A3)    output(ZN) ZN=AND3(A1,A2,A3)     ;
+AND4_X{1,2,4}  input(A1,A2,A3,A4) output(ZN) ZN=AND4(A1,A2,A3,A4)  ;
+OR2_X{1,2,4}   input(A1,A2)       output(ZN) ZN=OR2(A1,A2)         ;
+OR3_X{1,2,4}   input(A1,A2,A3)    output(ZN) ZN=OR3(A1,A2,A3)      ;
+OR4_X{1,2,4}   input(A1,A2,A3,A4) output(ZN) ZN=OR4(A1,A2,A3,A4)   ;
+XOR2_X{1,2}    input(A,B)         output(Z)  Z=XOR2(A,B)           ;
+XNOR2_X{1,2}   input(A,B)         output(ZN) ZN=XNOR2(A,B)         ;
+""")
+"""An older NANGATE-variant that uses 'ZN' as output pin names for AND and OR gates.
+"""
+
+
+SAED32 = TechLib(r"""
+NBUFFX{2,4,8,16,32}$ input(A) output(Y) Y=BUF1(A) ;
+AOBUFX{1,2,4}$       input(A) output(Y) Y=BUF1(A) ;
+DELLN{1,2,3}X2$      input(A) output(Y) Y=BUF1(A) ;
+
+INVX{0,1,2,4,8,16,32}$ input(A) output(Y) Y=INV1(A) ;
+AOINVX{1,2,4}$         input(A) output(Y) Y=INV1(A) ;
+IBUFFX{2,4,8,16,32}$   input(A) output(Y) Y=INV1(A) ;
+
+TIEH$ output(Y) Y=__const1__() ;
+TIEL$ output(Y) Y=__const0__() ;
+
+HEAD2X{2,4,8,16,32}$ input(SLEEP) output(SLEEPOUT) SLEEPOUT=BUF1(SLEEP) ;
+HEADX{2,4,8,16,32}$  input(SLEEP) ;
+
+FOOT2X{2,4,8,16,32}$ input(SLEEP) output(SLEEPOUT) SLEEPOUT=BUF1(SLEEP) ;
+FOOTX{2,4,8,16,32}$  input(SLEEP) ;
+
+ANTENNA$ input(INP)   ;
+CLOAD1$  input(A)     ;
+DCAP$                 ;
+DHFILLH2$             ;
+DHFILLHL2$            ;
+DHFILLHLHLS11$        ;
+SHFILL{1,2,3,64,128}$ ;
+
+AND2X{1,2,4}$    input(A1,A2)       output(Y) Y=AND2(A1,A2)        ;
+AND3X{1,2,4}$    input(A1,A2,A3)    output(Y) Y=AND3(A1,A2,A3)     ;
+AND4X{1,2,4}$    input(A1,A2,A3,A4) output(Y) Y=AND4(A1,A2,A3,A4)  ;
+OR2X{1,2,4}$     input(A1,A2)       output(Y) Y=OR2(A1,A2)         ;
+OR3X{1,2,4}$     input(A1,A2,A3)    output(Y) Y=OR3(A1,A2,A3)      ;
+OR4X{1,2,4}$     input(A1,A2,A3,A4) output(Y) Y=OR4(A1,A2,A3,A4)   ;
+XOR2X{1,2}$      input(A1,A2)       output(Y) Y=XOR2(A1,A2)        ;
+XOR3X{1,2}$      input(A1,A2,A3)    output(Y) Y=XOR3(A1,A2,A3)     ;
+NAND2X{0,1,2,4}$ input(A1,A2)       output(Y) Y=NAND2(A1,A2)       ;
+NAND3X{0,1,2,4}$ input(A1,A2,A3)    output(Y) Y=NAND3(A1,A2,A3)    ;
+NAND4X{0,1}$     input(A1,A2,A3,A4) output(Y) Y=NAND4(A1,A2,A3,A4) ;
+NOR2X{0,1,2,4}$  input(A1,A2)       output(Y) Y=NOR2(A1,A2)        ;
+NOR3X{0,1,2,4}$  input(A1,A2,A3)    output(Y) Y=NOR3(A1,A2,A3)     ;
+NOR4X{0,1}$      input(A1,A2,A3,A4) output(Y) Y=NOR4(A1,A2,A3,A4)  ;
+XNOR2X{1,2}$     input(A1,A2)       output(Y) Y=XNOR2(A1,A2)       ;
+XNOR3X{1,2}$     input(A1,A2,A3)    output(Y) Y=XNOR3(A1,A2,A3)    ;
+
+ISOLAND{,AO}X{1,2,4,8}$ input(ISO,D) output(Q) ISOB=NOT1(ISO) Q=AND2(ISOB,D) ;
+ISOLOR{,AO}X{1,2,4,8}$  input(ISO,D) output(Q) Q=OR2(ISO,D)  ;
+
+AO21X{1,2}$  input(A1,A2,A3) output(Y) Y=AO21(A1,A2,A3)  ;
+OA21X{1,2}$  input(A1,A2,A3) output(Y) Y=OA21(A1,A2,A3)  ;
+AOI21X{1,2}$ input(A1,A2,A3) output(Y) Y=AOI21(A1,A2,A3) ;
+OAI21X{1,2}$ input(A1,A2,A3) output(Y) Y=OAI21(A1,A2,A3) ;
+
+AO22X{1,2}$  input(A1,A2,A3,A4) output(Y) Y=AO22(A1,A2,A3,A4)  ;
+OA22X{1,2}$  input(A1,A2,A3,A4) output(Y) Y=OA22(A1,A2,A3,A4)  ;
+AOI22X{1,2}$ input(A1,A2,A3,A4) output(Y) Y=AOI22(A1,A2,A3,A4) ;
+OAI22X{1,2}$ input(A1,A2,A3,A4) output(Y) Y=OAI22(A1,A2,A3,A4) ;
+
+MUX21X{1,2}$ input(A1,A2,S0) output(Y) Y=MUX21(A1,A2,S0) ;
+
+AO221X{1,2}$  input(A1,A2,A3,A4,A5) output(Y) A=AO22(A1,A2,A3,A4) Y=OR2(A5,A)   ;
+OA221X{1,2}$  input(A1,A2,A3,A4,A5) output(Y) A=OA22(A1,A2,A3,A4) Y=AND2(A5,A)  ;
+AOI221X{1,2}$ input(A1,A2,A3,A4,A5) output(Y) A=AO22(A1,A2,A3,A4) Y=NOR2(A5,A)  ;
+OAI221X{1,2}$ input(A1,A2,A3,A4,A5) output(Y) A=OA22(A1,A2,A3,A4) Y=NAND2(A5,A) ;
+
+AO222X{1,2}$ input(A1,A2,A3,A4,A5,A6)  output(Y) A=AO22(A1,A2,A3,A4) Y=AO21(A5,A6,A)  ;
+OA222X{1,2}$ input(A1,A2,A3,A4,A5,A6)  output(Y) A=OA22(A1,A2,A3,A4) Y=OA21(A5,A6,A)  ;
+AOI222X{1,2}$ input(A1,A2,A3,A4,A5,A6) output(Y) A=AO22(A1,A2,A3,A4) Y=AOI21(A5,A6,A) ;
+OAI222X{1,2}$ input(A1,A2,A3,A4,A5,A6) output(Y) A=OA22(A1,A2,A3,A4) Y=OAI21(A5,A6,A) ;
+
+MUX41X{1,2}$ input(A1,A2,A3,A4,S0,S1) output(Y) A=MUX21(A1,A2,S0) B=MUX21(A3,A4,S0) Y=MUX21(A,B,S1) ;
+
+DEC24X{1,2}$ input(A0,A1) output(Y0,Y1,Y2,Y3) A0B=INV1(A0) A1B=INV1(A1) Y0=NOR2(A0,A1) Y1=AND(A0,A1B) Y2=AND(A0B,A1) Y3=AND(A0,A1) ;
+FADDX{1,2}$ input(A,B,CI) output(S,CO) AB=XOR2(A,B) CO=XOR2(AB,CI) S=AO22(AB,CI,A,B) ;
+HADDX{1,2}$ input(A0,B0) output(SO,C1) C1=XOR2(A0,B0) SO=AND2(A0,B0) ;
+
+{,AO}DFFARX{1,2}$ input(D,CLK,RSTB)      output(Q,QN) DR=AND2(D,RSTB) Q=DFF(DR,CLK) QN=INV1(Q) ;
+DFFASRX{1,2}$     input(D,CLK,RSTB,SETB) output(Q,QN) DR=AND2(D,RSTB) SET=INV1(SETB) DRS=OR2(DR,SET) Q=DFF(DRS,CLK) QN=INV1(Q) ;
+DFFASX{1,2}$      input(D,CLK,SETB)      output(Q,QN) SET=INV1(SETB) DS=OR2(D,SET) Q=DFF(DS,CLK) QN=INV1(Q) ;
+DFFSSRX{1,2}$     input(CLK,D,RSTB,SETB) output(Q,QN) DR=AND2(D,RSTB) SET=INV1(SETB) DRS=OR2(DR,SET) Q=DFF(DRS,CLK) QN=INV1(Q) ;
+DFFX{1,2}$        input(D,CLK)           output(Q,QN) Q=DFF(D,CLK) QN=INV1(Q) ;
+
+SDFFARX{1,2}$   input(D,CLK,RSTB,SE,SI)      output(Q,QN) DR=AND2(D,RSTB) DI=MUX21(DR,SI,SE) Q=DFF(DI,CLK) QN=INV1(Q) ;
+SDFFASRSX{1,2}$ input(D,CLK,RSTB,SETB,SE,SI) output(Q,QN,SO) DR=AND2(D,RSTB) SET=INV1(SETB) DRS=OR2(DR,SET) DI=MUX21(DRS,SI,SE) Q=DFF(DI,CLK) QN=INV1(Q) SO=BUF1(Q) ;
+SDFFASRX{1,2}$  input(D,CLK,RSTB,SETB,SE,SI) output(Q,QN) DR=AND2(D,RSTB) SET=INV1(SETB) DRS=OR2(DR,SET) DI=MUX21(DRS,SI,SE) Q=DFF(DI,CLK) QN=INV1(Q) ;
+SDFFASX{1,2}$   input(D,CLK,SETB,SE,SI)      output(Q,QN) SET=INV1(SETB) DS=OR2(D,SET) DI=MUX21(DS,SI,SE) Q=DFF(DI,CLK) QN=INV1(Q) ;
+SDFFSSRX{1,2}$  input(CLK,D,RSTB,SETB,SI,SE) output(Q,QN) DR=AND2(D,RSTB) SET=INV1(SETB) DRS=OR2(DR,SET) DI=MUX21(DRS,SI,SE) Q=DFF(DI,CLK) QN=INV1(Q) ;
+SDFFX{1,2}$     input(D,CLK,SE,SI)           output(Q,QN) DI=MUX21(D,SI,SE) Q=DFF(DI,CLK) QN=INV1(Q) ;
+
+LATCHX{1,2}$ input(D,CLK) output(Q,QN) Q=LATCH(D,CLK) QN=INV1(Q) ;
+""".replace('$','_RVT'))
+"""The SAED 32nm educational technology library.
+It defines all cells except: negative-edge flip-flops, tri-state, latches, clock gating, level shifters
+"""
+
+
+SAED90 = TechLib(r"""
+NBUFFX{2,4,8,16,32}$ input(INP) output(Z) Z=BUF1(INP) ;
+AOBUFX{1,2,4}$       input(INP) output(Z) Z=BUF1(INP) ;
+DELLN{1,2,3}X2$      input(INP) output(Z)Z=BUF1(INP) ;
+
+INVX{0,1,2,4,8,16,32}$ input(INP) output(ZN) ZN=INV1(INP) ;
+AOINVX{1,2,4}$         input(INP) output(ZN) ZN=INV1(INP) ;
+IBUFFX{2,4,8,16,32}$   input(INP) output(ZN) ZN=INV1(INP) ;
+
+TIEH$ output(Z)   Z=__const1__() ;
+TIEL$ output(ZN) ZN=__const0__() ;
+
+HEAD2X{2,4,8,16,32}$ input(SLEEP) output(SLEEPOUT) SLEEPOUT=BUF1(SLEEP) ;
+HEADX{2,4,8,16,32}$  input(SLEEP) ;
+
+ANTENNA$ input(INP)   ;
+CLOAD1$  input(INP)   ;
+DCAP$                 ;
+DHFILL{HLH,LHL}2      ;
+DHFILLHLHLS11$        ;
+SHFILL{1,2,3,64,128}$ ;
+
+AND2X{1,2,4}$    input(IN1,IN2)         output(Q)   Q=AND2(IN1,IN2)          ;
+AND3X{1,2,4}$    input(IN1,IN2,IN3)     output(Q)   Q=AND3(IN1,IN2,IN3)      ;
+AND4X{1,2,4}$    input(IN1,IN2,IN3,IN4) output(Q)   Q=AND4(IN1,IN2,IN3,IN4)  ;
+OR2X{1,2,4}$     input(IN1,IN2)         output(Q)   Q=OR2(IN1,IN2)           ;
+OR3X{1,2,4}$     input(IN1,IN2,IN3)     output(Q)   Q=OR3(IN1,IN2,IN3)       ;
+OR4X{1,2,4}$     input(IN1,IN2,IN3,IN4) output(Q)   Q=OR4(IN1,IN2,IN3,IN4)   ;
+XOR2X{1,2}$      input(IN1,IN2)         output(Q)   Q=XOR2(IN1,IN2)          ;
+XOR3X{1,2}$      input(IN1,IN2,IN3)     output(Q)   Q=XOR3(IN1,IN2,IN3)      ;
+NAND2X{0,1,2,4}$ input(IN1,IN2)         output(QN) QN=NAND2(IN1,IN2)         ;
+NAND3X{0,1,2,4}$ input(IN1,IN2,IN3)     output(QN) QN=NAND3(IN1,IN2,IN3)     ;
+NAND4X{0,1}$     input(IN1,IN2,IN3,IN4) output(QN) QN=NAND4(IN1,IN2,IN3,IN4) ;
+NOR2X{0,1,2,4}$  input(IN1,IN2)         output(QN) QN=NOR2(IN1,IN2)          ;
+NOR3X{0,1,2,4}$  input(IN1,IN2,IN3)     output(QN) QN=NOR3(IN1,IN2,IN3)      ;
+NOR4X{0,1}$      input(IN1,IN2,IN3,IN4) output(QN) QN=NOR4(IN1,IN2,IN3,IN4)  ;
+XNOR2X{1,2}$     input(IN1,IN2)         output(Q)   Q=XNOR2(IN1,IN2)         ;
+XNOR3X{1,2}$     input(IN1,IN2,IN3)     output(Q)   Q=XNOR3(IN1,IN2,IN3)     ;
+
+ISOLAND{,AO}X{1,2,4,8}$ input(ISO,D) output(Q) ISOB=NOT1(ISO) Q=AND2(ISOB,D) ;
+ISOLOR{,AO}X{1,2,4,8}$  input(ISO,D) output(Q) Q=OR2(ISO,D)  ;
+
+AO21X{1,2}$  input(IN1,IN2,IN3) output(Q)   Q=AO21(IN1,IN2,IN3)  ;
+OA21X{1,2}$  input(IN1,IN2,IN3) output(Q)   Q=OA21(IN1,IN2,IN3)  ;
+AOI21X{1,2}$ input(IN1,IN2,IN3) output(QN) QN=AOI21(IN1,IN2,IN3) ;
+OAI21X{1,2}$ input(IN1,IN2,IN3) output(QN) QN=OAI21(IN1,IN2,IN3) ;
+
+AO22X{1,2}$  input(IN1,IN2,IN3,IN4) output(Q)   Q=AO22(IN1,IN2,IN3,IN4)  ;
+OA22X{1,2}$  input(IN1,IN2,IN3,IN4) output(Q)   Q=OA22(IN1,IN2,IN3,IN4)  ;
+AOI22X{1,2}$ input(IN1,IN2,IN3,IN4) output(QN) QN=AOI22(IN1,IN2,IN3,IN4) ;
+OAI22X{1,2}$ input(IN1,IN2,IN3,IN4) output(QN) QN=OAI22(IN1,IN2,IN3,IN4) ;
+
+MUX21X{1,2}$ input(IN1,IN2,S) output(Q) Q=MUX21(IN1,IN2,S) ;
+
+AO221X{1,2}$  input(IN1,IN2,IN3,IN4,IN5) output(Q)  A=AO22(IN1,IN2,IN3,IN4)  Q=OR2(IN5,A)   ;
+OA221X{1,2}$  input(IN1,IN2,IN3,IN4,IN5) output(Q)  A=OA22(IN1,IN2,IN3,IN4)  Q=AND2(IN5,A)  ;
+AOI221X{1,2}$ input(IN1,IN2,IN3,IN4,IN5) output(QN) A=AO22(IN1,IN2,IN3,IN4) QN=NOR2(IN5,A)  ;
+OAI221X{1,2}$ input(IN1,IN2,IN3,IN4,IN5) output(QN) A=OA22(IN1,IN2,IN3,IN4) QN=NAND2(IN5,A) ;
+
+AO222X{1,2}$ input(IN1,IN2,IN3,IN4,IN5,IN6)  output(Q)  A=AO22(IN1,IN2,IN3,IN4)  Q=AO21(IN5,IN6,A)  ;
+OA222X{1,2}$ input(IN1,IN2,IN3,IN4,IN5,IN6)  output(Q)  A=OA22(IN1,IN2,IN3,IN4)  Q=OA21(IN5,IN6,A)  ;
+AOI222X{1,2}$ input(IN1,IN2,IN3,IN4,IN5,IN6) output(QN) A=AO22(IN1,IN2,IN3,IN4) QN=AOI21(IN5,IN6,A) ;
+OAI222X{1,2}$ input(IN1,IN2,IN3,IN4,IN5,IN6) output(QN) A=OA22(IN1,IN2,IN3,IN4) QN=OAI21(IN5,IN6,A) ;
+
+MUX41X{1,2}$ input(IN1,IN2,IN3,IN4,S0,S1) output(Q) A=MUX21(IN1,IN2,S0) B=MUX21(IN3,IN4,S0) Q=MUX21(A,B,S1) ;
+
+DEC24X{1,2}$ input(IN1,IN2) output(Q0,Q1,Q2,Q3) IN1B=INV1(IN1) IN2B=INV1(IN2) Q0=NOR2(IN1,IN2) Q1=AND(IN1,IN2B) Q2=AND(IN1B,IN2) Q3=AND(IN1,IN2) ;
+FADDX{1,2}$ input(A,B,CI) output(S,CO) AB=XOR2(A,B) CO=XOR2(AB,CI) S=AO22(AB,CI,A,B) ;
+HADDX{1,2}$ input(A0,B0) output(SO,C1) C1=XOR2(A0,B0) SO=AND2(A0,B0) ;
+
+{,AO}DFFARX{1,2}$ input(D,CLK,RSTB)      output(Q,QN) DR=AND2(D,RSTB) Q=DFF(DR,CLK) QN=INV1(Q) ;
+DFFASRX{1,2}$     input(D,CLK,RSTB,SETB) output(Q,QN) DR=AND2(D,RSTB) SET=INV1(SETB) DRS=OR2(DR,SET) Q=DFF(DRS,CLK) QN=INV1(Q) ;
+DFFASX{1,2}$      input(D,CLK,SETB)      output(Q,QN) SET=INV1(SETB) DS=OR2(D,SET) Q=DFF(DS,CLK) QN=INV1(Q) ;
+DFFSSRX{1,2}$     input(CLK,D,RSTB,SETB) output(Q,QN) DR=AND2(D,RSTB) SET=INV1(SETB) DRS=OR2(DR,SET) Q=DFF(DRS,CLK) QN=INV1(Q) ;
+DFFX{1,2}$        input(D,CLK)           output(Q,QN) Q=DFF(D,CLK) QN=INV1(Q) ;
+
+SDFFARX{1,2}$   input(D,CLK,RSTB,SE,SI)      output(Q,QN) DR=AND2(D,RSTB) DI=MUX21(DR,SI,SE) Q=DFF(DI,CLK) QN=INV1(Q) ;
+SDFFASRSX{1,2}$ input(D,CLK,RSTB,SETB,SE,SI) output(Q,QN,S0) DR=AND2(D,RSTB) SET=INV1(SETB) DRS=OR2(DR,SET) DI=MUX21(DRS,SI,SE) Q=DFF(DI,CLK) QN=INV1(Q) S0=BUF1(Q) ;
+SDFFASRX{1,2}$  input(D,CLK,RSTB,SETB,SE,SI) output(Q,QN) DR=AND2(D,RSTB) SET=INV1(SETB) DRS=OR2(DR,SET) DI=MUX21(DRS,SI,SE) Q=DFF(DI,CLK) QN=INV1(Q) ;
+SDFFASX{1,2}$   input(D,CLK,SETB,SE,SI)      output(Q,QN) SET=INV1(SETB) DS=OR2(D,SET) DI=MUX21(DS,SI,SE) Q=DFF(DI,CLK) QN=INV1(Q) ;
+SDFFSSRX{1,2}$  input(CLK,D,RSTB,SETB,SI,SE) output(Q,QN) DR=AND2(D,RSTB) SET=INV1(SETB) DRS=OR2(DR,SET) DI=MUX21(DRS,SI,SE) Q=DFF(DI,CLK) QN=INV1(Q) ;
+SDFFX{1,2}$     input(D,CLK,SE,SI)           output(Q,QN) DI=MUX21(D,SI,SE) Q=DFF(DI,CLK) QN=INV1(Q) ;
+
+LATCHX{1,2}$ input(D,CLK) output(Q,QN) Q=LATCH(D,CLK) QN=INV1(Q) ;
+""".replace('$','{,_LVT,_HVT}'))
+"""The SAED 90nm educational technology library.
+It defines all cells except: negative-edge flip-flops, tri-state, latches, clock gating, level shifters
+"""
```

## kyupy/verilog.py

```diff
@@ -1,176 +1,260 @@
 """A simple and incomplete parser for Verilog files.
 
 The main purpose of this parser is to load synthesized, non-hierarchical (flat) gate-level netlists.
-It supports only a very limited subset of Verilog.
+It supports only a subset of Verilog.
 """
 
 from collections import namedtuple
 
-from lark import Lark, Transformer
+from lark import Lark, Transformer, Tree
 
-from . import readtext
+from . import log, readtext
 from .circuit import Circuit, Node, Line
-from .techlib import TechLib
+from .techlib import NANGATE
 
 Instantiation = namedtuple('Instantiation', ['type', 'name', 'pins'])
 
 
 class SignalDeclaration:
 
-    def __init__(self, kind, tokens):
+    def __init__(self, kind, name, rnge=None):
         self.left = None
         self.right = None
         self.kind = kind
-        if len(tokens.children) == 1:
-            self.basename = tokens.children[0]
-        else:
-            self.basename = tokens.children[2]
-            self.left = int(tokens.children[0].value)
-            self.right = int(tokens.children[1].value)
+        self.basename = name
+        self.rnge = rnge
 
     @property
     def names(self):
-        if self.left is None:
+        if self.rnge is None:
             return [self.basename]
-        if self.left <= self.right:
-            return [f'{self.basename}[{i}]' for i in range(self.left, self.right + 1)]
-        return [f'{self.basename}[{i}]' for i in range(self.left, self.right - 1, -1)]
+        return [f'{self.basename}[{i}]' for i in self.rnge]
 
     def __repr__(self):
-        return f"{self.kind}:{self.basename}[{self.left}:{self.right}]"
+        return f"{self.kind}:{self.basename}[{self.rnge}]"
 
 
 class VerilogTransformer(Transformer):
-    def __init__(self, branchforks=False, tlib=TechLib()):
+    def __init__(self, branchforks=False, tlib=NANGATE):
         super().__init__()
-        self._signal_declarations = {}
         self.branchforks = branchforks
         self.tlib = tlib
 
     @staticmethod
     def name(args):
         s = args[0].value
-        if s[0] == '\\':
-            s = s[1:-1]
-        return s
+        return s[1:-1] if s[0] == '\\' else s
+
+    @staticmethod
+    def namedpin(args):
+        return tuple(args) if len(args) > 1 else (args[0], None)
 
     @staticmethod
     def instantiation(args):
-        return Instantiation(args[0], args[1],
-                             dict((pin.children[0], pin.children[1]) for pin in args[2:]))
+        pinmap = {}
+        for idx, pin in enumerate(args[2:]):
+            p = pin.children[0]
+            if isinstance(p, tuple):  # named pin
+                if p[1] is not None:
+                    pinmap[p[0]] = p[1]
+            else:  # unnamed pin
+                pinmap[idx] = p
+        return Instantiation(args[0], args[1], pinmap)
+
+    def range(self, args):
+        left = int(args[0].value)
+        right = int(args[1].value) if len(args) > 1 else left
+        return range(left, right+1) if left <= right else range(left, right-1, -1)
+
+    def sigsel(self, args):
+        if len(args) > 1 and isinstance(args[1], range):
+            l = [f'{args[0]}[{i}]' for i in args[1]]
+            return l if len(l) > 1 else l[0]
+        elif "'" in args[0]:
+            width, rest = args[0].split("'")
+            width = int(width)
+            base, const = rest[0], rest[1:]
+            const = int(const, {'b': 2, 'd':10, 'h':16}[base.lower()])
+            l = []
+            for _ in range(width):
+                l.insert(0, "1'b1" if (const & 1) else "1'b0")
+                const >>= 1
+            return l if len(l) > 1 else l[0]
+        else:
+            return args[0]
 
-    def input(self, args):
-        for sd in [SignalDeclaration('input', signal) for signal in args]:
-            self._signal_declarations[sd.basename] = sd
-
-    def inout(self, args):
-        for sd in [SignalDeclaration('input', signal) for signal in args]:  # just treat as input
-            self._signal_declarations[sd.basename] = sd
-
-    def output(self, args):
-        for sd in [SignalDeclaration('output', signal) for signal in args]:
-            self._signal_declarations[sd.basename] = sd
-
-    def wire(self, args):
-        for sd in [SignalDeclaration('wire', signal) for signal in args]:
-            self._signal_declarations[sd.basename] = sd
+    def concat(self, args):
+        sigs = []
+        for a in args:
+            if isinstance(a, list):
+                sigs += a
+            else:
+                sigs.append(a)
+        return sigs
+
+    def declaration(self, kind, args):
+        rnge = None
+        if isinstance(args[0], range):
+            rnge = args[0]
+            args = args[1:]
+        return [SignalDeclaration(kind, signal, rnge) for signal in args]
+
+    def input(self, args): return self.declaration("input", args)
+    def output(self, args): return self.declaration("output", args)
+    def inout(self, args): return self.declaration("input", args)  # just treat as input
+    def wire(self, args): return self.declaration("wire", args)
 
     def module(self, args):
         c = Circuit(args[0])
         positions = {}
         pos = 0
+        const_count = 0
+        sig_decls = {}
+        for decls in args[2:]:  # pass 0: collect signal declarations
+            if isinstance(decls, list):
+                if len(decls) > 0 and isinstance(decls[0], SignalDeclaration):
+                    for decl in decls:
+                        if decl.basename not in sig_decls or sig_decls[decl.basename].kind == 'wire':
+                            sig_decls[decl.basename] = decl
         for intf_sig in args[1].children:
-            for name in self._signal_declarations[intf_sig].names:
+            for name in sig_decls[intf_sig].names:
                 positions[name] = pos
                 pos += 1
         assignments = []
         for stmt in args[2:]:  # pass 1: instantiate cells and driven signals
             if isinstance(stmt, Instantiation):
                 n = Node(c, stmt.name, kind=stmt.type)
                 for p, s in stmt.pins.items():
                     if self.tlib.pin_is_output(n.kind, p):
+                        if s in sig_decls:
+                            s = sig_decls[s].names
+                            if isinstance(s, list) and len(s) == 1:
+                                s = s[0]
                         Line(c, (n, self.tlib.pin_index(stmt.type, p)), Node(c, s))
-            elif stmt is not None and stmt.data == 'assign':
+            elif hasattr(stmt, 'data') and stmt.data == 'assign':
                 assignments.append((stmt.children[0], stmt.children[1]))
-        for sd in self._signal_declarations.values():
+        for sd in sig_decls.values():
             if sd.kind == 'output' or sd.kind == 'input':
                 for name in sd.names:
                     n = Node(c, name, kind=sd.kind)
                     if name in positions:
-                        c.interface[positions[name]] = n
+                        c.io_nodes[positions[name]] = n
                     if sd.kind == 'input':
                         Line(c, n, Node(c, name))
-        for s1, s2 in assignments:  # pass 1.5: process signal assignments
-            if s1 in c.forks:
-                assert s2 not in c.forks, 'assignment between two driven signals'
-                Line(c, c.forks[s1], Node(c, s2))
-            elif s2 in c.forks:
-                assert s1 not in c.forks, 'assignment between two driven signals'
-                Line(c, c.forks[s2], Node(c, s1))
+        for target, source in assignments:  # pass 1.5: process signal assignments
+            target_sigs = []
+            if not isinstance(target, list): target = [target]
+            for s in target:
+                if s in sig_decls:
+                    target_sigs += sig_decls[s].names
+                else:
+                    target_sigs.append(s)
+            source_sigs = []
+            if not isinstance(source, list): source = [source]
+            for s in source:
+                if s in sig_decls:
+                    source_sigs += sig_decls[s].names
+                else:
+                    source_sigs.append(s)
+            for t, s in zip(target_sigs, source_sigs):
+                if t in c.forks:
+                    assert s not in c.forks, 'assignment between two driven signals'
+                    Line(c, c.forks[t], Node(c, s))
+                elif s in c.forks:
+                    assert t not in c.forks, 'assignment between two driven signals'
+                    Line(c, c.forks[s], Node(c, t))
+                elif s.startswith("1'b"):
+                    cnode = Node(c, f'__const{s[3]}_{const_count}__', f'__const{s[3]}__')
+                    const_count += 1
+                    Line(c, cnode, Node(c, t))
         for stmt in args[2:]:  # pass 2: connect signals to readers
             if isinstance(stmt, Instantiation):
                 for p, s in stmt.pins.items():
                     n = c.cells[stmt.name]
                     if self.tlib.pin_is_output(n.kind, p): continue
                     if s.startswith("1'b"):
-                        const = f'__const{s[3]}__'
-                        if const not in c.cells:
-                            Line(c, Node(c, const, const), Node(c, s))
+                        cname = f'__const{s[3]}_{const_count}__'
+                        cnode = Node(c, cname, f'__const{s[3]}__')
+                        const_count += 1
+                        s = cname
+                        Line(c, cnode, Node(c, s))
+                    if s not in c.forks:
+                        if f'{s}[0]' in c.forks:  # actually a 1-bit bus?
+                            s = f'{s}[0]'
+                        else:
+                            log.warn(f'Signal not driven: {s}')
+                            Node(c, s)  # generate fork here
                     fork = c.forks[s]
                     if self.branchforks:
                         branchfork = Node(c, fork.name + "~" + n.name + "/" + p)
                         Line(c, fork, branchfork)
                         fork = branchfork
                     Line(c, fork, (n, self.tlib.pin_index(stmt.type, p)))
-        for sd in self._signal_declarations.values():
+        for sd in sig_decls.values():
             if sd.kind == 'output':
                 for name in sd.names:
+                    if name not in c.forks:
+                        if f'{name}[0]' in c.forks:  # actually a 1-bit bus?
+                            name = f'{name}[0]'
+                        else:
+                            log.warn(f'Output not driven: {name}')
+                            continue
                     Line(c, c.forks[name], c.cells[name])
         return c
 
     @staticmethod
     def start(args): return args[0] if len(args) == 1 else args
 
 
-GRAMMAR = """
+GRAMMAR = r"""
     start: (module)*
     module: "module" name parameters ";" (_statement)* "endmodule"
-    parameters: "(" [ name ( "," name )* ] ")"
+    parameters: "(" [ _namelist ] ")"
     _statement: input | output | inout | tri | wire | assign | instantiation
-    input: "input" signal ( "," signal )* ";"
-    output: "output" signal ( "," signal )* ";"
-    inout: "inout" signal ( "," signal )* ";"
-    tri: "tri" name ";"
-    wire: "wire" signal ( "," signal )* ";"
-    assign: "assign" name "=" name ";"
+    input: "input" range? _namelist ";"
+    output: "output" range? _namelist ";"
+    inout: "inout" range? _namelist ";"
+    tri: "tri" range? _namelist ";"
+    wire: "wire" range? _namelist ";"
+    assign: "assign" sigsel "=" sigsel ";"
     instantiation: name name "(" [ pin ( "," pin )* ] ")" ";"
-    pin: "." name "(" name ")"
-    signal: ( name | "[" /[0-9]+/ ":" /[0-9]+/ "]" name )
-
-    name: ( /[a-z_][a-z0-9_\\[\\]]*/i | /\\\\[^\\t \\r\\n]+[\\t \\r\\n](\\[[0-9]+\\])?/i | /1'b0/i | /1'b1/i )
-    COMMENT: "//" /[^\\n]*/
-    %ignore ( /\\r?\\n/ | COMMENT )+
-    %ignore /[\\t \\f]+/
+    pin: namedpin | sigsel
+    namedpin: "." name "(" sigsel? ")"
+    range: "[" /[0-9]+/ (":" /[0-9]+/)? "]"
+    sigsel: name range? | concat
+    concat: "{" sigsel ( "," sigsel )*  "}"
+    _namelist: name ( "," name )*
+    name: ( /[a-z_][a-z0-9_]*/i | /\\[^\t \r\n]+[\t \r\n]/i | /[0-9]+'[bdh][0-9a-f]+/i )
+    %import common.NEWLINE
+    COMMENT: /\/\*(\*(?!\/)|[^*])*\*\// | /\(\*(\*(?!\))|[^*])*\*\)/ |  "//" /(.)*/ NEWLINE
+    %ignore ( /\r?\n/ | COMMENT )+
+    %ignore /[\t \f]+/
     """
 
 
-def parse(text, *, branchforks=False, tlib=TechLib()):
+def parse(text, tlib=NANGATE, branchforks=False):
     """Parses the given ``text`` as Verilog code.
 
     :param text: A string with Verilog code.
+    :param tlib: A technology library object that defines all known cells.
+    :type tlib: :py:class:`~kyupy.techlib.TechLib`
     :param branchforks: If set to ``True``, the returned circuit will include additional `forks` on each fanout branch.
         These forks are needed to correctly annotate interconnect delays
-        (see :py:func:`kyupy.sdf.DelayFile.annotation`).
-    :param tlib: A technology library object that provides pin name mappings.
-    :type tlib: :py:class:`~kyupy.techlib.TechLib`
-    :return: A :class:`~kyupy.circuit.Circuit` object.
+        (see :py:func:`~kyupy.sdf.DelayFile.interconnects()`).
+    :return: A :py:class:`~kyupy.circuit.Circuit` object.
     """
     return Lark(GRAMMAR, parser="lalr", transformer=VerilogTransformer(branchforks, tlib)).parse(text)
 
 
-def load(file, *args, **kwargs):
+def load(file, tlib=NANGATE, branchforks=False):
     """Parses the contents of ``file`` as Verilog code.
 
-    The given file may be gzip compressed. Takes the same keyword arguments as :py:func:`parse`.
+    :param file: A file name or a file handle. Files with `.gz`-suffix are decompressed on-the-fly.
+    :param tlib: A technology library object that defines all known cells.
+    :type tlib: :py:class:`~kyupy.techlib.TechLib`
+    :param branchforks: If set to ``True``, the returned circuit will include additional `forks` on each fanout branch.
+        These forks are needed to correctly annotate interconnect delays
+        (see :py:func:`~kyupy.sdf.DelayFile.interconnects()`).
+    :return: A :py:class:`~kyupy.circuit.Circuit` object.
     """
-    return parse(readtext(file), *args, **kwargs)
+    return parse(readtext(file), tlib, branchforks)
```

## kyupy/wave_sim.py

```diff
@@ -9,780 +9,462 @@
 The simulators are not event-based and are not capable of simulating sequential circuits directly.
 
 Two simulators are available: :py:class:`WaveSim` runs on the CPU, and the derived class
 :py:class:`WaveSimCuda` runs on the GPU.
 """
 
 import math
-from bisect import bisect, insort_left
 
 import numpy as np
 
-from . import numba, cuda, hr_bytes
+from . import numba, cuda, sim, cdiv
 
 
 TMAX = np.float32(2 ** 127)
 """A large 32-bit floating point value used to mark the end of a waveform."""
 TMAX_OVL = np.float32(1.1 * 2 ** 127)
 """A large 32-bit floating point value used to mark the end of a waveform that
 may be incomplete due to an overflow."""
 TMIN = np.float32(-2 ** 127)
 """A large negative 32-bit floating point value used at the beginning of waveforms that start with logic-1."""
 
 
-class Heap:
-    def __init__(self):
-        self.chunks = dict()  # map start location to chunk size
-        self.released = list()  # chunks that were released
-        self.current_size = 0
-        self.max_size = 0
-
-    def alloc(self, size):
-        for idx, loc in enumerate(self.released):
-            if self.chunks[loc] == size:
-                del self.released[idx]
-                return loc
-            if self.chunks[loc] > size:  # split chunk
-                chunksize = self.chunks[loc]
-                self.chunks[loc] = size
-                self.chunks[loc + size] = chunksize - size
-                self.released[idx] = loc + size  # move released pointer: loc -> loc+size
-                return loc
-        # no previously released chunk; make new one
-        loc = self.current_size
-        self.chunks[loc] = size
-        self.current_size += size
-        self.max_size = max(self.max_size, self.current_size)
-        return loc
-
-    def free(self, loc):
-        size = self.chunks[loc]
-        if loc + size == self.current_size:  # end of managed area, remove chunk
-            del self.chunks[loc]
-            self.current_size -= size
-            # check and remove prev chunk if free
-            if len(self.released) > 0:
-                prev = self.released[-1]
-                if prev + self.chunks[prev] == self.current_size:
-                    chunksize = self.chunks[prev]
-                    del self.chunks[prev]
-                    del self.released[-1]
-                    self.current_size -= chunksize
-            return
-        released_idx = bisect(self.released, loc)
-        if released_idx < len(self.released) and loc + size == self.released[released_idx]:  # next chunk is free, merge
-            chunksize = size + self.chunks[loc + size]
-            del self.chunks[loc + size]
-            self.chunks[loc] = chunksize
-            size = self.chunks[loc]
-            self.released[released_idx] = loc
-        else:
-            insort_left(self.released, loc)  # put in a new release
-        if released_idx > 0:  # check if previous chunk is free
-            prev = self.released[released_idx - 1]
-            if prev + self.chunks[prev] == loc:  # previous chunk is adjacent to freed one, merge
-                chunksize = size + self.chunks[prev]
-                del self.chunks[loc]
-                self.chunks[prev] = chunksize
-                del self.released[released_idx]
-
-    def __repr__(self):
-        r = []
-        for loc in sorted(self.chunks.keys()):
-            size = self.chunks[loc]
-            released_idx = bisect(self.released, loc)
-            is_released = released_idx > 0 and len(self.released) > 0 and self.released[released_idx - 1] == loc
-            r.append(f'{loc:5d}: {"free" if is_released else "used"} {size}')
-        return "\n".join(r)
-
-
-class WaveSim:
+class WaveSim(sim.SimOps):
     """A waveform-based combinational logic timing simulator running on CPU.
 
     :param circuit: The circuit to simulate.
-    :param timing: The timing annotation of the circuit (see :py:func:`kyupy.sdf.DelayFile.annotation` for details)
+    :param delays: One or more delay annotations for the circuit (see :py:func:`kyupy.sdf.DelayFile.iopaths` for details).
+        Each parallel simulation may use the same delays or different delays, depending on the use-case (see :py:attr:`simctl_int`).
     :param sims: The number of parallel simulations.
-    :param wavecaps: The number of floats available in each waveform. Waveforms are encoding the signal switching
-        history by storing transition times. The waveform capacity roughly corresponds to the number of transitions
+    :param c_caps: The number of floats available in each waveform. Values must be positive and a multiple of 4.
+        Waveforms encode the signal switching history by storing transition times.
+        The waveform capacity roughly corresponds to the number of transitions
         that can be stored. A capacity of ``n`` can store at least ``n-2`` transitions. If more transitions are
         generated during simulation, the latest glitch is removed (freeing up two transition times) and an overflow
         flag is set. If an integer is given, all waveforms are set to that same capacity. With an array of length
-        ``len(circuit.lines)`` the capacity can be controlled for each intermediate waveform individually.
+        ``len(circuit.lines)`` the capacity is set individually for each intermediate waveform.
+    :param a_ctrl: An integer array controlling the accumulation of weighted switching activity during simulation.
+        Its shape must be ``(len(circuit.lines), 3)``. ``a_ctrl[...,0]`` is the index into the accumulation buffer, -1 means ignore.
+        ``a_ctrl[...,1]`` is the (integer) weight for a rising transition, ``a_ctrl[...,2]`` is the (integer) weight for
+        a falling transition. The accumulation buffer (:py:attr:`abuf`) is allocated automatically if ``a_ctrl`` is given.
+    :param c_reuse: If enabled, memory of intermediate signal waveforms will be re-used. This greatly reduces
+        memory footprint, but intermediate signal waveforms may become unaccessible after a propagation.
     :param strip_forks: If enabled, the simulator will not evaluate fork nodes explicitly. This saves simulation time
-        by reducing the number of nodes to simulate, but (interconnect) delay annotations of lines read by fork nodes
+        and memory by reducing the number of nodes to simulate, but (interconnect) delay annotations of lines read by fork nodes
         are ignored.
-    :param keep_waveforms: If disabled, memory of intermediate signal waveforms will be re-used. This greatly reduces
-        memory footprint, but intermediate signal waveforms become unaccessible after a propagation.
     """
-    def __init__(self, circuit, timing, sims=8, wavecaps=16, strip_forks=False, keep_waveforms=True):
-        self.circuit = circuit
+    def __init__(self, circuit, delays, sims=8, c_caps=16, a_ctrl=None, c_reuse=False, strip_forks=False):
+        super().__init__(circuit, c_caps=c_caps, c_caps_min=4, a_ctrl=a_ctrl, c_reuse=c_reuse, strip_forks=strip_forks)
         self.sims = sims
-        self.overflows = 0
-        self.interface = list(circuit.interface) + [n for n in circuit.nodes if 'dff' in n.kind.lower()]
-
-        self.lst_eat_valid = False
+        if delays.ndim == 3: delays = np.expand_dims(delays, axis=0)
+        self.delays = np.zeros((len(delays), self.c_locs_len, 2, 2), dtype=delays.dtype)
+        self.delays[:, :delays.shape[1]] = delays
+
+        self.c = np.zeros((self.c_len, sims), dtype=np.float32) + TMAX
+        self.s = np.zeros((11, self.s_len, sims), dtype=np.float32)
+        """Information about the logic values and transitions around the sequential elements (flip-flops) and ports.
+
+        The first 3 values are read by :py:func:`s_to_c`.
+        The remaining values are written by :py:func:`c_to_s`.
+
+        The elements are as follows:
+
+        * ``s[0]`` (P)PI initial value
+        * ``s[1]`` (P)PI transition time
+        * ``s[2]`` (P)PI final value
+        * ``s[3]`` (P)PO initial value
+        * ``s[4]`` (P)PO earliest arrival time (EAT): The time at which the output transitioned from its initial value.
+        * ``s[5]`` (P)PO latest stabilization time (LST): The time at which the output settled to its final value.
+        * ``s[6]`` (P)PO final value
+        * ``s[7]`` (P)PO capture value: probability of capturing a 1 at a given capture time
+        * ``s[8]`` (P)PO sampled capture value: decided by random sampling according to a given seed.
+        * ``s[9]`` (P)PO sampled capture slack: (capture time - LST) - decided by random sampling according to a given seed.
+        * ``s[10]`` Overflow indicator: If non-zero, some signals in the input cone of this output had more
+          transitions than specified in ``c_caps``. Some transitions have been discarded, the
+          final values in the waveforms are still valid.
+        """
 
-        self.cdata = np.zeros((len(self.interface), sims, 7), dtype='float32')
+        self.abuf_len = self.ops[:,6].max() + 1
+        self.abuf = np.zeros((self.abuf_len, sims), dtype=np.int32) if self.abuf_len > 0 else np.zeros((1, 1), dtype=np.int32)
 
-        if isinstance(wavecaps, int):
-            wavecaps = [wavecaps] * len(circuit.lines)
-
-        intf_wavecap = 4  # sufficient for storing only 1 transition.
-
-        # indices for state allocation table (sat)
-        self.zero_idx = len(circuit.lines)
-        self.tmp_idx = self.zero_idx + 1
-        self.ppi_offset = self.tmp_idx + 1
-        self.ppo_offset = self.ppi_offset + len(self.interface)
-        self.sat_length = self.ppo_offset + len(self.interface)
-
-        # translate circuit structure into self.ops
-        ops = []
-        interface_dict = dict((n, i) for i, n in enumerate(self.interface))
-        for n in circuit.topological_order():
-            if n in interface_dict:
-                inp_idx = self.ppi_offset + interface_dict[n]
-                if len(n.outs) > 0 and n.outs[0] is not None:  # first output of a PI/PPI
-                    ops.append((0b1010, n.outs[0].index, inp_idx, self.zero_idx))
-                if 'dff' in n.kind.lower():  # second output of DFF is inverted
-                    if len(n.outs) > 1 and n.outs[1] is not None:
-                        ops.append((0b0101, n.outs[1].index, inp_idx, self.zero_idx))
-                else:  # if not DFF, no output is inverted.
-                    for o_line in n.outs[1:]:
-                        if o_line is not None:
-                            ops.append((0b1010, o_line.index, inp_idx, self.zero_idx))
-            else:  # regular node, not PI/PPI or PO/PPO
-                o0_idx = n.outs[0].index if len(n.outs) > 0 and n.outs[0] is not None else self.tmp_idx
-                i0_idx = n.ins[0].index if len(n.ins) > 0 and n.ins[0] is not None else self.zero_idx
-                i1_idx = n.ins[1].index if len(n.ins) > 1 and n.ins[1] is not None else self.zero_idx
-                kind = n.kind.lower()
-                if kind == '__fork__':
-                    if not strip_forks:
-                        for o_line in n.outs:
-                            ops.append((0b1010, o_line.index, i0_idx, i1_idx))
-                elif kind.startswith('nand'):
-                    ops.append((0b0111, o0_idx, i0_idx, i1_idx))
-                elif kind.startswith('nor'):
-                    ops.append((0b0001, o0_idx, i0_idx, i1_idx))
-                elif kind.startswith('and'):
-                    ops.append((0b1000, o0_idx, i0_idx, i1_idx))
-                elif kind.startswith('or'):
-                    ops.append((0b1110, o0_idx, i0_idx, i1_idx))
-                elif kind.startswith('xor'):
-                    ops.append((0b0110, o0_idx, i0_idx, i1_idx))
-                elif kind.startswith('xnor'):
-                    ops.append((0b1001, o0_idx, i0_idx, i1_idx))
-                elif kind.startswith('not') or kind.startswith('inv') or kind.startswith('ibuf'):
-                    ops.append((0b0101, o0_idx, i0_idx, i1_idx))
-                elif kind.startswith('buf') or kind.startswith('nbuf'):
-                    ops.append((0b1010, o0_idx, i0_idx, i1_idx))
-                elif kind.startswith('__const1__') or kind.startswith('tieh'):
-                    ops.append((0b0101, o0_idx, i0_idx, i1_idx))
-                elif kind.startswith('__const0__') or kind.startswith('tiel'):
-                    ops.append((0b1010, o0_idx, i0_idx, i1_idx))
-                else:
-                    print('unknown gate type', kind)
-        self.ops = np.asarray(ops, dtype='int32')
+        self.simctl_int = np.zeros((2, sims), dtype=np.int32)
+        """Integer array for per-simulation delay configuration.
 
-        # create a map from fanout lines to stem lines for fork stripping
-        stems = np.zeros(self.sat_length, dtype='int32') - 1  # default to -1: 'no fanout line'
-        if strip_forks:
-            for f in circuit.forks.values():
-                prev_line = f.ins[0]
-                while prev_line.driver.kind == '__fork__':
-                    prev_line = prev_line.driver.ins[0]
-                stem_idx = prev_line.index
-                for ol in f.outs:
-                    stems[ol] = stem_idx
-
-        # calculate level (distance from PI/PPI) and reference count for each line
-        levels = np.zeros(self.sat_length, dtype='int32')
-        ref_count = np.zeros(self.sat_length, dtype='int32')
-        level_starts = [0]
-        current_level = 1
-        for i, op in enumerate(self.ops):
-            # if we fork-strip, always take the stems for determining fan-in level
-            i0_idx = stems[op[2]] if stems[op[2]] >= 0 else op[2]
-            i1_idx = stems[op[3]] if stems[op[3]] >= 0 else op[3]
-            if levels[i0_idx] >= current_level or levels[i1_idx] >= current_level:
-                current_level += 1
-                level_starts.append(i)
-            levels[op[1]] = current_level  # set level of the output line
-            ref_count[i0_idx] += 1
-            ref_count[i1_idx] += 1
-        self.level_starts = np.asarray(level_starts, dtype='int32')
-        self.level_stops = np.asarray(level_starts[1:] + [len(self.ops)], dtype='int32')
-
-        # state allocation table. maps line and interface indices to self.state memory locations
-        self.sat = np.zeros((self.sat_length, 3), dtype='int')
-        self.sat[:, 0] = -1
-
-        h = Heap()
-
-        # allocate and keep memory for special fields
-        self.sat[self.zero_idx] = h.alloc(intf_wavecap), intf_wavecap, 0
-        self.sat[self.tmp_idx] = h.alloc(intf_wavecap), intf_wavecap, 0
-        ref_count[self.zero_idx] += 1
-        ref_count[self.tmp_idx] += 1
-
-        # allocate and keep memory for PI/PPI, keep memory for PO/PPO (allocated later)
-        for i, n in enumerate(self.interface):
-            if len(n.outs) > 0:
-                self.sat[self.ppi_offset + i] = h.alloc(intf_wavecap), intf_wavecap, 0
-                ref_count[self.ppi_offset + i] += 1
-            if len(n.ins) > 0:
-                i0_idx = stems[n.ins[0]] if stems[n.ins[0]] >= 0 else n.ins[0]
-                ref_count[i0_idx] += 1
+        * ``simctl_int[0]`` delay dataset or random seed for picking a delay. By default, each sim has a unique seed.
+        * ``simctl_int[1]`` Method for picking a delay:
+            * 0: seed parameter of :py:func:`c_prop` directly specifies dataset for all simulations
+            * 1: ``simctl_int[0]`` specifies dataset on a per-simulation basis
+            * 2 (default): ``simctl_int[0]`` and seed parameter of :py:func:`c_prop` together are a random seed for picking a delay dataset.
+        """
+        self.simctl_int[0] = range(sims)  # unique seed for each sim by default, zero this to pick same delays for all sims.
+        self.simctl_int[1] = 2  # random picking by default.
 
-        # allocate memory for the rest of the circuit
-        for op_start, op_stop in zip(self.level_starts, self.level_stops):
-            free_list = []
-            for op in self.ops[op_start:op_stop]:
-                # if we fork-strip, always take the stems
-                i0_idx = stems[op[2]] if stems[op[2]] >= 0 else op[2]
-                i1_idx = stems[op[3]] if stems[op[3]] >= 0 else op[3]
-                ref_count[i0_idx] -= 1
-                ref_count[i1_idx] -= 1
-                if ref_count[i0_idx] <= 0: free_list.append(self.sat[i0_idx, 0])
-                if ref_count[i1_idx] <= 0: free_list.append(self.sat[i1_idx, 0])
-                o_idx = op[1]
-                cap = wavecaps[o_idx]
-                self.sat[o_idx] = h.alloc(cap), cap, 0
-            if not keep_waveforms:
-                for loc in free_list:
-                    h.free(loc)
-
-        # copy memory location and capacity from stems to fanout lines
-        for lidx, stem in enumerate(stems):
-            if stem >= 0:  # if at a fanout line
-                self.sat[lidx] = self.sat[stem]
-
-        # copy memory location to PO/PPO area
-        for i, n in enumerate(self.interface):
-            if len(n.ins) > 0:
-                self.sat[self.ppo_offset + i] = self.sat[n.ins[0]]
-
-        # pad timing
-        self.timing = np.zeros((self.sat_length, 2, 2))
-        self.timing[:len(timing)] = timing
-
-        # allocate self.state
-        self.state = np.zeros((h.max_size, sims), dtype='float32') + TMAX
-
-        m1 = np.array([2 ** x for x in range(7, -1, -1)], dtype='uint8')
-        m0 = ~m1
-        self.mask = np.rollaxis(np.vstack((m0, m1)), 1)
+        self.nbytes = sum([a.nbytes for a in (self.c, self.s, self.c_locs, self.c_caps, self.ops, self.simctl_int)])
 
     def __repr__(self):
-        total_mem = self.state.nbytes + self.sat.nbytes + self.ops.nbytes + self.cdata.nbytes
-        return f'<WaveSim {self.circuit.name} sims={self.sims} ops={len(self.ops)} ' + \
-               f'levels={len(self.level_starts)} mem={hr_bytes(total_mem)}>'
-
-    def get_line_delay(self, line, polarity):
-        """Returns the current delay of the given ``line`` and ``polarity`` in the simulation model."""
-        return self.timing[line, 0, polarity]
-
-    def set_line_delay(self, line, polarity, delay):
-        """Sets a new ``delay`` for the given ``line`` and ``polarity`` in the simulation model."""
-        self.timing[line, 0, polarity] = delay
-
-    def assign(self, vectors, time=0.0, offset=0):
-        """Assigns new values to the primary inputs and state-elements.
-
-        :param vectors: The values to assign preferably in 8-valued logic. The values are converted to
-            appropriate waveforms with or one transition (``RISE``, ``FALL``) no transitions
-            (``ZERO``, ``ONE``, and others).
-        :type vectors: :py:class:`~kyupy.logic.BPArray`
-        :param time: The transition time of the generated waveforms.
-        :param offset: The offset into the vector set. The vector assigned to the first simulator is
-            ``vectors[offset]``.
+        dev = 'GPU' if hasattr(self.c, 'copy_to_host') else 'CPU'
+        return f'{{name: "{self.circuit.name}", device: "{dev}", sims: {self.sims}, ops: {len(self.ops)}, ' + \
+               f'levels: {len(self.level_starts)}, nbytes: {self.nbytes}}}'
+
+    def s_to_c(self):
+        """Transfers values of sequential elements and primary inputs to the combinational portion.
+
+        Waveforms are generated on the input lines of the combinational circuit based on the data in :py:attr:`s`.
         """
-        nvectors = min(len(vectors) - offset, self.sims)
-        for i in range(len(self.interface)):
-            ppi_loc = self.sat[self.ppi_offset + i, 0]
-            if ppi_loc < 0: continue
-            for p in range(nvectors):
-                vector = p + offset
-                a = vectors.data[i, :, vector // 8]
-                m = self.mask[vector % 8]
-                toggle = 0
-                if len(a) <= 2:
-                    if a[0] & m[1]:
-                        self.state[ppi_loc, p] = TMIN
-                        toggle += 1
-                else:
-                    if a[1] & m[1]:
-                        self.state[ppi_loc, p] = TMIN
-                        toggle += 1
-                    if (a[2] & m[1]) and ((a[0] & m[1]) != (a[1] & m[1])):
-                        self.state[ppi_loc + toggle, p] = time
-                        toggle += 1
-                self.state[ppi_loc + toggle, p] = TMAX
+        sins = self.s[:, self.pippi_s_locs]
+        cond = (sins[2] != 0) + 2*(sins[0] != 0)  # choices order: 0 R F 1
+        self.c[self.pippi_c_locs] = np.choose(cond, [TMAX, sins[1], TMIN, TMIN])
+        self.c[self.pippi_c_locs+1] = np.choose(cond, [TMAX, TMAX, sins[1], TMAX])
+        self.c[self.pippi_c_locs+2] = TMAX
 
-    def propagate(self, sims=None, sd=0.0, seed=1):
+    def c_prop(self, sims=None, seed=1):
         """Propagates all waveforms from the (pseudo) primary inputs to the (pseudo) primary outputs.
 
         :param sims: Number of parallel simulations to execute. If None, all available simulations are performed.
-        :param sd: Standard deviation for injection of random delay variation. Active, if value is positive.
-        :param seed: Random seed for delay variations.
+        :param seed: Seed for picking delays. See also: :py:attr:`simctl_int`.
         """
         sims = min(sims or self.sims, self.sims)
         for op_start, op_stop in zip(self.level_starts, self.level_stops):
-            self.overflows += level_eval(self.ops, op_start, op_stop, self.state, self.sat, 0, sims,
-                                         self.timing, sd, seed)
-        self.lst_eat_valid = False
-
-    def wave(self, line, vector):
-        # """Returns the desired waveform from the simulation state. Only valid, if simulator was
-        # instantiated with ``keep_waveforms=True``."""
-        if line < 0:
-            return [TMAX]
-        mem, wcap, _ = self.sat[line]
-        if mem < 0:
-            return [TMAX]
-        return self.state[mem:mem + wcap, vector]
-
-    def wave_ppi(self, i, vector):
-        return self.wave(self.ppi_offset + i, vector)
-
-    def wave_ppo(self, o, vector):
-        return self.wave(self.ppo_offset + o, vector)
+            level_eval_cpu(self.ops, op_start, op_stop, self.c, self.c_locs, self.c_caps, self.abuf, 0, sims, self.delays, self.simctl_int, seed)
 
-    def capture(self, time=TMAX, sd=0.0, seed=1, cdata=None, offset=0):
-        """Simulates a capture operation at all state-elements and primary outputs.
+    def c_to_s(self, time=TMAX, sd=0.0, seed=1):
+        """Simulates a capture operation at all sequential elements and primary outputs.
 
-        The capture analyzes the propagated waveforms at and around the given capture time and returns
-        various results for each capture operation.
+        Propagated waveforms at the outputs of the combinational circuit at and around the given capture time are analyzed and
+        the results are stored in :py:attr:`s`.
 
         :param time: The desired capture time. By default, a capture of the settled value is performed.
         :param sd: A standard deviation for uncertainty in the actual capture time.
         :param seed: The random seed for a capture with uncertainty.
-        :param cdata: An array to copy capture data into (optional). See the return value for details.
-        :param offset: An offset into the supplied capture data array.
-        :return: The capture data as numpy array.
-
-            The 3-dimensional capture data array contains for each interface node (axis 0),
-            and each test (axis 1), seven values:
-
-            0. Probability of capturing a 1 at the given capture time (same as next value, if no
-               standard deviation given).
-            1. A capture value decided by random sampling according to above probability and given seed.
-            2. The final value (assume a very late capture time).
-            3. True, if there was a premature capture (capture error), i.e. final value is different
-               from captured value.
-            4. Earliest arrival time. The time at which the output transitioned from its initial value.
-            5. Latest stabilization time. The time at which the output transitioned to its final value.
-            6. Overflow indicator. If non-zero, some signals in the input cone of this output had more
-               transitions than specified in ``wavecaps``. Some transitions have been discarded, the
-               final values in the waveforms are still valid.
         """
-        for i, node in enumerate(self.interface):
-            if len(node.ins) == 0: continue
-            for p in range(self.sims):
-                self.cdata[i, p] = self.capture_wave(self.ppo_offset + i, p, time, sd, seed)
-        if cdata is not None:
-            assert offset < cdata.shape[1]
-            cap_dim = min(cdata.shape[1] - offset, self.sims)
-            cdata[:, offset:cap_dim + offset] = self.cdata[:, 0:cap_dim]
-        self.lst_eat_valid = True
-        return self.cdata
-
-    def reassign(self, time=0.0):
-        """Re-assigns the last capture to the appropriate pseudo-primary inputs. Generates a new set of
-        waveforms at the PPIs that start with the previous final value of that PPI, and transitions at the
-        given time to the value captured in a previous simulation. :py:func:`~WaveSim.capture` must be called
-        prior to this function. The final value of each PPI is taken from the randomly sampled concrete logic
-        values in the capture data.
+        for s_loc, c_loc, c_len in zip(self.poppo_s_locs, self.c_locs[self.ppo_offset+self.poppo_s_locs], self.c_caps[self.ppo_offset+self.poppo_s_locs]):
+            for vector in range(self.sims):
+                self.s[3:, s_loc, vector] = wave_capture_cpu(self.c, c_loc, c_len, vector, time=time, sd=sd, seed=seed)
+
+    def s_ppo_to_ppi(self, time=0.0):
+        """Re-assigns the last sampled capture of the PPOs to the appropriate pseudo-primary inputs (PPIs).
+        Each PPI transition is constructed from the final value of the previous assignment, the
+        given time, and the sampled captured value of its PPO. Reads and modifies :py:attr:`s`.
 
         :param time: The transition time at the inputs (usually 0.0).
         """
-        for i in range(len(self.interface)):
-            ppi_loc = self.sat[self.ppi_offset + i, 0]
-            ppo_loc = self.sat[self.ppo_offset + i, 0]
-            if ppi_loc < 0 or ppo_loc < 0: continue
-            for sidx in range(self.sims):
-                ival = self.val(self.ppi_offset + i, sidx, TMAX) > 0.5
-                oval = self.cdata[i, sidx, 1] > 0.5
-                toggle = 0
-                if ival:
-                    self.state[ppi_loc, sidx] = TMIN
-                    toggle += 1
-                if ival != oval:
-                    self.state[ppi_loc + toggle, sidx] = time
-                    toggle += 1
-                self.state[ppi_loc + toggle, sidx] = TMAX
-
-    def eat(self, line, vector):
-        eat = TMAX
-        for t in self.wave(line, vector):
-            if t >= TMAX: break
-            if t <= TMIN: continue
-            eat = min(eat, t)
-        return eat
-
-    def lst(self, line, vector):
-        lst = TMIN
-        for t in self.wave(line, vector):
-            if t >= TMAX: break
-            if t <= TMIN: continue
-            lst = max(lst, t)
-        return lst
-
-    def lst_ppo(self, o, vector):
-        if not self.lst_eat_valid:
-            self.capture()
-        return self.cdata[o, vector, 5]
-
-    def toggles(self, line, vector):
-        tog = 0
-        for t in self.wave(line, vector):
-            if t >= TMAX: break
-            if t <= TMIN: continue
-            tog += 1
-        return tog
-
-    def _vals(self, idx, vector, times, sd=0.0):
-        s_sqrt2 = sd * math.sqrt(2)
-        m = 0.5
-        accs = [0.0] * len(times)
-        values = [0] * len(times)
-        for t in self.wave(idx, vector):
-            if t >= TMAX: break
-            for idx, time in enumerate(times):
-                if t < time:
-                    values[idx] = values[idx] ^ 1
-            m = -m
-            if t <= TMIN: continue
-            if s_sqrt2 > 0:
-                for idx, time in enumerate(times):
-                    accs[idx] += m * (1 + math.erf((t - time) / s_sqrt2))
-        if (m < 0) and (s_sqrt2 > 0):
-            for idx, time in enumerate(times):
-                accs[idx] += 1
-        if s_sqrt2 == 0:
-            return values
-        return accs
-
-    def vals(self, line, vector, times, sd=0):
-        return self._vals(line, vector, times, sd)
-
-    def val(self, line, vector, time=TMAX, sd=0):
-        return self.capture_wave(line, vector, time, sd)[0]
-
-    def vals_ppo(self, o, vector, times, sd=0):
-        return self._vals(self.ppo_offset + o, vector, times, sd)
-
-    def val_ppo(self, o, vector, time=TMAX, sd=0):
-        if not self.lst_eat_valid:
-            self.capture(time, sd)
-        return self.cdata[o, vector, 0]
-
-    def capture_wave(self, line, vector, time=TMAX, sd=0.0, seed=1):
-        s_sqrt2 = sd * math.sqrt(2)
-        m = 0.5
-        acc = 0.0
-        eat = TMAX
-        lst = TMIN
-        tog = 0
-        ovl = 0
-        val = int(0)
-        final = int(0)
-        for t in self.wave(line, vector):
-            if t >= TMAX:
-                if t == TMAX_OVL:
-                    ovl = 1
-                break
-            m = -m
-            final ^= 1
-            if t < time:
-                val ^= 1
-            if t <= TMIN: continue
-            if s_sqrt2 > 0:
-                acc += m * (1 + math.erf((t - time) / s_sqrt2))
-            eat = min(eat, t)
-            lst = max(lst, t)
-            tog += 1
-        if s_sqrt2 > 0:
-            if m < 0:
-                acc += 1
-            if acc >= 0.99:
-                val = 1
-            elif acc > 0.01:
-                seed = (seed << 4) + (vector << 20) + (line-self.ppo_offset << 1)
-                seed = int(0xDEECE66D) * seed + 0xB
-                seed = int(0xDEECE66D) * seed + 0xB
-                rnd = float((seed >> 8) & 0xffffff) / float(1 << 24)
-                val = rnd < acc
-            else:
-                val = 0
-        else:
-            acc = val
-
-        return acc, val, final, (val != final), eat, lst, ovl
+        self.s[0, self.ppio_s_locs] = self.s[2, self.ppio_s_locs]
+        self.s[1, self.ppio_s_locs] = time
+        self.s[2, self.ppio_s_locs] = self.s[8, self.ppio_s_locs]
 
 
-@numba.njit
-def level_eval(ops, op_start, op_stop, state, sat, st_start, st_stop, line_times, sd, seed):
-    overflows = 0
-    for op_idx in range(op_start, op_stop):
-        op = ops[op_idx]
-        for st_idx in range(st_start, st_stop):
-            overflows += wave_eval(op, state, sat, st_idx, line_times, sd, seed)
-    return overflows
-
-
-@numba.njit
-def rand_gauss(seed, sd):
-    clamp = 0.5
-    if sd <= 0.0:
-        return 1.0
-    while True:
-        x = -6.0
-        for _ in range(12):
-            seed = int(0xDEECE66D) * seed + 0xB
-            x += float((seed >> 8) & 0xffffff) / float(1 << 24)
-        x *= sd
-        if abs(x) <= clamp:
-            break
-    return x + 1.0
-
-
-@numba.njit
-def wave_eval(op, state, sat, st_idx, line_times, sd=0.0, seed=0):
-    lut, z_idx, a_idx, b_idx = op
+def _wave_eval(op, cbuf, c_locs, c_caps, sim, delays, simctl_int, seed=0):
     overflows = int(0)
 
-    _seed = (seed << 4) + (z_idx << 20) + (st_idx << 1)
+    lut = op[0]
+    z_idx = op[1]
+    a_idx = op[2]
+    b_idx = op[3]
+    c_idx = op[4]
+    d_idx = op[5]
+
+    if len(delays) > 1:
+        if simctl_int[1] == 0:
+            delays = delays[seed]
+        elif simctl_int[1] == 1:
+            delays = delays[simctl_int[0]]
+        else:
+            _rnd = (seed << 4) + (z_idx << 20) + simctl_int[0]
+            for _ in range(4):
+                _rnd = int(0xDEECE66D) * _rnd + 0xB
+            delays = delays[_rnd % len(delays)]
+    else:
+        delays = delays[0]
 
-    a_mem = sat[a_idx, 0]
-    b_mem = sat[b_idx, 0]
-    z_mem, z_cap, _ = sat[z_idx]
+    a_mem = c_locs[a_idx]
+    b_mem = c_locs[b_idx]
+    c_mem = c_locs[c_idx]
+    d_mem = c_locs[d_idx]
+    z_mem = c_locs[z_idx]
+    z_cap = c_caps[z_idx]
 
     a_cur = int(0)
     b_cur = int(0)
+    c_cur = int(0)
+    d_cur = int(0)
     z_cur = lut & 1
     if z_cur == 1:
-        state[z_mem, st_idx] = TMIN
+        cbuf[z_mem, sim] = TMIN
 
-    a = state[a_mem, st_idx] + line_times[a_idx, 0, z_cur] * rand_gauss(_seed ^ a_mem ^ z_cur, sd)
-    b = state[b_mem, st_idx] + line_times[b_idx, 0, z_cur] * rand_gauss(_seed ^ b_mem ^ z_cur, sd)
+    z_val = z_cur
+
+    a = cbuf[a_mem + a_cur, sim] + delays[a_idx, 0, z_val]
+    b = cbuf[b_mem + b_cur, sim] + delays[b_idx, 0, z_val]
+    c = cbuf[c_mem + c_cur, sim] + delays[c_idx, 0, z_val]
+    d = cbuf[d_mem + d_cur, sim] + delays[d_idx, 0, z_val]
 
     previous_t = TMIN
 
-    current_t = min(a, b)
+    current_t = min(a, b, c, d)
     inputs = int(0)
 
     while current_t < TMAX:
-        z_val = z_cur & 1
-        if b < a:
+        if a == current_t:
+            a_cur += 1
+            inputs ^= 1
+            thresh = delays[a_idx, a_cur & 1, z_val]
+            a = cbuf[a_mem + a_cur, sim] + delays[a_idx, a_cur & 1, z_val]
+            next_t = cbuf[a_mem + a_cur, sim] + delays[a_idx, (a_cur & 1) ^ 1, z_val ^ 1]
+        elif b == current_t:
             b_cur += 1
-            b = state[b_mem + b_cur, st_idx]
-            b += line_times[b_idx, 0, z_val ^ 1] * rand_gauss(_seed ^ b_mem ^ z_val ^ 1, sd)
-            thresh = line_times[b_idx, 1, z_val] * rand_gauss(_seed ^ b_mem ^ z_val, sd)
             inputs ^= 2
-            next_t = b
+            thresh = delays[b_idx, b_cur & 1, z_val]
+            b = cbuf[b_mem + b_cur, sim] + delays[b_idx, b_cur & 1, z_val]
+            next_t = cbuf[b_mem + b_cur, sim] + delays[b_idx, (b_cur & 1) ^ 1, z_val ^ 1]
+        elif c == current_t:
+            c_cur += 1
+            inputs ^= 4
+            thresh = delays[c_idx, c_cur & 1, z_val]
+            c = cbuf[c_mem + c_cur, sim] + delays[c_idx, c_cur & 1, z_val]
+            next_t = cbuf[c_mem + c_cur, sim] + delays[c_idx, (c_cur & 1) ^ 1, z_val ^ 1]
         else:
-            a_cur += 1
-            a = state[a_mem + a_cur, st_idx]
-            a += line_times[a_idx, 0, z_val ^ 1] * rand_gauss(_seed ^ a_mem ^ z_val ^ 1, sd)
-            thresh = line_times[a_idx, 1, z_val] * rand_gauss(_seed ^ a_mem ^ z_val, sd)
-            inputs ^= 1
-            next_t = a
+            d_cur += 1
+            inputs ^= 8
+            thresh = delays[d_idx, d_cur & 1, z_val]
+            d = cbuf[d_mem + d_cur, sim] + delays[d_idx, d_cur & 1, z_val]
+            next_t = cbuf[d_mem + d_cur, sim] + delays[d_idx, (d_cur & 1) ^ 1, z_val ^ 1]
 
         if (z_cur & 1) != ((lut >> inputs) & 1):
-            # we generate a toggle in z_mem, if:
-            #   ( it is the first toggle in z_mem OR
-            #   following toggle is earlier OR
-            #   pulse is wide enough ) AND enough space in z_mem.
-            if z_cur == 0 or next_t < current_t or (current_t - previous_t) > thresh:
-                if z_cur < (z_cap - 1):
-                    state[z_mem + z_cur, st_idx] = current_t
+            # we generate an edge in z_mem, if ...
+            if (z_cur == 0                            # it is the first edge in z_mem ...
+                or next_t < current_t                 # -OR- the next edge on SAME input is EARLIER (need current edge to filter BOTH in next iteration) ...
+                or (current_t - previous_t) > thresh  # -OR- the generated hazard is wider than pulse threshold.
+                ):
+                if z_cur < (z_cap - 1):  # enough space in z_mem?
+                    cbuf[z_mem + z_cur, sim] = current_t
                     previous_t = current_t
                     z_cur += 1
                 else:
                     overflows += 1
-                    previous_t = state[z_mem + z_cur - 1, st_idx]
+                    previous_t = cbuf[z_mem + z_cur - 1, sim]
                     z_cur -= 1
             else:
                 z_cur -= 1
-                if z_cur > 0:
-                    previous_t = state[z_mem + z_cur - 1, st_idx]
-                else:
-                    previous_t = TMIN
-        current_t = min(a, b)
+                previous_t = cbuf[z_mem + z_cur - 1, sim] if z_cur > 0 else TMIN
+
+            # output value of cell changed. update all delayed inputs.
+            z_val = z_val ^ 1
+            a = cbuf[a_mem + a_cur, sim] + delays[a_idx, a_cur & 1, z_val]
+            b = cbuf[b_mem + b_cur, sim] + delays[b_idx, b_cur & 1, z_val]
+            c = cbuf[c_mem + c_cur, sim] + delays[c_idx, c_cur & 1, z_val]
+            d = cbuf[d_mem + d_cur, sim] + delays[d_idx, d_cur & 1, z_val]
+
+        current_t = min(a, b, c, d)
+
+    # generate or propagate overflow flag
+    cbuf[z_mem + z_cur, sim] = TMAX_OVL if overflows > 0 else max(a, b, c, d)
+
+    nrise = max(0, (z_cur+1) // 2 - (cbuf[z_mem, sim] == TMIN))
+    nfall = z_cur // 2
+
+    return nrise, nfall
+
+
+wave_eval_cpu = numba.njit(_wave_eval)
 
-    if overflows > 0:
-        state[z_mem + z_cur, st_idx] = TMAX_OVL
+
+@numba.njit
+def level_eval_cpu(ops, op_start, op_stop, c, c_locs, c_caps, abuf, sim_start, sim_stop, delays, simctl_int, seed):
+    for op_idx in range(op_start, op_stop):
+        op = ops[op_idx]
+        for sim in range(sim_start, sim_stop):
+            nrise, nfall = wave_eval_cpu(op, c, c_locs, c_caps, sim, delays, simctl_int[:, sim], seed)
+            a_loc = op[6]
+            a_wr = op[7]
+            a_wf = op[8]
+            if a_loc >= 0:
+                abuf[a_loc, sim] += nrise*a_wr + nfall*a_wf
+
+
+@numba.njit
+def wave_capture_cpu(c, c_loc, c_len, vector, time=TMAX, sd=0.0, seed=1):
+    s_sqrt2 = sd * math.sqrt(2)
+    m = 0.5
+    acc = 0.0
+    eat = TMAX
+    lst = TMIN
+    tog = 0
+    ovl = 0
+    val = int(0)
+    final = int(0)
+    w = c[c_loc:c_loc+c_len, vector]
+    for t in w:
+        if t >= TMAX:
+            if t == TMAX_OVL:
+                ovl = 1
+            break
+        m = -m
+        final ^= 1
+        if t < time:
+            val ^= 1
+        if t <= TMIN: continue
+        if s_sqrt2 > 0:
+            acc += m * (1 + math.erf((t - time) / s_sqrt2))
+        eat = min(eat, t)
+        lst = max(lst, t)
+        tog += 1
+    if s_sqrt2 > 0:
+        if m < 0:
+            acc += 1
+        if acc >= 0.99:
+            val = 1
+        elif acc > 0.01:
+            seed = (seed << 4) + (vector << 20) + c_loc
+            seed = int(0xDEECE66D) * seed + 0xB
+            seed = int(0xDEECE66D) * seed + 0xB
+            rnd = float((seed >> 8) & 0xffffff) / float(1 << 24)
+            val = rnd < acc
+        else:
+            val = 0
     else:
-        state[z_mem + z_cur, st_idx] = a if a > b else b  # propagate overflow flags by storing biggest TMAX from input
+        acc = val
 
-    return overflows
+    return (w[0] <= TMIN), eat, lst, final, acc, val, 0, ovl
 
 
 class WaveSimCuda(WaveSim):
     """A GPU-accelerated waveform-based combinational logic timing simulator.
 
-    The API is the same as for :py:class:`WaveSim`.
+    The API is identical to :py:class:`WaveSim`. See there for complete documentation.
+
     All internal memories are mirrored into GPU memory upon construction.
     Some operations like access to single waveforms can involve large communication overheads.
     """
-    def __init__(self, circuit, timing, sims=8, wavecaps=16, strip_forks=False, keep_waveforms=True):
-        super().__init__(circuit, timing, sims, wavecaps, strip_forks, keep_waveforms)
-
-        self.tdata = np.zeros((len(self.interface), 3, (sims - 1) // 8 + 1), dtype='uint8')
+    def __init__(self, circuit, delays, sims=8, c_caps=16, a_ctrl=None, c_reuse=False, strip_forks=False):
+        super().__init__(circuit, delays, sims, c_caps, a_ctrl=a_ctrl, c_reuse=c_reuse, strip_forks=strip_forks)
 
-        self.d_state = cuda.to_device(self.state)
-        self.d_sat = cuda.to_device(self.sat)
-        self.d_ops = cuda.to_device(self.ops)
-        self.d_timing = cuda.to_device(self.timing)
-        self.d_tdata = cuda.to_device(self.tdata)
-        self.d_cdata = cuda.to_device(self.cdata)
+        self.c = cuda.to_device(self.c)
+        self.s = cuda.to_device(self.s)
+        self.ops = cuda.to_device(self.ops)
+        self.c_locs = cuda.to_device(self.c_locs)
+        self.c_caps = cuda.to_device(self.c_caps)
+        self.delays = cuda.to_device(self.delays)
+        self.simctl_int = cuda.to_device(self.simctl_int)
+        self.abuf = cuda.to_device(self.abuf)
 
         self._block_dim = (32, 16)
 
-    def __repr__(self):
-        total_mem = self.state.nbytes + self.sat.nbytes + self.ops.nbytes + self.timing.nbytes + \
-                    self.tdata.nbytes + self.cdata.nbytes
-        return f'<WaveSimCuda {self.circuit.name} sims={self.sims} ops={len(self.ops)} ' + \
-               f'levels={len(self.level_starts)} mem={hr_bytes(total_mem)}>'
-
-    def get_line_delay(self, line, polarity):
-        return self.d_timing[line, 0, polarity]
-
-    def set_line_delay(self, line, polarity, delay):
-        self.d_timing[line, 0, polarity] = delay
-
-    def assign(self, vectors, time=0.0, offset=0):
-        assert (offset % 8) == 0
-        byte_offset = offset // 8
-        assert byte_offset < vectors.data.shape[-1]
-        pdim = min(vectors.data.shape[-1] - byte_offset, self.tdata.shape[-1])
-
-        self.tdata[..., 0:pdim] = vectors.data[..., byte_offset:pdim + byte_offset]
-        if vectors.m == 2:
-            self.tdata[:, 2, 0:pdim] = 0
-        cuda.to_device(self.tdata, to=self.d_tdata)
-
-        grid_dim = self._grid_dim(self.sims, len(self.interface))
-        assign_kernel[grid_dim, self._block_dim](self.d_state, self.d_sat, self.ppi_offset,
-                                                 len(self.interface), self.d_tdata, time)
-
-    def _grid_dim(self, x, y):
-        gx = math.ceil(x / self._block_dim[0])
-        gy = math.ceil(y / self._block_dim[1])
-        return gx, gy
+    def __getstate__(self):
+        state = self.__dict__.copy()
+        state['c'] = np.array(self.c)
+        state['s'] = np.array(self.s)
+        state['ops'] = np.array(self.ops)
+        state['c_locs'] = np.array(self.c_locs)
+        state['c_caps'] = np.array(self.c_caps)
+        state['delays'] = np.array(self.delays)
+        state['simctl_int'] = np.array(self.simctl_int)
+        state['abuf'] = np.array(self.abuf)
+        return state
+
+    def __setstate__(self, state):
+        self.__dict__.update(state)
+        self.c = cuda.to_device(self.c)
+        self.s = cuda.to_device(self.s)
+        self.ops = cuda.to_device(self.ops)
+        self.c_locs = cuda.to_device(self.c_locs)
+        self.c_caps = cuda.to_device(self.c_caps)
+        self.delays = cuda.to_device(self.delays)
+        self.simctl_int = cuda.to_device(self.simctl_int)
+        self.abuf = cuda.to_device(self.abuf)
+
+    def s_to_c(self):
+        grid_dim = self._grid_dim(self.sims, self.s_len)
+        wave_assign_gpu[grid_dim, self._block_dim](self.c, self.s, self.c_locs, self.ppi_offset)
+
+    def _grid_dim(self, x, y): return cdiv(x, self._block_dim[0]), cdiv(y, self._block_dim[1])
 
-    def propagate(self, sims=None, sd=0.0, seed=1):
+    def c_prop(self, sims=None, seed=1):
         sims = min(sims or self.sims, self.sims)
         for op_start, op_stop in zip(self.level_starts, self.level_stops):
             grid_dim = self._grid_dim(sims, op_stop - op_start)
-            wave_kernel[grid_dim, self._block_dim](self.d_ops, op_start, op_stop, self.d_state, self.sat, int(0),
-                                                   sims, self.d_timing, sd, seed)
+            wave_eval_gpu[grid_dim, self._block_dim](self.ops, op_start, op_stop, self.c, self.c_locs, self.c_caps, self.abuf, int(0),
+                sims, self.delays, self.simctl_int, seed)
         cuda.synchronize()
-        self.lst_eat_valid = False
 
-    def wave(self, line, vector):
-        if line < 0:
-            return [TMAX]
-        mem, wcap, _ = self.sat[line]
-        if mem < 0:
-            return [TMAX]
-        return self.d_state[mem:mem + wcap, vector]
-
-    def capture(self, time=TMAX, sd=0, seed=1, cdata=None, offset=0):
-        grid_dim = self._grid_dim(self.sims, len(self.interface))
-        capture_kernel[grid_dim, self._block_dim](self.d_state, self.d_sat, self.ppo_offset,
-                                                  self.d_cdata, time, sd * math.sqrt(2), seed)
-        self.cdata[...] = self.d_cdata
-        if cdata is not None:
-            assert offset < cdata.shape[1]
-            cap_dim = min(cdata.shape[1] - offset, self.sims)
-            cdata[:, offset:cap_dim + offset] = self.cdata[:, 0:cap_dim]
-        self.lst_eat_valid = True
-        return self.cdata
-
-    def reassign(self, time=0.0):
-        grid_dim = self._grid_dim(self.sims, len(self.interface))
-        reassign_kernel[grid_dim, self._block_dim](self.d_state, self.d_sat, self.ppi_offset, self.ppo_offset,
-                                                   self.d_cdata, time)
-        cuda.synchronize()
-
-    def wavecaps(self):
-        gx = math.ceil(len(self.circuit.lines) / 512)
-        wavecaps_kernel[gx, 512](self.d_state, self.d_sat, self.sims)
-        self.sat[...] = self.d_sat
-        return self.sat[..., 2]
+    def c_to_s(self, time=TMAX, sd=0.0, seed=1):
+        grid_dim = self._grid_dim(self.sims, self.s_len)
+        wave_capture_gpu[grid_dim, self._block_dim](self.c, self.s, self.c_locs, self.c_caps, self.ppo_offset,
+            time, sd * math.sqrt(2), seed)
+
+    def s_ppo_to_ppi(self, time=0.0):
+        grid_dim = self._grid_dim(self.sims, self.s_len)
+        ppo_to_ppi_gpu[grid_dim, self._block_dim](self.s, self.c_locs, time, self.ppi_offset, self.ppo_offset)
 
 
 @cuda.jit()
-def wavecaps_kernel(state, sat, sims):
-    idx = cuda.grid(1)
-    if idx >= len(sat): return
-
-    lidx, lcap, _ = sat[idx]
-    if lidx < 0: return
-
-    wcap = 0
-    for sidx in range(sims):
-        for tidx in range(lcap):
-            t = state[lidx + tidx, sidx]
-            if tidx > wcap:
-                wcap = tidx
-            if t >= TMAX: break
+def wave_assign_gpu(c, s, c_locs, ppi_offset):
+    x, y = cuda.grid(2)
+    if y >= s.shape[1]: return
+    c_loc = c_locs[ppi_offset + y]
+    if c_loc < 0: return
+    if x >= c.shape[-1]: return
+    value = int(s[2, y, x] >= 0.5) | (2*int(s[0, y, x] >= 0.5))
+    ttime = s[1, y, x]
+    if value == 0:
+        c[c_loc, x] = TMAX
+        c[c_loc+1, x] = TMAX
+    elif value == 1:
+        c[c_loc, x] = ttime
+        c[c_loc+1, x] = TMAX
+    elif value == 2:
+        c[c_loc, x] = TMIN
+        c[c_loc+1, x] = ttime
+    else:
+        c[c_loc, x] = TMIN
+        c[c_loc+1, x] = TMAX
+    c[c_loc+2, x] = TMAX
+
 
-    sat[idx, 2] = wcap + 1
+_wave_eval_gpu = cuda.jit(_wave_eval, device=True)
 
 
 @cuda.jit()
-def reassign_kernel(state, sat, ppi_offset, ppo_offset, cdata, ppi_time):
-    vector, y = cuda.grid(2)
-    if vector >= state.shape[-1]: return
-    if ppo_offset + y >= len(sat): return
-
-    ppo, _, _ = sat[ppo_offset + y]
-    ppi, ppi_cap, _ = sat[ppi_offset + y]
-    if ppo < 0: return
-    if ppi < 0: return
-
-    ppo_val = int(cdata[y, vector, 1])
-    ppi_val = int(0)
-    for tidx in range(ppi_cap):
-        t = state[ppi + tidx, vector]
-        if t >= TMAX: break
-        ppi_val ^= 1
-
-    # make new waveform at PPI
-    toggle = 0
-    if ppi_val:
-        state[ppi + toggle, vector] = TMIN
-        toggle += 1
-    if ppi_val != ppo_val:
-        state[ppi + toggle, vector] = ppi_time
-        toggle += 1
-    state[ppi + toggle, vector] = TMAX
+def wave_eval_gpu(ops, op_start, op_stop, cbuf, c_locs, c_caps, abuf, sim_start, sim_stop, delays, simctl_int, seed):
+    x, y = cuda.grid(2)
+    sim = sim_start + x
+    op_idx = op_start + y
+    if sim >= sim_stop: return
+    if op_idx >= op_stop: return
+
+    op = ops[op_idx]
+    a_loc = op[6]
+    a_wr = op[7]
+    a_wf = op[8]
+
+    nrise, nfall = _wave_eval_gpu(op, cbuf, c_locs, c_caps, sim, delays, simctl_int[:, sim], seed)
+
+    # accumulate WSA into abuf
+    if a_loc >= 0:
+        cuda.atomic.add(abuf, (a_loc, sim), nrise*a_wr + nfall*a_wf)
 
 
 @cuda.jit()
-def capture_kernel(state, sat, ppo_offset, cdata, time, s_sqrt2, seed):
+def wave_capture_gpu(c, s, c_locs, c_caps, ppo_offset, time, s_sqrt2, seed):
     x, y = cuda.grid(2)
-    if ppo_offset + y >= len(sat): return
-    line, tdim, _ = sat[ppo_offset + y]
+    if ppo_offset + y >= len(c_locs): return
+    line = c_locs[ppo_offset + y]
+    tdim = c_caps[ppo_offset + y]
     if line < 0: return
-    if x >= state.shape[-1]: return
+    if x >= c.shape[-1]: return
     vector = x
     m = 0.5
     acc = 0.0
     eat = TMAX
     lst = TMIN
     tog = 0
     ovl = 0
     val = int(0)
     final = int(0)
     for tidx in range(tdim):
-        t = state[line + tidx, vector]
+        t = c[line + tidx, vector]
         if t >= TMAX:
             if t == TMAX_OVL:
                 ovl = 1
             break
         m = -m
         final ^= 1
         if t < time:
@@ -805,131 +487,29 @@
             rnd = float((seed >> 8) & 0xffffff) / float(1 << 24)
             val = rnd < acc
         else:
             val = 0
     else:
         acc = val
 
-    cdata[y, vector, 0] = acc
-    cdata[y, vector, 1] = val
-    cdata[y, vector, 2] = final
-    cdata[y, vector, 3] = (val != final)
-    cdata[y, vector, 4] = eat
-    cdata[y, vector, 5] = lst
-    cdata[y, vector, 6] = ovl
+    s[3, y, vector] = (c[line, vector] <= TMIN)
+    s[4, y, vector] = eat
+    s[5, y, vector] = lst
+    s[6, y, vector] = final
+    s[7, y, vector] = acc
+    s[8, y, vector] = val
+    s[9, y, vector] = 0  # TODO
+    s[10, y, vector] = ovl
 
 
 @cuda.jit()
-def assign_kernel(state, sat, ppi_offset, intf_len, tdata, time):
+def ppo_to_ppi_gpu(s, c_locs, time, ppi_offset, ppo_offset):
     x, y = cuda.grid(2)
-    if y >= intf_len: return
-    line = sat[ppi_offset + y, 0]
-    if line < 0: return
-    sdim = state.shape[-1]
-    if x >= sdim: return
-    vector = x
-    a0 = tdata[y, 0, vector // 8]
-    a1 = tdata[y, 1, vector // 8]
-    a2 = tdata[y, 2, vector // 8]
-    m = np.uint8(1 << (7 - (vector % 8)))
-    toggle = 0
-    if a1 & m:
-        state[line + toggle, x] = TMIN
-        toggle += 1
-    if (a2 & m) and ((a0 & m) != (a1 & m)):
-        state[line + toggle, x] = time
-        toggle += 1
-    state[line + toggle, x] = TMAX
-
-
-@cuda.jit(device=True)
-def rand_gauss_dev(seed, sd):
-    clamp = 0.5
-    if sd <= 0.0:
-        return 1.0
-    while True:
-        x = -6.0
-        for _ in range(12):
-            seed = int(0xDEECE66D) * seed + 0xB
-            x += float((seed >> 8) & 0xffffff) / float(1 << 24)
-        x *= sd
-        if abs(x) <= clamp:
-            break
-    return x + 1.0
+    if y >= s.shape[1]: return
+    if x >= s.shape[2]: return
 
+    if c_locs[ppi_offset + y] < 0: return
+    if c_locs[ppo_offset + y] < 0: return
 
-@cuda.jit()
-def wave_kernel(ops, op_start, op_stop, state, sat, st_start, st_stop, line_times, sd, seed):
-    x, y = cuda.grid(2)
-    st_idx = st_start + x
-    op_idx = op_start + y
-    if st_idx >= st_stop: return
-    if op_idx >= op_stop: return
-    lut = ops[op_idx, 0]
-    z_idx = ops[op_idx, 1]
-    a_idx = ops[op_idx, 2]
-    b_idx = ops[op_idx, 3]
-    overflows = int(0)
-
-    _seed = (seed << 4) + (z_idx << 20) + (st_idx << 1)
-
-    a_mem = sat[a_idx, 0]
-    b_mem = sat[b_idx, 0]
-    z_mem, z_cap, _ = sat[z_idx]
-
-    a_cur = int(0)
-    b_cur = int(0)
-    z_cur = lut & 1
-    if z_cur == 1:
-        state[z_mem, st_idx] = TMIN
-
-    a = state[a_mem, st_idx] + line_times[a_idx, 0, z_cur] * rand_gauss_dev(_seed ^ a_mem ^ z_cur, sd)
-    b = state[b_mem, st_idx] + line_times[b_idx, 0, z_cur] * rand_gauss_dev(_seed ^ b_mem ^ z_cur, sd)
-
-    previous_t = TMIN
-
-    current_t = min(a, b)
-    inputs = int(0)
-
-    while current_t < TMAX:
-        z_val = z_cur & 1
-        if b < a:
-            b_cur += 1
-            b = state[b_mem + b_cur, st_idx]
-            b += line_times[b_idx, 0, z_val ^ 1] * rand_gauss_dev(_seed ^ b_mem ^ z_val ^ 1, sd)
-            thresh = line_times[b_idx, 1, z_val] * rand_gauss_dev(_seed ^ b_mem ^ z_val, sd)
-            inputs ^= 2
-            next_t = b
-        else:
-            a_cur += 1
-            a = state[a_mem + a_cur, st_idx]
-            a += line_times[a_idx, 0, z_val ^ 1] * rand_gauss_dev(_seed ^ a_mem ^ z_val ^ 1, sd)
-            thresh = line_times[a_idx, 1, z_val] * rand_gauss_dev(_seed ^ a_mem ^ z_val, sd)
-            inputs ^= 1
-            next_t = a
-
-        if (z_cur & 1) != ((lut >> inputs) & 1):
-            # we generate a toggle in z_mem, if:
-            #   ( it is the first toggle in z_mem OR
-            #   following toggle is earlier OR
-            #   pulse is wide enough ) AND enough space in z_mem.
-            if z_cur == 0 or next_t < current_t or (current_t - previous_t) > thresh:
-                if z_cur < (z_cap - 1):
-                    state[z_mem + z_cur, st_idx] = current_t
-                    previous_t = current_t
-                    z_cur += 1
-                else:
-                    overflows += 1
-                    previous_t = state[z_mem + z_cur - 1, st_idx]
-                    z_cur -= 1
-            else:
-                z_cur -= 1
-                if z_cur > 0:
-                    previous_t = state[z_mem + z_cur - 1, st_idx]
-                else:
-                    previous_t = TMIN
-        current_t = min(a, b)
-
-    if overflows > 0:
-        state[z_mem + z_cur, st_idx] = TMAX_OVL
-    else:
-        state[z_mem + z_cur, st_idx] = a if a > b else b  # propagate overflow flags by storing biggest TMAX from input
+    s[0, y, x] = s[2, y, x]
+    s[1, y, x] = time
+    s[2, y, x] = s[8, y, x]
```

## Comparing `kyupy-0.0.3.dist-info/LICENSE.txt` & `kyupy-0.0.4.dist-info/LICENSE.txt`

 * *Files 22% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 MIT License
 
-Copyright (c) 2020-2021 Stefan Holst
+Copyright (c) 2020-2023 Stefan Holst
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
```

## Comparing `kyupy-0.0.3.dist-info/METADATA` & `kyupy-0.0.4.dist-info/METADATA`

 * *Files 10% similar despite different names*

```diff
@@ -1,56 +1,56 @@
 Metadata-Version: 2.1
 Name: kyupy
-Version: 0.0.3
+Version: 0.0.4
 Summary: High-performance processing and analysis of non-hierarchical VLSI designs
 Home-page: https://github.com/s-holst/kyupy
 Author: Stefan Holst
 Author-email: mail@s-holst.de
-License: UNKNOWN
-Platform: UNKNOWN
 Classifier: Development Status :: 3 - Alpha
 Classifier: Environment :: GPU :: NVIDIA CUDA
 Classifier: Intended Audience :: Science/Research
 Classifier: Topic :: Scientific/Engineering :: Electronic Design Automation (EDA)
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3 :: Only
-Classifier: Programming Language :: Python :: 3.6
-Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
-Requires-Python: >=3.6
+Classifier: Programming Language :: Python :: 3.10
+Requires-Python: >=3.8
 Description-Content-Type: text/x-rst
+License-File: LICENSE.txt
 Requires-Dist: numpy (>=1.17.0)
 Requires-Dist: lark-parser (>=0.8.0)
 
 KyuPy - Pythonic Processing of VLSI Circuits
 ============================================
 
 KyuPy is a Python package for processing and analysis of non-hierarchical gate-level VLSI designs.
 It contains fundamental building blocks for research software in the fields of VLSI test, diagnosis and reliability:
 
 * Efficient data structures for gate-level circuits and related design data.
 * Partial `lark <https://github.com/lark-parser/lark>`_ parsers for common design files like
-  bench, gate-level verilog, standard delay format (SDF), standard test interface language (STIL).
+  bench, gate-level Verilog, standard delay format (SDF), standard test interface language (STIL), design exchange format (DEF).
 * Bit-parallel gate-level 2-, 4-, and 8-valued logic simulation.
 * GPU-accelerated high-throughput gate-level timing simulation.
 * High-performance through the use of `numpy <https://numpy.org>`_ and `numba <https://numba.pydata.org>`_.
 
 
 Getting Started
 ---------------
 
 KyuPy is available in `PyPI <https://pypi.org/project/kyupy>`_.
-It requires Python 3.6 or newer, `lark-parser <https://pypi.org/project/lark-parser>`_, and `numpy`_.
+It requires Python 3.8 or newer, `lark-parser <https://pypi.org/project/lark-parser>`_, and `numpy`_.
 Although optional, `numba`_ should be installed for best performance.
-GPU/CUDA support in numba may `require some additional setup <https://numba.pydata.org/numba-doc/latest/cuda/index.html>`_.
+GPU/CUDA support in numba may `require some additional setup <https://numba.readthedocs.io/en/stable/cuda/index.html>`_.
 If numba is not available, KyuPy will automatically fall back to slow, pure Python execution.
 
-The Jupyter Notebook `Demo.ipynb <https://github.com/s-holst/kyupy/blob/main/Demo.ipynb>`_ contains some useful examples to get familiar with the API.
+The Jupyter Notebook `Introduction.ipynb <https://github.com/s-holst/kyupy/blob/main/examples/Introduction.ipynb>`_ contains some useful examples to get familiar with the API.
 
-To work with the latest pre-release source code, clone the `KyuPy GitHub repository <https://github.com/s-holst/kyupy>`_.
-Run ``pip3 install --user -e .`` within your local checkout to make the package available in your Python environment.
-The source code comes with tests that can be run with ``pytest``.
 
+Development
+-----------
 
+To work with the latest pre-release source code, clone the `KyuPy GitHub repository <https://github.com/s-holst/kyupy>`_.
+Run ``pip install -e .`` within your local checkout to make the package available in your Python environment.
+The source code comes with tests that can be run with ``pytest``.
```

## Comparing `kyupy-0.0.3.dist-info/RECORD` & `kyupy-0.0.4.dist-info/RECORD`

 * *Files 24% similar despite different names*

```diff
@@ -1,15 +1,17 @@
-kyupy/__init__.py,sha256=toFZqyJKf4OvTlK3vtW0VeYsRN49xrm5rqcJ63Af28M,6525
-kyupy/bench.py,sha256=kjOLhQaMZBmilg5dLhbfhHdtQT9aT4SeDPxKTzdgXHA,2193
-kyupy/circuit.py,sha256=qI2exTWveVB_q2527s69rtZW-GZ2EduxsNIwEm_wuGc,13807
-kyupy/logic.py,sha256=Lm-FKaXzquIQtBzv5n2JavPcW1oma2PWLfp-BvPWlrc,18716
-kyupy/logic_sim.py,sha256=LWunqOVGYVZhc5QmAF_Nl-XdNxzHcWZtOih_M-T-iPU,7978
-kyupy/sdf.py,sha256=F-v4v1bBUnTtOXLsjb1xJ4ExIl5w0tWLPHBolfky2_s,9636
-kyupy/stil.py,sha256=J_zgbYsLvqbUV7lJULRzpQiaPrBhZkKyPpeoZFpkhPo,10357
-kyupy/techlib.py,sha256=x7G8lbnE-uiexascCbQ4dgC1IbLYOknRrEW2BJvQE-0,16958
-kyupy/verilog.py,sha256=CsQgoXasxbrdds_wvg7jXo0MrOZnv1G70JzUOr5xfkU,6934
-kyupy/wave_sim.py,sha256=SjghgcfphL7gik0AgzPjtZzQslDUBaV2nY2ojQHvhR8,37626
-kyupy-0.0.3.dist-info/LICENSE.txt,sha256=UnYgrIwPANqKzlve1hKQhYHTeb1MYnGwXFCopLUe5FA,1074
-kyupy-0.0.3.dist-info/METADATA,sha256=IxxNpo010CLFrQ_DEjjBU-9BJc9xB1plOYzUzAa6W-4,2780
-kyupy-0.0.3.dist-info/WHEEL,sha256=OqRkF0eY5GHssMorFjlbTIq072vpHpF60fIQA6lS9xA,92
-kyupy-0.0.3.dist-info/top_level.txt,sha256=yvBjxFd_JKj7T7nmdlXc0dr-7Q8BUxo5HoB_B3bDGtk,6
-kyupy-0.0.3.dist-info/RECORD,,
+kyupy/__init__.py,sha256=XNe6rY9NlSjyqkBUTwG2Rmyuhu6_n_bHicTN-10o6hg,9406
+kyupy/bench.py,sha256=vrmCT-K9H3j_gd382aS-V8igZ6arvRNTRZhUWbwBOEI,2244
+kyupy/circuit.py,sha256=mMEE-A1xTxhOk8hCF_jR6tZV6G1QARv5Es7nv3hij5o,27685
+kyupy/def_file.py,sha256=mKFZPujpT0Fg74mMNn-8B7hVHVlt5tkgunuXeR8o45w,10262
+kyupy/logic.py,sha256=DMeNUDbrjoFTRCIfOW7HONylNTx_lkGQo2KIDfPTMoY,16828
+kyupy/logic_sim.py,sha256=WEpuSsUY390CweOLz2fzRPdVfsk60dhgSADeD6-d6_M,22213
+kyupy/sdf.py,sha256=Bs8rGFfePn3_CauGlqxfQYdlS30J0cccuKtQ_b83DKI,8637
+kyupy/sim.py,sha256=B9wgCo2gpRexzAFGvnM_r1IAVItzX5OFDNo7rvbSc_o,14994
+kyupy/stil.py,sha256=DlXqgVfT0O5Flb7_OhYA6Pj2OtnlvFY4HBRzxLUCM_M,12625
+kyupy/techlib.py,sha256=f7gQ-FrNIOWmhcZdvi8ADiHlKK2vHqauWyUeGoysVtE,21997
+kyupy/verilog.py,sha256=plM9_moyYTCt6BNSBfq9QzdqFKuniHjHTkhyy2bzI0k,10513
+kyupy/wave_sim.py,sha256=RHtaR4QTcuKnHvWnRnQ_dZo32vQNqk_DOD6YOaO7o_c,21260
+kyupy-0.0.4.dist-info/LICENSE.txt,sha256=cbNLG1vR3mnhbsAx_EpMWXm85QYX-TlZlSCuX1AR2wQ,1074
+kyupy-0.0.4.dist-info/METADATA,sha256=vcPdviG2qFb5alCd1F_GlJ11zNErNu5JQKXnOkgoQVY,2790
+kyupy-0.0.4.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+kyupy-0.0.4.dist-info/top_level.txt,sha256=yvBjxFd_JKj7T7nmdlXc0dr-7Q8BUxo5HoB_B3bDGtk,6
+kyupy-0.0.4.dist-info/RECORD,,
```

